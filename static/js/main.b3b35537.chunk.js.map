{"version":3,"sources":["PageFlip/Page/Page.ts","PageFlip/Flip/Flip.ts","PageFlip/Page/ImagePage.ts","PageFlip/Helper.ts","PageFlip/Flip/FlipCalculation.ts","PageFlip/Settings.ts","PageFlip/Render/Render.ts","PageFlip/Collection/PageCollection.ts","PageFlip/Collection/ImagePageCollection.ts","PageFlip/Page/HTMLPage.ts","PageFlip/Collection/HTMLPageCollection.ts","PageFlip/Render/CanvasRender.ts","PageFlip/UI/UI.ts","PageFlip/UI/HTMLUI.ts","PageFlip/UI/CanvasUI.ts","PageFlip/Event/EventObject.ts","PageFlip/Render/HTMLRender.ts","PageFlip/PageFlip.ts","PageFlip/react-pageflip/html-flip-book/index.tsx","PageFlip/react-pageflip/index.ts","ImageBook/Page/Page.jsx","Router.js","ImageBook/ImageBook.jsx","reportWebVitals.js","index.js"],"names":["PageOrientation","PageDensity","FlipDirection","FlipCorner","FlippingState","Page","render","density","state","orientation","createdDensity","nowDrawingDensity","this","angle","area","position","x","y","hardAngle","hardDrawingAngle","pagePos","ImagePage","href","image","isLoad","loadingAngle","Image","src","tempDensity","ctx","getContext","convertToGlobal","pageWidth","getRect","pageHeight","height","save","translate","beginPath","p","lineTo","rotate","clip","drawImage","drawLoader","restore","orient","rect","RIGHT","left","top","shiftPos","strokeStyle","fillStyle","lineWidth","stroke","fill","middlePoint","arc","Math","PI","closePath","onload","Helper","point1","point2","Infinity","sqrt","pow","segment","GetDistanceBetweenTwoPoint","line1","line2","A1","A2","B1","B2","acos","pos","width","transformedPoint","startPoint","cos","sin","radius","limitedPoint","a","b","n","m","rectBorder","one","two","PointInRect","GetIntersectBeetwenTwoLine","C1","C2","det1","det2","isFinite","abs","Error","pointOne","pointTwo","sizeX","sizeY","lengthLine","max","result","getCord","c1","c2","size","length","index","i","push","FlipCalculation","direction","corner","topIntersectPoint","sideIntersectPoint","bottomIntersectPoint","parseInt","localPos","calcAngleAndPosition","calculateIntersectPoint","e","clipBottom","topLeft","BOTTOM","bottomLeft","TOP","FORWARD","topRight","BACK","GetAngleBetweenTwoLine","getSegmentToShadowLine","updateAngleAndGeometry","checkPositionAtCenterLine","calculateAngle","getPageRect","da","getRectFromBasePoint","points","getRotatedPoint","bottomRight","boundRect","GetIntersectBetweenTwoSegment","checkedPos","centerOne","centerTwo","tmp","LimitPointToCircle","rad","checkPointOne","checkPointTwo","bottomPoint","first","getShadowStartPoint","SizeType","Flip","app","flippingPage","bottomPage","calc","READ","globalPos","setState","USER_FOLD","start","do","convertToPage","getSettings","disableFlipByClick","isPointOnCorners","finishAnimation","getBoundsRect","FLIPPING","topMargins","yStart","getCorner","yDest","animateFlippingTo","reset","bookPos","convertToBook","getDirectionByPoint","flipCorner","checkDirection","getPageCollection","getFlippingPage","getBottomPage","getOrientation","Orientation","LANDSCAPE","nextPage","nextBy","getDensity","setDrawingDensity","HARD","prevPage","prevBy","setDirection","toString","progress","getFlippingProgress","setArea","getBottomClipArea","setPosition","getBottomPagePosition","setAngle","setHardAngle","getFlippingClipArea","getActiveCorner","getAngle","getDirection","setPageRect","setBottomPage","setFlippingPage","setShadowData","getShadowAngle","page","current","getCurrentSpreadIndex","next","getSpreadIndexByPage","setCurrentSpreadIndex","flipNext","flipPrev","flip","getPosition","checkState","FOLD_CORNER","stopMove","dest","isTurned","needReset","GetCordsFromTwoPoint","frames","duration","getAnimationDuration","startAnimation","turnToPrevPage","turnToNextPage","clearShadow","newState","updateState","touchPos","PORTRAIT","defaultTime","flippingTime","getCurrentPageIndex","getPageCount","states","operatingDistance","Settings","_default","startPage","FIXED","minWidth","maxWidth","minHeight","maxHeight","drawShadow","usePortrait","startZIndex","autoSize","maxShadowOpacity","showCover","mobileScrollSupport","swipeDistance","clickEventForward","useMouseEvents","showPageCorners","userSetting","Object","assign","STRETCH","Render","setting","leftPage","rightPage","shadow","animation","pageRect","boundsRect","timer","safari","regex","RegExp","exec","window","navigator","userAgent","frameIndex","round","startedAt","durationFrame","onAnimateEnd","drawFrame","update","requestAnimationFrame","loop","calculateBoundsRect","updateOrientation","blockWidth","getBlockWidth","getBlockHeight","ratio","opacity","getUI","getDistElement","offsetWidth","offsetHeight","setOrientation","LEFT","PageCollection","isShowCover","pages","currentPageIndex","currentSpreadIndex","landscapeSpread","portraitSpread","setDensity","pageNum","spread","getSpread","pageIndex","idx","indexOf","newTemporaryCopy","showSpread","spreadIndex","newIndex","setLeftPage","setRightPage","updatePageIndex","ImagePageCollection","imagesHref","SOFT","load","createSpread","HTMLPage","element","copiedElement","temporaryCopy","classList","add","cloneNode","parentElement","appendChild","getTemporaryCopy","remove","style","display","drawHard","drawSoft","backfaceVisibility","setProperty","transformOrigin","transform","clipPath","polygon","g","GetRotatedPoint","slice","isSafari","contains","cssText","HTMLPageCollection","items","pagesElement","pageElement","dataset","CanvasRender","inCanvas","canvas","clear","simpleDraw","draw","drawBookShadow","drawOuterShadow","drawInnerShadow","shadowSize","shadowPos","outerGradient","createLinearGradient","addColorStop","fillRect","convertRectToGlobal","moveTo","isw","innerGradient","UI","inBlock","wrapper","distElement","touchPoint","swipeTimeout","onResize","onMouseDown","checkTarget","target","getMousePos","clientX","clientY","startUserTouch","preventDefault","onTouchStart","changedTouches","t","point","time","Date","now","setTimeout","onMouseUp","userStop","onMouseMove","userMove","onTouchMove","getState","cancelable","onTouchEnd","isSwipe","dx","distY","getRender","insertAdjacentHTML","querySelector","k","addEventListener","removeHandlers","paddingBottom","removeEventListener","passive","getBoundingClientRect","Array","isArray","includes","tagName","toLowerCase","HTMLUI","item","setHandlers","innerHTML","CanvasUI","querySelectorAll","resizeCanvas","cs","getComputedStyle","getPropertyValue","EventObject","events","Map","eventName","callback","has","get","set","event","delete","data","object","HTMLRender","outerShadow","innerShadow","hardShadow","hardInnerShadow","createShadows","innerShadowSize","zIndex","background","shadowTranslate","shadowDirection","getDrawingDensity","getElement","setHardDrawingAngle","getHardAngle","drawLeftPage","drawRightPage","drawBottomPage","drawHardOuterShadow","drawHardInnerShadow","getPages","hideTemporaryCopy","clearSaved","PageFlip","mousePosition","isUserTouch","isUserMove","block","flipController","ui","destroy","show","getCanvas","trigger","mode","updateItems","reload","showPrev","showNext","flipToPage","newPage","newOrientation","setOrientationStyle","getPage","isTouch","fold","showCorner","HTMLFlipBookForward","React","forwardRef","props","ref","htmlElementRef","useRef","childRef","pageFlip","useState","setPages","useImperativeHandle","refreshOnPageDelete","useCallback","off","useEffect","children","childList","Children","map","child","cloneElement","dom","renderOnlyPageLengthChange","getFlipController","updateFromHtml","loadFromHTML","onFlip","on","onChangeOrientation","onChangeState","onInit","onUpdate","className","HTMLFlipBook","memo","type","data-density","isNaN","pageNumber","pageTitle","no_animation","undefined","content","margin","float","process","alt","dangerouslySetInnerHTML","__html","html","outerHTML","imageCaption","onClick","console","log","requestFullscreen","then","onLoad","Router","options","routes","root","path","cb","flush","clearSlashes","replace","getFragment","fragment","decodeURI","location","pathname","search","match","navigate","history","pushState","listen","clearInterval","interval","setInterval","some","route","shift","apply","ImageBook","language","setLanguage","renderedPages","setRenderedPages","pageMap","setPageMap","chapters","pageOfContents","pageData","setPageData","routingStrategy","setPage","router","setRouter","flipBook","fetch","headers","res","json","pageArray","_pageData","preparePages","chapter","String","pagenumber","navigateToPage","pagetitle","_renderedPages","concat","_pageMap","reduce","_router","_page","isNumeric","Number","updateRenderedPages","updatedRenderedPages","updatedPageMap","err","alert","error","openBookmark","localStorage","getItem","pageCount","htmlpages","cutHTMLIntoPieces","forEach","inputProps","key","bookmark","onBookmark","imagename","imagecaption","hiddendiv","document","createElement","id","visibility","fontSize","arr","body","childNodes","node","nodeType","textContent","clientHeight","removeChild","hash","substring","split","str","parseFloat","title","class","backgroundImage","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","getElementById"],"mappings":"sMAuBYA,EAQAC,E,oHARAD,O,eAAAA,I,kBAAAA,M,cAQAC,K,YAAAA,E,aAAAA,M,KAQL,IC7BKC,EAQAC,EAQAC,EDaUC,EAAtB,WAcE,WAAsBC,EAAgBC,GAAuB,yBAZnDC,WAYkD,OAVlDF,YAUkD,OAPlDG,iBAOkD,OAJlDC,oBAIkD,OAFlDC,uBAEkD,EAC1DC,KAAKJ,MAAQ,CACXK,MAAO,EACPC,KAAM,GACNC,SAAU,CAAEC,EAAG,EAAGC,EAAG,GACrBC,UAAW,EACXC,iBAAkB,GAGpBP,KAAKF,eAAiBH,EACtBK,KAAKD,kBAAoBC,KAAKF,eAE9BE,KAAKN,OAASA,EA1BlB,uDAqDoBC,GAChBK,KAAKF,eAAiBH,EACtBK,KAAKD,kBAAoBJ,IAvD7B,wCA+D2BA,GACvBK,KAAKD,kBAAoBJ,IAhE7B,kCAwEqBa,GACjBR,KAAKJ,MAAMO,SAAWK,IAzE1B,+BAiFkBP,GACdD,KAAKJ,MAAMK,MAAQA,IAlFvB,8BA0FiBC,GACbF,KAAKJ,MAAMM,KAAOA,IA3FtB,0CAmG6BD,GACzBD,KAAKJ,MAAMW,iBAAmBN,IApGlC,mCA4GsBA,GAClBD,KAAKJ,MAAMU,UAAYL,EACvBD,KAAKJ,MAAMW,iBAAmBN,IA9GlC,qCAsHwBJ,GACpBG,KAAKH,YAAcA,IAvHvB,0CA8HI,OAAOG,KAAKD,oBA9HhB,mCAqII,OAAOC,KAAKF,iBArIhB,qCA4II,OAAOE,KAAKJ,MAAMU,cA5ItB,KE/BaG,EAAb,kDAMI,WAAYf,EAAgBgB,EAAcf,GAAuB,IAAD,8BAC5D,cAAMD,EAAQC,IANDgB,MAA0B,KAKqB,EAJxDC,QAAS,EAI+C,EAFxDC,aAAe,EAKnB,EAAKF,MAAQ,IAAIG,MACjB,EAAKH,MAAMI,IAAML,EAJ2C,EANpE,iDAagBM,GACR,IAAMC,EAAOjB,KAAKN,OAAwBwB,aAEpCV,EAAUR,KAAKN,OAAOyB,gBAAgBnB,KAAKJ,MAAMO,UACjDiB,EAAYpB,KAAKN,OAAO2B,UAAUD,UAClCE,EAAatB,KAAKN,OAAO2B,UAAUE,OAEzCN,EAAIO,OACJP,EAAIQ,UAAUjB,EAAQJ,EAAGI,EAAQH,GACjCY,EAAIS,YATqC,oBAW3B1B,KAAKJ,MAAMM,MAXgB,IAWzC,2BAA+B,CAAC,IAAvByB,EAAsB,QACjB,OAANA,IACAA,EAAI3B,KAAKN,OAAOyB,gBAAgBQ,GAChCV,EAAIW,OAAOD,EAAEvB,EAAII,EAAQJ,EAAGuB,EAAEtB,EAAIG,EAAQH,KAdT,8BAkBzCY,EAAIY,OAAO7B,KAAKJ,MAAMK,OAEtBgB,EAAIa,OAEC9B,KAAKY,OAGNK,EAAIc,UAAU/B,KAAKW,MAAO,EAAG,EAAGS,EAAWE,GAF3CtB,KAAKgC,WAAWf,EAAK,CAAEb,EAAG,EAAGC,EAAG,GAAKe,EAAWE,GAKpDL,EAAIgB,YAzCZ,iCA4CsBC,GACd,IAAMC,EAAOnC,KAAKN,OAAO2B,UACnBJ,EAAOjB,KAAKN,OAAwBwB,aAEpCE,EAAYe,EAAKf,UACjBE,EAAaa,EAAKZ,OAElBnB,EAAI8B,IAAW9C,EAAgBgD,MAAQD,EAAKE,KAAOF,EAAKf,UAAYe,EAAKE,KAEzEhC,EAAI8B,EAAKG,IAEVtC,KAAKY,OAGNK,EAAIc,UAAU/B,KAAKW,MAAOP,EAAGC,EAAGe,EAAWE,GAF3CtB,KAAKgC,WAAWf,EAAK,CAAEb,IAAGC,KAAKe,EAAWE,KAxDtD,iCA+DQL,EACAsB,EACAnB,EACAE,GAEAL,EAAIS,YACJT,EAAIuB,YAAc,qBAClBvB,EAAIwB,UAAY,qBAChBxB,EAAIyB,UAAY,EAChBzB,EAAIkB,KAAKI,EAASnC,EAAI,EAAGmC,EAASlC,EAAI,EAAGe,EAAY,EAAGE,EAAa,GACrEL,EAAI0B,SACJ1B,EAAI2B,OAEJ,IAAMC,EAAqB,CACvBzC,EAAGmC,EAASnC,EAAIgB,EAAY,EAC5Bf,EAAGkC,EAASlC,EAAIiB,EAAa,GAGjCL,EAAIS,YACJT,EAAIyB,UAAY,GAChBzB,EAAI6B,IACAD,EAAYzC,EACZyC,EAAYxC,EACZ,GACAL,KAAKa,aACJ,EAAIkC,KAAKC,GAAM,EAAIhD,KAAKa,cAE7BI,EAAI0B,SACJ1B,EAAIgC,YAEJjD,KAAKa,cAAgB,IACjBb,KAAKa,cAAgB,EAAIkC,KAAKC,KAC9BhD,KAAKa,aAAe,KA/FhC,6BAmGyB,IAAD,OACXb,KAAKY,SACNZ,KAAKW,MAAMuC,OAAS,WAChB,EAAKtC,QAAS,MAtG9B,yCA2GQ,OAAOZ,OA3Gf,yCA+GQ,OAAOA,OA/Gf,kDAA+BP,GCHlB0D,EAAb,wHAO6CC,EAAeC,GACpD,OAAe,OAAXD,GAA8B,OAAXC,EACZC,IAGJP,KAAKQ,KAAKR,KAAKS,IAAIH,EAAOjD,EAAIgD,EAAOhD,EAAG,GAAK2C,KAAKS,IAAIH,EAAOhD,EAAI+C,EAAO/C,EAAG,MAZ1F,uCAoBmCoD,GAC3B,OAAON,EAAOO,2BAA2BD,EAAQ,GAAIA,EAAQ,MArBrE,6CA8ByCE,EAAgBC,GACjD,IAAMC,EAAKF,EAAM,GAAGtD,EAAIsD,EAAM,GAAGtD,EAC3ByD,EAAKF,EAAM,GAAGvD,EAAIuD,EAAM,GAAGvD,EAE3B0D,EAAKJ,EAAM,GAAGvD,EAAIuD,EAAM,GAAGvD,EAC3B4D,EAAKJ,EAAM,GAAGxD,EAAIwD,EAAM,GAAGxD,EAEjC,OAAO2C,KAAKkB,MAAMJ,EAAKC,EAAKC,EAAKC,IAAOjB,KAAKQ,KAAKM,EAAKA,EAAKE,EAAKA,GAAMhB,KAAKQ,KAAKO,EAAKA,EAAKE,EAAKA,OArCxG,kCAgD8B7B,EAAY+B,GAClC,OAAY,OAARA,EACO,KAIPA,EAAI9D,GAAK+B,EAAKE,MACd6B,EAAI9D,GAAK+B,EAAKgC,MAAQhC,EAAKE,MAC3B6B,EAAI7D,GAAK8B,EAAKG,KACd4B,EAAI7D,GAAK8B,EAAKG,IAAMH,EAAKZ,OAElB2C,EAEJ,OA7Df,sCAyEkCE,EAAyBC,EAAmBpE,GACtE,MAAO,CACHG,EAAGgE,EAAiBhE,EAAI2C,KAAKuB,IAAIrE,GAASmE,EAAiB/D,EAAI0C,KAAKwB,IAAItE,GAASoE,EAAWjE,EAC5FC,EAAG+D,EAAiB/D,EAAI0C,KAAKuB,IAAIrE,GAASmE,EAAiBhE,EAAI2C,KAAKwB,IAAItE,GAASoE,EAAWhE,KA5ExG,yCA0FqCgE,EAAmBG,EAAgBC,GAEhE,GAAItB,EAAOO,2BAA2BW,EAAYI,IAAiBD,EAC/D,OAAOC,EAGX,IAAMC,EAAIL,EAAWjE,EACfuE,EAAIN,EAAWhE,EACfuE,EAAIH,EAAarE,EACjByE,EAAIJ,EAAapE,EAGnBD,EAAI2C,KAAKQ,KAAMR,KAAKS,IAAIgB,EAAQ,GAAKzB,KAAKS,IAAIkB,EAAIE,EAAG,IAAO7B,KAAKS,IAAIkB,EAAIE,EAAG,GAAK7B,KAAKS,IAAImB,EAAIE,EAAG,KAAOH,EACxGD,EAAarE,EAAI,IACjBA,IAAM,GAGV,IAAIC,GAAMD,EAAIsE,IAAMC,EAAIE,IAAOH,EAAIE,GAAKD,EAKxC,OAJID,EAAIE,EAAID,IAAM,IACdtE,EAAImE,GAGD,CAAEpE,IAAGC,OAhHpB,oDA4HgDyE,EAAkBC,EAAcC,GACxE,OAAO7B,EAAO8B,YAAYH,EAAY3B,EAAO+B,2BAA2BH,EAAKC,MA7HrF,iDAyI6CD,EAAcC,GACnD,IAAMnB,EAAKkB,EAAI,GAAG1E,EAAI0E,EAAI,GAAG1E,EACvByD,EAAKkB,EAAI,GAAG3E,EAAI2E,EAAI,GAAG3E,EAEvB0D,EAAKgB,EAAI,GAAG3E,EAAI2E,EAAI,GAAG3E,EACvB4D,EAAKgB,EAAI,GAAG5E,EAAI4E,EAAI,GAAG5E,EAEvB+E,EAAKJ,EAAI,GAAG3E,EAAI2E,EAAI,GAAG1E,EAAI0E,EAAI,GAAG3E,EAAI2E,EAAI,GAAG1E,EAC7C+E,EAAKJ,EAAI,GAAG5E,EAAI4E,EAAI,GAAG3E,EAAI2E,EAAI,GAAG5E,EAAI4E,EAAI,GAAG3E,EAE7CgF,EAAOxB,EAAKuB,EAAKtB,EAAKqB,EACtBG,EAAOvB,EAAKqB,EAAKpB,EAAKmB,EAEtB/E,IAAO+E,EAAKnB,EAAKoB,EAAKrB,IAAOF,EAAKG,EAAKF,EAAKC,GAC5C1D,IAAOwD,EAAKuB,EAAKtB,EAAKqB,IAAOtB,EAAKG,EAAKF,EAAKC,GAElD,GAAIwB,SAASnF,IAAMmF,SAASlF,GACxB,MAAO,CAAED,IAAGC,KAEZ,GAAI0C,KAAKyC,IAAIH,EAAOC,GAAQ,GAAK,MAAM,IAAIG,MAAM,oBAGrD,OAAO,OA/Jf,2CA0KuCC,EAAiBC,GAChD,IAAMC,EAAQ7C,KAAKyC,IAAIE,EAAStF,EAAIuF,EAASvF,GACvCyF,EAAQ9C,KAAKyC,IAAIE,EAASrF,EAAIsF,EAAStF,GAEvCyF,EAAa/C,KAAKgD,IAAIH,EAAOC,GAE7BG,EAAkB,CAACN,GAEzB,SAASO,EAAQC,EAAYC,EAAYC,EAAcC,EAAgBC,GACnE,OAAIH,EAAKD,EACEA,EAAKI,GAASF,EAAOC,GACrBF,EAAKD,EACLA,EAAKI,GAASF,EAAOC,GAGzBH,EAGX,IAAK,IAAIK,EAAI,EAAGA,GAAKT,EAAYS,GAAK,EAClCP,EAAOQ,KAAK,CACRpG,EAAG6F,EAAQP,EAAStF,EAAGuF,EAASvF,EAAGwF,EAAOE,EAAYS,GACtDlG,EAAG4F,EAAQP,EAASrF,EAAGsF,EAAStF,EAAGwF,EAAOC,EAAYS,KAI9D,OAAOP,MAnMf,KCEaS,EAAb,WAwBE,WACUC,EACAC,EAERvF,EACAE,GACC,yBALOoF,YAKR,KAJQC,SAIR,KA5BM1G,WA4BN,OA1BME,cA0BN,OAxBMgC,UAwBN,OArBMyE,kBAA2B,KAqBjC,KApBMC,mBAA4B,KAoBlC,KAnBMC,qBAA8B,KAmBpC,KAjBe1F,eAiBf,OAhBeE,gBAgBf,EACAtB,KAAKoB,UAAY2F,SAAS3F,EAAW,IACrCpB,KAAKsB,WAAayF,SAASzF,EAAY,IAhC3C,iDA0Cc0F,GACV,IAME,OAJAhH,KAAKG,SAAWH,KAAKiH,qBAAqBD,GAE1ChH,KAAKkH,wBAAwBlH,KAAKG,WAE3B,EACP,MAAOgH,GACP,OAAO,KAnDb,4CA6DI,IAAMnB,EAAS,GACXoB,GAAa,EAmBjB,OAjBApB,EAAOQ,KAAKxG,KAAKmC,KAAKkF,SACtBrB,EAAOQ,KAAKxG,KAAK4G,mBAEe,OAA5B5G,KAAK6G,mBACPO,GAAa,GAEbpB,EAAOQ,KAAKxG,KAAK6G,oBAEiB,OAA9B7G,KAAK8G,uBAA+BM,GAAa,IAGvDpB,EAAOQ,KAAKxG,KAAK8G,uBAEbM,GAAcpH,KAAK2G,SAAWpH,EAAW+H,SAC3CtB,EAAOQ,KAAKxG,KAAKmC,KAAKoF,YAGjBvB,IAjFX,0CA0FI,IAAMA,EAAS,GA8Bf,OA5BAA,EAAOQ,KAAKxG,KAAK4G,mBAEb5G,KAAK2G,SAAWpH,EAAWiI,IAC7BxB,EAAOQ,KAAK,CAAEpG,EAAGJ,KAAKoB,UAAWf,EAAG,KAEL,OAA3BL,KAAK4G,mBACPZ,EAAOQ,KAAK,CAAEpG,EAAGJ,KAAKoB,UAAWf,EAAG,IAEtC2F,EAAOQ,KAAK,CAAEpG,EAAGJ,KAAKoB,UAAWf,EAAGL,KAAKsB,cAGX,OAA5BtB,KAAK6G,mBAEL1D,EAAOO,2BACL1D,KAAK6G,mBACL7G,KAAK4G,oBACF,IAELZ,EAAOQ,KAAKxG,KAAK6G,oBAEf7G,KAAK2G,SAAWpH,EAAWiI,KAC7BxB,EAAOQ,KAAK,CAAEpG,EAAGJ,KAAKoB,UAAWf,EAAGL,KAAKsB,aAI7C0E,EAAOQ,KAAKxG,KAAK8G,sBACjBd,EAAOQ,KAAKxG,KAAK4G,mBAEVZ,IAxHX,iCA+HI,OAAIhG,KAAK0G,YAAcpH,EAAcmI,SAC3BzH,KAAKC,MAGRD,KAAKC,QAnIhB,gCA0II,OAAOD,KAAKmC,OA1IhB,oCAiJI,OAAOnC,KAAKG,WAjJhB,wCAwJI,OAAIH,KAAK0G,YAAcpH,EAAcmI,QAC5BzH,KAAKmC,KAAKkF,QAGZrH,KAAKmC,KAAKuF,WA5JrB,qCAmKI,OAAO1H,KAAK0G,YAnKhB,4CA0KI,OAAO3D,KAAKyC,KAAMxF,KAAKG,SAASC,EAAIJ,KAAKoB,YAAc,EAAIpB,KAAKoB,WAAc,OA1KlF,kCAiLI,OAAOpB,KAAK2G,SAjLhB,8CAwLI,OAAI3G,KAAK0G,YAAcpH,EAAcqI,KAC5B,CAAEvH,EAAGJ,KAAKoB,UAAWf,EAAG,GAG1B,CAAED,EAAG,EAAGC,EAAG,KA5LtB,4CAmMI,OAAIL,KAAK2G,SAAWpH,EAAWiI,IACtBxH,KAAK4G,kBAEoB,OAA5B5G,KAAK6G,mBAAoC7G,KAAK6G,mBAE3C7G,KAAK4G,oBAxMlB,uCAgNI,IAAM3G,EAAQkD,EAAOyE,uBAAuB5H,KAAK6H,yBAA0B,CACzE,CAAEzH,EAAG,EAAGC,EAAG,GACX,CAAED,EAAGJ,KAAKoB,UAAWf,EAAG,KAG1B,OAAIL,KAAK0G,YAAcpH,EAAcmI,QAC5BxH,EAGF8C,KAAKC,GAAK/C,IAzNrB,2CA4N+BiE,GAC3B,IAAI8B,EAAS9B,EAkBb,GAhBAlE,KAAK8H,uBAAuB9B,GAG1BA,EADEhG,KAAK2G,SAAWpH,EAAWiI,IACpBxH,KAAK+H,0BACZ/B,EACA,CAAE5F,EAAG,EAAGC,EAAG,GACX,CAAED,EAAG,EAAGC,EAAGL,KAAKsB,aAGTtB,KAAK+H,0BACZ/B,EACA,CAAE5F,EAAG,EAAGC,EAAGL,KAAKsB,YAChB,CAAElB,EAAG,EAAGC,EAAG,IAIX0C,KAAKyC,IAAIQ,EAAO5F,EAAIJ,KAAKoB,WAAa,GAAK2B,KAAKyC,IAAIQ,EAAO3F,GAAK,EAClE,MAAM,IAAIoF,MAAM,sBAGlB,OAAOO,IAnPX,6CAsPiC9B,GAC7BlE,KAAKC,MAAQD,KAAKgI,eAAe9D,GACjClE,KAAKmC,KAAOnC,KAAKiI,YAAY/D,KAxPjC,qCA2PyBA,GACrB,IAAM7B,EAAOrC,KAAKoB,UAAY8C,EAAI9D,EAAI,EAChCkC,EAAMtC,KAAK2G,SAAWpH,EAAW+H,OAAStH,KAAKsB,WAAa4C,EAAI7D,EAAI6D,EAAI7D,EAE1EJ,EAAQ,EAAI8C,KAAKkB,KAAK5B,EAAOU,KAAKQ,KAAKjB,EAAMA,EAAMD,EAAOA,IAE1DC,EAAM,IAAGrC,GAASA,GAEtB,IAAMiI,EAAKnF,KAAKC,GAAK/C,EACrB,IAAKsF,SAAStF,IAAWiI,GAAM,GAAKA,EAAK,KACvC,MAAM,IAAIzC,MAAM,4BAIlB,OAFIzF,KAAK2G,SAAWpH,EAAW+H,SAAQrH,GAASA,GAEzCA,IAzQX,kCA6QsB+G,GAClB,OAAIhH,KAAK2G,SAAWpH,EAAWiI,IACtBxH,KAAKmI,qBACV,CACE,CAAE/H,EAAG,EAAGC,EAAG,GACX,CAAED,EAAGJ,KAAKoB,UAAWf,EAAG,GACxB,CAAED,EAAG,EAAGC,EAAGL,KAAKsB,YAChB,CAAElB,EAAGJ,KAAKoB,UAAWf,EAAGL,KAAKsB,aAE/B0F,GAIGhH,KAAKmI,qBACV,CACE,CAAE/H,EAAG,EAAGC,GAAIL,KAAKsB,YACjB,CAAElB,EAAGJ,KAAKoB,UAAWf,GAAIL,KAAKsB,YAC9B,CAAElB,EAAG,EAAGC,EAAG,GACX,CAAED,EAAGJ,KAAKoB,UAAWf,EAAG,IAE1B2G,KAjSN,2CAqS+BoB,EAAiBpB,GAC5C,MAAO,CACLK,QAASrH,KAAKqI,gBAAgBD,EAAO,GAAIpB,GACzCU,SAAU1H,KAAKqI,gBAAgBD,EAAO,GAAIpB,GAC1CO,WAAYvH,KAAKqI,gBAAgBD,EAAO,GAAIpB,GAC5CsB,YAAatI,KAAKqI,gBAAgBD,EAAO,GAAIpB,MA1SnD,sCA8S0B5C,EAAyBC,GAC/C,MAAO,CACLjE,EACEgE,EAAiBhE,EAAI2C,KAAKuB,IAAItE,KAAKC,OACnCmE,EAAiB/D,EAAI0C,KAAKwB,IAAIvE,KAAKC,OACnCoE,EAAWjE,EACbC,EACE+D,EAAiB/D,EAAI0C,KAAKuB,IAAItE,KAAKC,OACnCmE,EAAiBhE,EAAI2C,KAAKwB,IAAIvE,KAAKC,OACnCoE,EAAWhE,KAvTnB,8CA2TkC6D,GAC9B,IAAMqE,EAAkB,CACtBlG,MAAO,EACPC,KAAM,EACN6B,MAAOnE,KAAKoB,UAAY,EACxBG,OAAQvB,KAAKsB,WAAa,GAGxBtB,KAAK2G,SAAWpH,EAAWiI,KAC7BxH,KAAK4G,kBAAoBzD,EAAOqF,8BAC9BD,EACA,CAACrE,EAAKlE,KAAKmC,KAAKuF,UAChB,CACE,CAAEtH,EAAG,EAAGC,EAAG,GACX,CAAED,EAAGJ,KAAKoB,UAAWf,EAAG,KAI5BL,KAAK6G,mBAAqB1D,EAAOqF,8BAC/BD,EACA,CAACrE,EAAKlE,KAAKmC,KAAKoF,YAChB,CACE,CAAEnH,EAAGJ,KAAKoB,UAAWf,EAAG,GACxB,CAAED,EAAGJ,KAAKoB,UAAWf,EAAGL,KAAKsB,cAIjCtB,KAAK8G,qBAAuB3D,EAAOqF,8BACjCD,EACA,CAACvI,KAAKmC,KAAKoF,WAAYvH,KAAKmC,KAAKmG,aACjC,CACE,CAAElI,EAAG,EAAGC,EAAGL,KAAKsB,YAChB,CAAElB,EAAGJ,KAAKoB,UAAWf,EAAGL,KAAKsB,gBAIjCtB,KAAK4G,kBAAoBzD,EAAOqF,8BAC9BD,EACA,CAACvI,KAAKmC,KAAKkF,QAASrH,KAAKmC,KAAKuF,UAC9B,CACE,CAAEtH,EAAG,EAAGC,EAAG,GACX,CAAED,EAAGJ,KAAKoB,UAAWf,EAAG,KAI5BL,KAAK6G,mBAAqB1D,EAAOqF,8BAC/BD,EACA,CAACrE,EAAKlE,KAAKmC,KAAKkF,SAChB,CACE,CAAEjH,EAAGJ,KAAKoB,UAAWf,EAAG,GACxB,CAAED,EAAGJ,KAAKoB,UAAWf,EAAGL,KAAKsB,cAIjCtB,KAAK8G,qBAAuB3D,EAAOqF,8BACjCD,EACA,CAACvI,KAAKmC,KAAKoF,WAAYvH,KAAKmC,KAAKmG,aACjC,CACE,CAAElI,EAAG,EAAGC,EAAGL,KAAKsB,YAChB,CAAElB,EAAGJ,KAAKoB,UAAWf,EAAGL,KAAKsB,iBAtXvC,gDA6XImH,EACAC,EACAC,GAEA,IAAI3C,EAASyC,EAEPG,EAAMzF,EAAO0F,mBAAmBH,EAAW1I,KAAKoB,UAAW4E,GAC7DA,IAAW4C,IACb5C,EAAS4C,EACT5I,KAAK8H,uBAAuB9B,IAG9B,IAAM8C,EAAM/F,KAAKQ,KAAKR,KAAKS,IAAIxD,KAAKoB,UAAW,GAAK2B,KAAKS,IAAIxD,KAAKsB,WAAY,IAE1EyH,EAAgB/I,KAAKmC,KAAKmG,YAC1BU,EAAgBhJ,KAAKmC,KAAKkF,QAO9B,GALIrH,KAAK2G,SAAWpH,EAAW+H,SAC7ByB,EAAgB/I,KAAKmC,KAAKuF,SAC1BsB,EAAgBhJ,KAAKmC,KAAKoF,YAGxBwB,EAAc3I,GAAK,EAAG,CACxB,IAAM6I,EAAc9F,EAAO0F,mBAAmBF,EAAWG,EAAKE,GAE1DC,IAAgBjD,IAClBA,EAASiD,EACTjJ,KAAK8H,uBAAuB9B,IAIhC,OAAOA,IA5ZX,+CAgaI,IAAMkD,EAAQlJ,KAAKmJ,sBAOnB,MAAO,CAACD,EAJNA,IAAUlJ,KAAK6G,oBAAkD,OAA5B7G,KAAK6G,mBACtC7G,KAAK6G,mBACL7G,KAAK8G,0BAraf,M,SHGYxH,O,qBAAAA,I,gBAAAA,M,cAQAC,K,UAAAA,E,iBAAAA,M,cAQAC,K,sBAAAA,E,0BAAAA,E,oBAAAA,E,aAAAA,M,KAiBL,IIxCK4J,EJwCCC,EAAb,WAWE,WAAY3J,EAAgB4J,GAAgB,yBAV3B5J,YAU0B,OAT1B4J,SAS0B,OAPnCC,aAAqB,KAOc,KANnCC,WAAmB,KAMgB,KAJnCC,KAAwB,KAIW,KAFnC7J,MAAuBJ,EAAckK,KAG3C1J,KAAKN,OAASA,EACdM,KAAKsJ,IAAMA,EAbf,iDAqBcK,GACV3J,KAAK4J,SAASpK,EAAcqK,WAGV,OAAd7J,KAAKyJ,MAAezJ,KAAK8J,MAAMH,GAEnC3J,KAAK+J,GAAG/J,KAAKN,OAAOsK,cAAcL,MA3BtC,2BAmCcA,GACV,KAAI3J,KAAKsJ,IAAIW,cAAcC,oBAAuBlK,KAAKmK,iBAAiBR,MAGtD,OAAd3J,KAAKyJ,MAAezJ,KAAKN,OAAO0K,kBAE/BpK,KAAK8J,MAAMH,IAAhB,CAEA,IAAMxH,EAAOnC,KAAKqK,gBAElBrK,KAAK4J,SAASpK,EAAc8K,UAG5B,IAAMC,EAAapI,EAAKZ,OAAS,GAG3BiJ,EACJxK,KAAKyJ,KAAKgB,cAAgBlL,EAAW+H,OAASnF,EAAKZ,OAASgJ,EAAaA,EAErEG,EAAQ1K,KAAKyJ,KAAKgB,cAAgBlL,EAAW+H,OAASnF,EAAKZ,OAAS,EAG1EvB,KAAKyJ,KAAKA,KAAK,CAAErJ,EAAG+B,EAAKf,UAAYmJ,EAAYlK,EAAGmK,IAGpDxK,KAAK2K,kBACH,CAAEvK,EAAG+B,EAAKf,UAAYmJ,EAAYlK,EAAGmK,GACrC,CAAEpK,GAAI+B,EAAKf,UAAWf,EAAGqK,IACzB,MA/DN,4BA0Eef,GACX3J,KAAK4K,QAEL,IAAMC,EAAU7K,KAAKN,OAAOoL,cAAcnB,GACpCxH,EAAOnC,KAAKqK,gBAGZ3D,EAAY1G,KAAK+K,oBAAoBF,GAGrCG,EAAaH,EAAQxK,GAAK8B,EAAKZ,OAAS,EAAIhC,EAAW+H,OAAS/H,EAAWiI,IAEjF,IAAKxH,KAAKiL,eAAevE,GAAY,OAAO,EAE5C,IAKE,GAJA1G,KAAKuJ,aAAevJ,KAAKsJ,IAAI4B,oBAAoBC,gBAAgBzE,GACjE1G,KAAKwJ,WAAaxJ,KAAKsJ,IAAI4B,oBAAoBE,cAAc1E,GAGzD1G,KAAKN,OAAO2L,mBAAqBC,EAAYC,UAC/C,GAAI7E,IAAcpH,EAAcqI,KAAM,CACpC,IAAM6D,EAAWxL,KAAKsJ,IAAI4B,oBAAoBO,OAAOzL,KAAKuJ,cAEzC,OAAbiC,GACExL,KAAKuJ,aAAamC,eAAiBF,EAASE,eAC9C1L,KAAKuJ,aAAaoC,kBAAkBtM,EAAYuM,MAChDJ,EAASG,kBAAkBtM,EAAYuM,WAGtC,CACL,IAAMC,EAAW7L,KAAKsJ,IAAI4B,oBAAoBY,OAAO9L,KAAKuJ,cAEzC,OAAbsC,GACE7L,KAAKuJ,aAAamC,eAAiBG,EAASH,eAC9C1L,KAAKuJ,aAAaoC,kBAAkBtM,EAAYuM,MAChDC,EAASF,kBAAkBtM,EAAYuM,OAc/C,OARA5L,KAAKN,OAAOqM,aAAarF,GACzB1G,KAAKyJ,KAAO,IAAIhD,EACdC,EACAsE,EACA7I,EAAKf,UAAU4K,SAAS,IACxB7J,EAAKZ,OAAOyK,SAAS,MAGhB,EACP,MAAO7E,GACP,OAAO,KA7Hb,yBAsIa3G,GACT,GAAkB,OAAdR,KAAKyJ,MAELzJ,KAAKyJ,KAAKA,KAAKjJ,GAAU,CAE3B,IAAMyL,EAAWjM,KAAKyJ,KAAKyC,sBAE3BlM,KAAKwJ,WAAW2C,QAAQnM,KAAKyJ,KAAK2C,qBAClCpM,KAAKwJ,WAAW6C,YAAYrM,KAAKyJ,KAAK6C,yBACtCtM,KAAKwJ,WAAW+C,SAAS,GACzBvM,KAAKwJ,WAAWgD,aAAa,GAE7BxM,KAAKuJ,aAAa4C,QAAQnM,KAAKyJ,KAAKgD,uBACpCzM,KAAKuJ,aAAa8C,YAAYrM,KAAKyJ,KAAKiD,mBACxC1M,KAAKuJ,aAAagD,SAASvM,KAAKyJ,KAAKkD,YAEjC3M,KAAKyJ,KAAKmD,iBAAmBtN,EAAcmI,QAC7CzH,KAAKuJ,aAAaiD,aAAc,IAAM,IAAiB,EAAXP,GAAiB,KAE7DjM,KAAKuJ,aAAaiD,cAAe,IAAM,IAAiB,EAAXP,GAAiB,KAGhEjM,KAAKN,OAAOmN,YAAY7M,KAAKyJ,KAAKpI,WAElCrB,KAAKN,OAAOoN,cAAc9M,KAAKwJ,YAC/BxJ,KAAKN,OAAOqN,gBAAgB/M,KAAKuJ,cAEjCvJ,KAAKN,OAAOsN,cACVhN,KAAKyJ,KAAKN,sBACVnJ,KAAKyJ,KAAKwD,iBACVhB,EACAjM,KAAKyJ,KAAKmD,mBArKlB,iCAgLoBM,EAAcvG,GAC9B,IAAMwG,EAAUnN,KAAKsJ,IAAI4B,oBAAoBkC,wBACvCC,EAAOrN,KAAKsJ,IAAI4B,oBAAoBoC,qBAAqBJ,GAE/D,IACMG,EAAOF,IACTnN,KAAKsJ,IAAI4B,oBAAoBqC,sBAAsBF,EAAO,GAC1DrN,KAAKwN,SAAS7G,IAEZ0G,EAAOF,IACTnN,KAAKsJ,IAAI4B,oBAAoBqC,sBAAsBF,EAAO,GAC1DrN,KAAKyN,SAAS9G,IAEhB,MAAOQ,OA7Lb,+BAuMkBR,GACd3G,KAAK0N,KAAK,CACRtN,EAAGJ,KAAKN,OAAO2B,UAAUgB,KAAyC,EAAlCrC,KAAKN,OAAO2B,UAAUD,UAAgB,GACtEf,EAAGsG,IAAWpH,EAAWiI,IAAM,EAAIxH,KAAKN,OAAO2B,UAAUE,OAAS,MA1MxE,+BAmNkBoF,GACd3G,KAAK0N,KAAK,CACRtN,EAAG,GACHC,EAAGsG,IAAWpH,EAAWiI,IAAM,EAAIxH,KAAKN,OAAO2B,UAAUE,OAAS,MAtNxE,iCA8NI,GAAkB,OAAdvB,KAAKyJ,KAAT,CAEA,IAAMvF,EAAMlE,KAAKyJ,KAAKkE,cAChBxL,EAAOnC,KAAKqK,gBAEZhK,EAAIL,KAAKyJ,KAAKgB,cAAgBlL,EAAW+H,OAASnF,EAAKZ,OAAS,EAElE2C,EAAI9D,GAAK,EAAGJ,KAAK2K,kBAAkBzG,EAAK,CAAE9D,GAAI+B,EAAKf,UAAWf,MAAK,GAClEL,KAAK2K,kBAAkBzG,EAAK,CAAE9D,EAAG+B,EAAKf,UAAWf,MAAK,MAtO/D,iCA+OoBsJ,GAChB,GAAK3J,KAAK4N,WAAWpO,EAAckK,KAAMlK,EAAcqO,aAAvD,CAEA,IAAM1L,EAAOnC,KAAKqK,gBACZjJ,EAAYe,EAAKf,UAEvB,GAAIpB,KAAKmK,iBAAiBR,GACxB,GAAkB,OAAd3J,KAAKyJ,KAAe,CACtB,IAAKzJ,KAAK8J,MAAMH,GAAY,OAE5B3J,KAAK4J,SAASpK,EAAcqO,aAE5B7N,KAAKyJ,KAAKA,KAAK,CAAErJ,EAAGgB,EAAY,EAAGf,EAAG,IAEtC,IACMmK,EAASxK,KAAKyJ,KAAKgB,cAAgBlL,EAAW+H,OAASnF,EAAKZ,OAAS,EAAI,EAEzEmJ,EACJ1K,KAAKyJ,KAAKgB,cAAgBlL,EAAW+H,OACjCnF,EAAKZ,OALa,MAQxBvB,KAAK2K,kBACH,CAAEvK,EAAGgB,EAAY,EAAGf,EAAGmK,GACvB,CAAEpK,EAAGgB,EAViB,GAUYf,EAAGqK,IACrC,GACA,QAGF1K,KAAK+J,GAAG/J,KAAKN,OAAOsK,cAAcL,SAGpC3J,KAAK4J,SAASpK,EAAckK,MAC5B1J,KAAKN,OAAO0K,kBAEZpK,KAAK8N,cAlRX,wCA+RIhE,EACAiE,EACAC,GAEO,IAAD,SADNC,IACM,yDACA7F,EAASjF,EAAO+K,qBAAqBpE,EAAOiE,GAG5CI,EAAS,GAJT,cAKU/F,GALV,yBAKKzG,EALL,QAKkBwM,EAAO3H,MAAK,kBAAM,EAAKuD,GAAGpI,OAAlD,+BALM,8BAON,IAAMyM,EAAWpO,KAAKqO,qBAAqBjG,EAAO/B,QAElDrG,KAAKN,OAAO4O,eAAeH,EAAQC,GAAU,WAEtC,EAAK3E,OAENuE,IACE,EAAKvE,KAAKmD,iBAAmBtN,EAAcqI,KAAM,EAAK2B,IAAIiF,iBACzD,EAAKjF,IAAIkF,kBAGZP,IACF,EAAKvO,OAAOoN,cAAc,MAC1B,EAAKpN,OAAOqN,gBAAgB,MAC5B,EAAKrN,OAAO+O,cAEZ,EAAK7E,SAASpK,EAAckK,MAC5B,EAAKkB,eA3Tb,uCAoUI,OAAO5K,KAAKyJ,OApUhB,iCA2UI,OAAOzJ,KAAKJ,QA3UhB,+BA8UmB8O,GACX1O,KAAKJ,QAAU8O,IACjB1O,KAAKsJ,IAAIqF,YAAYD,GACrB1O,KAAKJ,MAAQ8O,KAjVnB,0CAqV8BE,GAC1B,IAAMzM,EAAOnC,KAAKqK,gBAElB,GAAIrK,KAAKN,OAAO2L,mBAAqBC,EAAYuD,UAC/C,GAAID,EAASxO,EAAI+B,EAAKf,WAAae,EAAKgC,MAAQ,EAC9C,OAAO7E,EAAcqI,UAElB,GAAIiH,EAASxO,EAAI+B,EAAKgC,MAAQ,EACnC,OAAO7E,EAAcqI,KAGvB,OAAOrI,EAAcmI,UAhWzB,2CAmW+BrB,GAC3B,IAAM0I,EAAc9O,KAAKsJ,IAAIW,cAAc8E,aAE3C,OAAI3I,GAAQ,IAAa0I,EAEjB1I,EAAO,IAAQ0I,IAxW3B,qCA2WyBpI,GACrB,OAAIA,IAAcpH,EAAcmI,QACvBzH,KAAKsJ,IAAI0F,sBAAwBhP,KAAKsJ,IAAI2F,eAAiB,EAE7DjP,KAAKsJ,IAAI0F,uBAAyB,IA/W7C,8BAmXIhP,KAAKyJ,KAAO,KACZzJ,KAAKuJ,aAAe,KACpBvJ,KAAKwJ,WAAa,OArXtB,sCAyXI,OAAOxJ,KAAKN,OAAO2B,YAzXvB,mCA4X2D,IAAD,uBAAlC6N,EAAkC,yBAAlCA,EAAkC,gBACtD,cAAoBA,EAApB,eAA4B,CAAvB,IAAMtP,EAAK,KACd,GAAII,KAAKJ,QAAUA,EAAO,OAAO,EAGnC,OAAO,IAjYX,uCAoY2B+J,GACvB,IAAMxH,EAAOnC,KAAKqK,gBACZjJ,EAAYe,EAAKf,UAEjB+N,EAAoBpM,KAAKQ,KAAKR,KAAKS,IAAIpC,EAAW,GAAK2B,KAAKS,IAAIrB,EAAKZ,OAAQ,IAAM,EAEnFsJ,EAAU7K,KAAKN,OAAOoL,cAAcnB,GAE1C,OACEkB,EAAQzK,EAAI,GACZyK,EAAQxK,EAAI,GACZwK,EAAQzK,EAAI+B,EAAKgC,OACjB0G,EAAQxK,EAAI8B,EAAKZ,SAChBsJ,EAAQzK,EAAI+O,GAAqBtE,EAAQzK,EAAI+B,EAAKgC,MAAQgL,KAC1DtE,EAAQxK,EAAI8O,GAAqBtE,EAAQxK,EAAI8B,EAAKZ,OAAS4N,OAlZlE,M,SIxCY/F,K,cAAAA,E,mBAAAA,M,KA0DL,ICdKkC,EDcC8D,EAAb,iDACUC,SAAwB,CAC9BC,UAAW,EACXlJ,KAAMgD,EAASmG,MACfpL,MAAO,EACP5C,OAAQ,EACRiO,SAAU,EACVC,SAAU,EACVC,UAAW,EACXC,UAAW,EACXC,YAAY,EACZb,aAAc,IACdc,aAAa,EACbC,YAAa,EACbC,UAAU,EACVC,iBAAkB,EAClBC,WAAW,EACXC,qBAAqB,EACrBC,cAAe,GACfC,mBAAmB,EACnBC,gBAAgB,EAChBC,iBAAiB,EACjBpG,oBAAoB,GAtBxB,wDA+BqBqG,GACjB,IAAMvK,EAAShG,KAAKqP,SAGpB,GAFAmB,OAAOC,OAAOzK,EAAQuK,GAElBvK,EAAOI,OAASgD,EAASsH,SAAW1K,EAAOI,OAASgD,EAASmG,MAC/D,MAAM,IAAI9J,MAAM,iEAElB,GAAIO,EAAO7B,OAAS,GAAK6B,EAAOzE,QAAU,EAAG,MAAM,IAAIkE,MAAM,2BAE7D,GAAIO,EAAO+I,cAAgB,EAAG,MAAM,IAAItJ,MAAM,yBAiB9C,OAfIO,EAAOI,OAASgD,EAASsH,SACvB1K,EAAOwJ,UAAY,IAAGxJ,EAAOwJ,SAAW,KAExCxJ,EAAOyJ,SAAWzJ,EAAOwJ,WAAUxJ,EAAOyJ,SAAW,KAErDzJ,EAAO0J,WAAa,IAAG1J,EAAO0J,UAAY,KAE1C1J,EAAO2J,UAAY3J,EAAO0J,YAAW1J,EAAO2J,UAAY,OAE5D3J,EAAOwJ,SAAWxJ,EAAO7B,MACzB6B,EAAOyJ,SAAWzJ,EAAO7B,MACzB6B,EAAO0J,UAAY1J,EAAOzE,OAC1ByE,EAAO2J,UAAY3J,EAAOzE,QAGrByE,MAzDX,M,SCdYsF,K,oBAAAA,E,uBAAAA,M,KAQL,IAAeqF,EAAtB,WAqCE,WAAsBrH,EAAesH,GAAuB,yBApCzCA,aAoCwC,OAnCxCtH,SAmCwC,OAhCjDuH,SAAiB,KAgCgC,KA9BjDC,UAAkB,KA8B+B,KA3BjDvH,aAAqB,KA2B4B,KAzBjDC,WAAmB,KAyB8B,KAtBjD9C,UAA2B,KAsBsB,KApBjD7G,YAA2B,KAoBsB,KAlBjDkR,OAAiB,KAkBgC,KAhBjDC,UAA8B,KAgBmB,KAdjDC,SAAuB,KAc0B,KAZnDC,WAAuB,KAY4B,KATjDC,MAAQ,EASyC,KAFnDC,QAAS,EAGfpR,KAAK4Q,QAAUA,EACf5Q,KAAKsJ,IAAMA,EAGX,IAAM+H,EAAQ,IAAIC,OAAO,gCACzBtR,KAAKoR,OAAoD,OAA3CC,EAAME,KAAKC,OAAOC,UAAUC,WA3C9C,mDA6DiBP,GACb,GAAuB,OAAnBnR,KAAKgR,UAAoB,CAE3B,IAAMW,EAAa5O,KAAK6O,OACrBT,EAAQnR,KAAKgR,UAAUa,WAAa7R,KAAKgR,UAAUc,eAGlDH,EAAa3R,KAAKgR,UAAU7C,OAAO9H,OACrCrG,KAAKgR,UAAU7C,OAAOwD,MAEtB3R,KAAKgR,UAAUe,eACf/R,KAAKgR,UAAY,MAIrBhR,KAAKmR,MAAQA,EACbnR,KAAKgS,cA7ET,8BAmFwB,IAAD,OACnBhS,KAAKiS,SAOLC,uBALa,SAAPC,EAAQhB,GACZ,EAAKzR,OAAOyR,GACZe,sBAAsBC,QAxF5B,qCAsGIhE,EACAC,EACA2D,GAEA/R,KAAKoK,kBAELpK,KAAKgR,UAAY,CACf7C,SACAC,WACA0D,cAAe1D,EAAWD,EAAO9H,OACjC0L,eACAF,UAAW7R,KAAKmR,SAjHtB,wCAyH2B,OAAnBnR,KAAKgR,YACPhR,KAAKgR,UAAU7C,OAAOnO,KAAKgR,UAAU7C,OAAO9H,OAAS,KAEjB,OAAhCrG,KAAKgR,UAAUe,cACjB/R,KAAKgR,UAAUe,gBAInB/R,KAAKgR,UAAY,OAjIrB,+BAwIIhR,KAAKkR,WAAa,KAClB,IAAMrR,EAAcG,KAAKoS,sBAErBpS,KAAKH,cAAgBA,IACvBG,KAAKH,YAAcA,EACnBG,KAAKsJ,IAAI+I,kBAAkBxS,MA7IjC,4CAqJI,IAAIA,EAAcyL,EAAYC,UAExB+G,EAAatS,KAAKuS,gBAClB1P,EACDyP,EAAa,EADZzP,EAED7C,KAAKwS,iBAAmB,EAGvBC,EAAQzS,KAAK4Q,QAAQzM,MAAQnE,KAAK4Q,QAAQrP,OAE5CH,EAAYpB,KAAK4Q,QAAQzM,MACzB7C,EAAatB,KAAK4Q,QAAQrP,OAE1Bc,EAAOQ,EAAgBzB,EAwC3B,OAtCIpB,KAAK4Q,QAAQxK,OAASgD,EAASsH,SAC7B4B,EAAqC,EAAxBtS,KAAK4Q,QAAQpB,UAAgBxP,KAAKsJ,IAAIW,cAAc4F,cACnEhQ,EAAcyL,EAAYuD,WAE5BzN,EACEvB,IAAgByL,EAAYuD,SACxB7O,KAAKuS,gBACLvS,KAAKuS,gBAAkB,GAEbvS,KAAK4Q,QAAQnB,WAAUrO,EAAYpB,KAAK4Q,QAAQnB,WAEhEnO,EAAaF,EAAYqR,GACRzS,KAAKwS,mBAEpBpR,GADAE,EAAatB,KAAKwS,kBACOC,GAG3BpQ,EACExC,IAAgByL,EAAYuD,SACxBhM,EAAgBzB,EAAY,EAAIA,EAChCyB,EAAgBzB,GAElBkR,EAAyB,EAAZlR,GACXpB,KAAKsJ,IAAIW,cAAc4F,cACzBhQ,EAAcyL,EAAYuD,SAC1BxM,EAAOQ,EAAgBzB,EAAY,EAAIA,GAK7CpB,KAAKkR,WAAa,CAChB7O,OACAC,IAAKO,EAAgBvB,EAAa,EAClC6C,MAAmB,EAAZ/C,EACPG,OAAQD,EACRF,UAAWA,GAGNvB,IA1MX,oCAsNIqE,EACAjE,EACAgM,EACAvF,GAEA,GAAK1G,KAAKsJ,IAAIW,cAAc2F,WAA5B,CAEA,IAAMI,EAAmB,IAAMhQ,KAAKiK,cAAc+F,iBAElDhQ,KAAK+Q,OAAS,CACZ7M,MACAjE,QACAkE,MAAqC,EAA3BnE,KAAKqB,UAAUD,UAAiB,EAAK6K,EAAY,IAC3DyG,SAAW,IAAMzG,GAAY+D,EAAoB,IAAM,IACvDtJ,YACAuF,SAAqB,EAAXA,MArOhB,oCA6OIjM,KAAK+Q,OAAS,OA7OlB,sCAoPI,OAAO/Q,KAAKsJ,IAAIqJ,QAAQC,iBAAiBC,cApP7C,uCA2PI,OAAO7S,KAAKsJ,IAAIqJ,QAAQC,iBAAiBE,eA3P7C,qCAkQI,OAAO9S,KAAK0G,YAlQhB,gCA2QI,OAFwB,OAApB1G,KAAKkR,YAAqBlR,KAAKoS,sBAE5BpS,KAAKkR,aA3QhB,oCAkRI,OAAOlR,KAAKsJ,IAAIW,gBAlRpB,uCAyRI,OAAOjK,KAAKH,cAzRhB,kCAiSqBoR,GACjBjR,KAAKiR,SAAWA,IAlSpB,mCA0SsBvK,GAClB1G,KAAK0G,UAAYA,IA3SrB,mCAmTsBwG,GACL,OAATA,GAAeA,EAAK6F,eAAe3T,EAAgBgD,OAEvDpC,KAAK8Q,UAAY5D,IAtTrB,kCA6TqBA,GACJ,OAATA,GAAeA,EAAK6F,eAAe3T,EAAgB4T,MAEvDhT,KAAK6Q,SAAW3D,IAhUpB,oCAuUuBA,GACN,OAATA,GACFA,EAAK6F,eACH/S,KAAK0G,YAAcpH,EAAcqI,KAAOvI,EAAgB4T,KAAO5T,EAAgBgD,OAGnFpC,KAAKwJ,WAAa0D,IA7UtB,sCAqVyBA,GACR,OAATA,GACFA,EAAK6F,eACH/S,KAAK0G,YAAcpH,EAAcmI,SAC/BzH,KAAKH,cAAgByL,EAAYuD,SAC/BzP,EAAgB4T,KAChB5T,EAAgBgD,OAGxBpC,KAAKuJ,aAAe2D,IA9VxB,oCAuWuBhJ,GACnB,IAAM/B,EAAOnC,KAAKqB,UAElB,MAAO,CACLjB,EAAG8D,EAAI9D,EAAI+B,EAAKE,KAChBhC,EAAG6D,EAAI7D,EAAI8B,EAAKG,OA5WtB,iCAiXI,OAAOtC,KAAKoR,SAjXhB,oCA4XuBlN,EAAYwC,GAC1BA,IAAWA,EAAY1G,KAAK0G,WAEjC,IAAMvE,EAAOnC,KAAKqB,UAMlB,MAAO,CACLjB,EALAsG,IAAcpH,EAAcmI,QACxBvD,EAAI9D,EAAI+B,EAAKE,KAAOF,EAAKgC,MAAQ,EACjChC,EAAKgC,MAAQ,EAAID,EAAI9D,EAAI+B,EAAKE,KAIlChC,EAAG6D,EAAI7D,EAAI8B,EAAKG,OAvYtB,sCAmZyB4B,EAAYwC,GAGjC,GAFKA,IAAWA,EAAY1G,KAAK0G,WAEtB,MAAPxC,EAAa,OAAO,KAExB,IAAM/B,EAAOnC,KAAKqB,UAOlB,MAAO,CACLjB,EALAsG,IAAcpH,EAAcmI,QACxBvD,EAAI9D,EAAI+B,EAAKE,KAAOF,EAAKgC,MAAQ,EACjChC,EAAKgC,MAAQ,EAAID,EAAI9D,EAAI+B,EAAKE,KAIlChC,EAAG6D,EAAI7D,EAAI8B,EAAKG,OAjatB,0CA6a6BH,EAAkBuE,GAG3C,OAFKA,IAAWA,EAAY1G,KAAK0G,WAE1B,CACLW,QAASrH,KAAKmB,gBAAgBgB,EAAKkF,QAASX,GAC5CgB,SAAU1H,KAAKmB,gBAAgBgB,EAAKuF,SAAUhB,GAC9Ca,WAAYvH,KAAKmB,gBAAgBgB,EAAKoF,WAAYb,GAClD4B,YAAatI,KAAKmB,gBAAgBgB,EAAKmG,YAAa5B,QApb1D,KC7CsBuM,EAAtB,WAiBI,WAAsB3J,EAAe5J,GAAiB,yBAhBnC4J,SAgBkC,OAflC5J,YAekC,OAdlCwT,iBAckC,OAX3CC,MAAgB,GAW2B,KAT3CC,iBAAmB,EASwB,KAN3CC,mBAAqB,EAMsB,KAJ3CC,gBAAiC,GAIU,KAF3CC,eAAgC,GAGtCvT,KAAKN,OAASA,EACdM,KAAKsJ,IAAMA,EAEXtJ,KAAKoT,iBAAmB,EACxBpT,KAAKkT,YAAclT,KAAKsJ,IAAIW,cAAcgG,UAtBlD,sDAkCQjQ,KAAKmT,MAAQ,KAlCrB,qCAyCQnT,KAAKsT,gBAAkB,GACvBtT,KAAKuT,eAAiB,GAEtB,IAAK,IAAIhN,EAAI,EAAGA,EAAIvG,KAAKmT,MAAM9M,OAAQE,IACnCvG,KAAKuT,eAAe/M,KAAK,CAACD,IAG9B,IAAIuD,EAAQ,EACR9J,KAAKkT,cACLlT,KAAKmT,MAAM,GAAGK,WAAWnU,EAAYuM,MACrC5L,KAAKsT,gBAAgB9M,KAAK,CAACsD,IAC3BA,KAGJ,IAAK,IAAIvD,EAAIuD,EAAOvD,EAAIvG,KAAKmT,MAAM9M,OAAQE,GAAK,EACxCA,EAAIvG,KAAKmT,MAAM9M,OAAS,EAAGrG,KAAKsT,gBAAgB9M,KAAK,CAACD,EAAGA,EAAI,KAE7DvG,KAAKsT,gBAAgB9M,KAAK,CAACD,IAC3BvG,KAAKmT,MAAM5M,GAAGiN,WAAWnU,EAAYuM,SA3DrD,kCAoEQ,OAAO5L,KAAKN,OAAO2L,mBAAqBC,EAAYC,UAC9CvL,KAAKsT,gBACLtT,KAAKuT,iBAtEnB,2CA8EgCE,GAGxB,IAFA,IAAMC,EAAS1T,KAAK2T,YAEXpN,EAAI,EAAGA,EAAImN,EAAOrN,OAAQE,IAC/B,GAAIkN,IAAYC,EAAOnN,GAAG,IAAMkN,IAAYC,EAAOnN,GAAG,GAAI,OAAOA,EAErE,OAAO,OApFf,qCA2FQ,OAAOvG,KAAKmT,MAAM9M,SA3F1B,iCAkGQ,OAAOrG,KAAKmT,QAlGpB,8BA0GmBS,GACX,GAAIA,GAAa,GAAKA,EAAY5T,KAAKmT,MAAM9M,OACzC,OAAOrG,KAAKmT,MAAMS,GAGtB,MAAM,IAAInO,MAAM,yBA/GxB,6BAuHkB0H,GACV,IAAM0G,EAAM7T,KAAKmT,MAAMW,QAAQ3G,GAE/B,OAAI0G,EAAM7T,KAAKmT,MAAM9M,OAAS,EAAUrG,KAAKmT,MAAMU,EAAM,GAElD,OA5Hf,6BAoIkB1G,GACV,IAAM0G,EAAM7T,KAAKmT,MAAMW,QAAQ3G,GAE/B,OAAI0G,EAAM,EAAU7T,KAAKmT,MAAMU,EAAM,GAE9B,OAzIf,sCAiJ2BnN,GACnB,IAAMyG,EAAUnN,KAAKqT,mBAErB,GAAIrT,KAAKN,OAAO2L,mBAAqBC,EAAYuD,SAC7C,OAAOnI,IAAcpH,EAAcmI,QAC7BzH,KAAKmT,MAAMhG,GAAS4G,mBACpB/T,KAAKmT,MAAMhG,EAAU,GAE3B,IAAMuG,EACFhN,IAAcpH,EAAcmI,QACtBzH,KAAK2T,YAAYxG,EAAU,GAC3BnN,KAAK2T,YAAYxG,EAAU,GAErC,OAAsB,IAAlBuG,EAAOrN,QAEJK,IAAcpH,EAAcmI,QAFHzH,KAAKmT,MAAMO,EAAO,IAI5C1T,KAAKmT,MAAMO,EAAO,MAlKpC,oCA2KyBhN,GACjB,IAAMyG,EAAUnN,KAAKqT,mBAErB,GAAIrT,KAAKN,OAAO2L,mBAAqBC,EAAYuD,SAC7C,OAAOnI,IAAcpH,EAAcmI,QAC7BzH,KAAKmT,MAAMhG,EAAU,GACrBnN,KAAKmT,MAAMhG,EAAU,GAE3B,IAAMuG,EACFhN,IAAcpH,EAAcmI,QACtBzH,KAAK2T,YAAYxG,EAAU,GAC3BnN,KAAK2T,YAAYxG,EAAU,GAErC,OAAsB,IAAlBuG,EAAOrN,OAAqBrG,KAAKmT,MAAMO,EAAO,IAE3ChN,IAAcpH,EAAcmI,QAC7BzH,KAAKmT,MAAMO,EAAO,IAClB1T,KAAKmT,MAAMO,EAAO,MA5LpC,iCAoMY1T,KAAKqT,mBAAqBrT,KAAK2T,YAAYtN,SAC3CrG,KAAKqT,qBACLrT,KAAKgU,gBAtMjB,iCA8MYhU,KAAKqT,mBAAqB,IAC1BrT,KAAKqT,qBACLrT,KAAKgU,gBAhNjB,4CAwNQ,OAAOhU,KAAKoT,mBAxNpB,6BA+N+C,IAA/BK,EAA8B,uDAAZ,KAG1B,GAFgB,OAAZA,IAAkBA,EAAUzT,KAAKoT,oBAEjCK,EAAU,GAAKA,GAAWzT,KAAKmT,MAAM9M,QAAzC,CAEA,IAAM4N,EAAcjU,KAAKsN,qBAAqBmG,GAC1B,OAAhBQ,IACAjU,KAAKqT,mBAAqBY,EAC1BjU,KAAKgU,iBAvOjB,8CA+OQ,OAAOhU,KAAKqT,qBA/OpB,4CAuPiCa,GACzB,KAAIA,GAAY,GAAKA,EAAWlU,KAAK2T,YAAYtN,QAG7C,MAAM,IAAIZ,MAAM,gBAFhBzF,KAAKqT,mBAAqBa,IAzPtC,mCAmQQ,IAAMR,EAAS1T,KAAK2T,YAAY3T,KAAKqT,oBAEf,IAAlBK,EAAOrN,QACPrG,KAAKN,OAAOyU,YAAYnU,KAAKmT,MAAMO,EAAO,KAC1C1T,KAAKN,OAAO0U,aAAapU,KAAKmT,MAAMO,EAAO,MAEvC1T,KAAKN,OAAO2L,mBAAqBC,EAAYC,WACzCmI,EAAO,KAAO1T,KAAKmT,MAAM9M,OAAS,GAClCrG,KAAKN,OAAOyU,YAAYnU,KAAKmT,MAAMO,EAAO,KAC1C1T,KAAKN,OAAO0U,aAAa,QAM7BpU,KAAKN,OAAOyU,YAAY,MACxBnU,KAAKN,OAAO0U,aAAapU,KAAKmT,MAAMO,EAAO,MAInD1T,KAAKoT,iBAAmBM,EAAO,GAC/B1T,KAAKsJ,IAAI+K,gBAAgBrU,KAAKoT,sBAxRtC,KCDakB,EAAb,kDAGI,WAAYhL,EAAe5J,EAAgB6U,GAAuB,IAAD,8BAC7D,cAAMjL,EAAK5J,IAHE6U,gBAEgD,EAG7D,EAAKA,WAAaA,EAH2C,EAHrE,mDASyB,IAAD,gBACGvU,KAAKuU,YADR,IAChB,2BAAoC,CAAC,IAA1B7T,EAAyB,QAC1BwM,EAAO,IAAIzM,EAAUT,KAAKN,OAAQgB,EAAMrB,EAAYmV,MAE1DtH,EAAKuH,OACLzU,KAAKmT,MAAM3M,KAAK0G,IALJ,8BAQhBlN,KAAK0U,mBAjBb,GAAyCzB,G,eCA5B0B,EAAb,kDAQE,WAAYjV,EAAgBkV,EAAsBjV,GAAuB,IAAD,8BACtE,cAAMD,EAAQC,IARCiV,aAOuD,IANhEC,cAA6B,KAMmC,EAJhEC,cAAsB,KAI0C,EAFhElU,QAAS,EAKf,EAAKgU,QAAUA,EACf,EAAKA,QAAQG,UAAUC,IAAI,aAC3B,EAAKJ,QAAQG,UAAUC,IAAI,KAAOrV,GALoC,EAR1E,+DAiBI,OAAIK,KAAKD,oBAAsBV,EAAYuM,KAClC5L,MAGkB,OAAvBA,KAAK8U,gBACP9U,KAAK6U,cAAgB7U,KAAK4U,QAAQK,WAAU,GAC5CjV,KAAK4U,QAAQM,cAAcC,YAAYnV,KAAK6U,eAE5C7U,KAAK8U,cAAgB,IAAIH,EACvB3U,KAAKN,OACLM,KAAK6U,cACL7U,KAAKD,oBAIFC,KAAKoV,sBAhChB,yCAoCI,OAAOpV,KAAK8U,gBApChB,0CAwC+B,OAAvB9U,KAAK8U,gBACP9U,KAAK6U,cAAcQ,SACnBrV,KAAK6U,cAAgB,KACrB7U,KAAK8U,cAAgB,QA3C3B,2BA+Cc9T,GACV,IAAMrB,EAAUqB,GAA4BhB,KAAKD,kBAE3CS,EAAUR,KAAKN,OAAOyB,gBAAgBnB,KAAKJ,MAAMO,UACjDiB,EAAYpB,KAAKN,OAAO2B,UAAUD,UAClCE,EAAatB,KAAKN,OAAO2B,UAAUE,OAEzCvB,KAAK4U,QAAQG,UAAUM,OAAO,YAW9BrV,KAAK4U,QAAQU,MAAMC,QAAU,QAC7BvV,KAAK4U,QAAQU,MAAMjT,KAAO,IAC1BrC,KAAK4U,QAAQU,MAAMhT,IAAM,IAEzBtC,KAAK4U,QAAQU,MAAMnR,MAAQ/C,EAAY,KACvCpB,KAAK4U,QAAQU,MAAM/T,OAASD,EAAa,KAEzC3B,IAAYN,EAAYuM,KACpB5L,KAAKwV,WACLxV,KAAKyV,SAASjV,KA1EtB,iCA6E4C,IAClC0D,EAAMlE,KAAKN,OAAO2B,UAAUgB,KAAOrC,KAAKN,OAAO2B,UAAU8C,MAAQ,EAEjElE,EAAQD,KAAKJ,MAAMW,iBAEzBP,KAAK4U,QAAQU,MAAMI,mBAAqB,SACxC1V,KAAK4U,QAAQU,MAAMK,YAAY,8BAA+B,UAC1D3V,KAAKH,cAAgBT,EAAgB4T,MACvChT,KAAK4U,QAAQU,MAAMM,gBAAkB5V,KAAKN,OAAO2B,UAAUD,UAAY,OACvEpB,KAAK4U,QAAQU,MAAMO,UACjB,oCAAsD5V,EAAQ,SAEhED,KAAK4U,QAAQU,MAAMM,gBAAkB,MACrC5V,KAAK4U,QAAQU,MAAMO,UACjB,eAAiB3R,EAAjB,uBAAwDjE,EAAQ,QAEpED,KAAK4U,QAAQU,MAAMQ,SAAW,OAC9B9V,KAAK4U,QAAQU,MAAMK,YAAY,oBAAqB,UA9FxD,+BAmHmBxV,GAA0C,IAAD,EACpD4V,EAAU,YAD0C,cAExC/V,KAAKJ,MAAMM,MAF6B,IAExD,2BAAiC,CAAC,IAAvByB,EAAsB,QAC/B,GAAU,OAANA,EAAY,CACd,IAAIqU,EACFhW,KAAKN,OAAOkN,iBAAmBtN,EAAcqI,KACzC,CACAvH,GAAIuB,EAAEvB,EAAIJ,KAAKJ,MAAMO,SAASC,EAC9BC,EAAGsB,EAAEtB,EAAIL,KAAKJ,MAAMO,SAASE,GAE7B,CACAD,EAAGuB,EAAEvB,EAAIJ,KAAKJ,MAAMO,SAASC,EAC7BC,EAAGsB,EAAEtB,EAAIL,KAAKJ,MAAMO,SAASE,GAInC0V,IADAC,EAAI7S,EAAO8S,gBAAgBD,EAAG,CAAE5V,EAAG,EAAGC,EAAG,GAAKL,KAAKJ,MAAMK,QAC5CG,EAAI,MAAQ4V,EAAE3V,EAAI,SAhBqB,8BAmBxD0V,EAAUA,EAAQG,MAAM,GAAI,GAC5BH,GAAW,IAWX/V,KAAK4U,QAAQU,MAAMM,gBAAkB,MACjC5V,KAAKN,OAAOyW,YAAmC,IAArBnW,KAAKJ,MAAMK,MACvCD,KAAK4U,QAAQU,MAAMO,UAAY,aAAe1V,EAASC,EAAI,OAASD,EAASE,EAAI,MAEjFL,KAAK4U,QAAQU,MAAMO,UACjB,eACA1V,EAASC,EACT,OACAD,EAASE,EACT,iBACAL,KAAKJ,MAAMK,MACX,OAGJD,KAAK4U,QAAQU,MAAMQ,SAAWC,EAC9B/V,KAAK4U,QAAQU,MAAMK,YAAY,oBAAqBI,KAjKxD,iCAoKoB7T,GAChB,IAAIlC,KAAK4U,QAAQG,UAAUqB,SAAS,YAApC,CAEA,IAAMjU,EAAOnC,KAAKN,OAAO2B,UAEnBD,EAAYe,EAAKf,UACjBE,EAAaa,EAAKZ,OAElBnB,EAAI8B,IAAW9C,EAAgBgD,MAAQD,EAAKE,KAAOF,EAAKf,UAAYe,EAAKE,KAEzEhC,EAAI8B,EAAKG,IAEftC,KAAK4U,QAAQG,UAAUC,IAAI,YAC3BhV,KAAK4U,QAAQU,MAAMe,QAAnB,gGAGkB/U,EAHlB,mCAIgBlB,EAJhB,kCAKeC,EALf,oCAMiBe,EANjB,sCAOmBpB,KAAKN,OAAOuK,cAAc6F,YAAc,EAP3D,QAjLJ,mCAoMI9P,KAAK4U,QAAQG,UAAUM,OAAO,YAEH,OAAvBrV,KAAK6U,gBACP7U,KAAK6U,cAAcQ,SACnBrV,KAAK6U,cAAgB,QAxM3B,mCA6MI,OAAO7U,KAAK4U,UA7MhB,6BAiNI5U,KAAKY,QAAS,IAjNlB,qCAoNwBf,GACpB,sEAAqBA,GACrBG,KAAK4U,QAAQG,UAAUM,OAAO,SAAU,WAExCrV,KAAK4U,QAAQG,UAAUC,IAAInV,IAAgBT,EAAgBgD,MAAQ,UAAY,YAxNnF,wCA2N2BzC,GACvBK,KAAK4U,QAAQG,UAAUM,OAAO,SAAU,UACxCrV,KAAK4U,QAAQG,UAAUC,IAAI,KAAOrV,GAElC,yEAAwBA,OA/N5B,GAA8BF,GCAjB6W,EAAb,kDAII,WACIhN,EACA5J,EACAkV,EACA2B,GACD,IAAD,8BACE,cAAMjN,EAAK5J,IATEkV,aAQf,IAPe4B,kBAOf,EAGE,EAAK5B,QAAUA,EACf,EAAK4B,aAAeD,EAJtB,EATN,mDAgByB,IAAD,gBACUvW,KAAKwW,cADf,IAChB,2BAA6C,CAAC,IAAnCC,EAAkC,QACnCvJ,EAAO,IAAIyH,EACb3U,KAAKN,OACL+W,EACmC,SAAnCA,EAAYC,QAAZ,QAA4CrX,EAAYuM,KAAOvM,EAAYmV,MAG/EtH,EAAKuH,OACLzU,KAAKmT,MAAM3M,KAAK0G,IATJ,8BAYhBlN,KAAK0U,mBA5Bb,GAAwCzB,GCA3B0D,EAAb,kDAII,WAAYrN,EAAesH,EAAsBgG,GAA8B,IAAD,8BAC1E,cAAMtN,EAAKsH,IAJEiG,YAG6D,IAF7D5V,SAE6D,EAG1E,EAAK4V,OAASD,EACd,EAAK3V,IAAM2V,EAAS1V,WAAW,MAJ2C,EAJlF,yDAYQ,OAAOlB,KAAKiB,MAZpB,oEAoBQjB,KAAK8W,QAED9W,KAAKH,cAAgByL,EAAYuD,UACZ,MAAjB7O,KAAK6Q,UAAkB7Q,KAAK6Q,SAASkG,WAAW3X,EAAgB4T,MAElD,MAAlBhT,KAAK8Q,WAAmB9Q,KAAK8Q,UAAUiG,WAAW3X,EAAgBgD,OAE/C,MAAnBpC,KAAKwJ,YAAoBxJ,KAAKwJ,WAAWwN,OAE7ChX,KAAKiX,iBAEoB,MAArBjX,KAAKuJ,cAAsBvJ,KAAKuJ,aAAayN,OAE9B,MAAfhX,KAAK+Q,SACL/Q,KAAKkX,kBACLlX,KAAKmX,mBAGT,IAAMhV,EAAOnC,KAAKqB,UAEdrB,KAAKH,cAAgByL,EAAYuD,WACjC7O,KAAKiB,IAAIS,YACT1B,KAAKiB,IAAIkB,KAAKA,EAAKE,KAAOF,EAAKf,UAAWe,EAAKG,IAAKH,EAAKgC,MAAOhC,EAAKZ,QACrEvB,KAAKiB,IAAIa,UA3CrB,uCAgDQ,IAAMK,EAAOnC,KAAKqB,UAElBrB,KAAKiB,IAAIO,OACTxB,KAAKiB,IAAIS,YAET,IAAM0V,EAAajV,EAAKgC,MAAQ,GAChCnE,KAAKiB,IAAIkB,KAAKA,EAAKE,KAAMF,EAAKG,IAAKH,EAAKgC,MAAOhC,EAAKZ,QAEpD,IAAM8V,EAAY,CAAEjX,EAAG+B,EAAKE,KAAOF,EAAKgC,MAAQ,EAAIiT,EAAa,EAAG/W,EAAG,GACvEL,KAAKiB,IAAIQ,UAAU4V,EAAUjX,EAAGiX,EAAUhX,GAE1C,IAAMiX,EAAgBtX,KAAKiB,IAAIsW,qBAAqB,EAAG,EAAGH,EAAY,GAEtEE,EAAcE,aAAa,EAAG,oBAC9BF,EAAcE,aAAa,GAAK,sBAChCF,EAAcE,aAAa,IAAM,sBACjCF,EAAcE,aAAa,GAAK,sBAChCF,EAAcE,aAAa,IAAM,sBACjCF,EAAcE,aAAa,EAAG,oBAE9BxX,KAAKiB,IAAIa,OAET9B,KAAKiB,IAAIwB,UAAY6U,EACrBtX,KAAKiB,IAAIwW,SAAS,EAAG,EAAGL,EAA0B,EAAdjV,EAAKZ,QAEzCvB,KAAKiB,IAAIgB,YAzEjB,wCA6EQ,IAAME,EAAOnC,KAAKqB,UAElBrB,KAAKiB,IAAIO,OACTxB,KAAKiB,IAAIS,YAET1B,KAAKiB,IAAIkB,KAAKA,EAAKE,KAAMF,EAAKG,IAAKH,EAAKgC,MAAOhC,EAAKZ,QAEpD,IAAM8V,EAAYrX,KAAKmB,gBAAgB,CAAEf,EAAGJ,KAAK+Q,OAAO7M,IAAI9D,EAAGC,EAAGL,KAAK+Q,OAAO7M,IAAI7D,IAClFL,KAAKiB,IAAIQ,UAAU4V,EAAUjX,EAAGiX,EAAUhX,GAE1CL,KAAKiB,IAAIY,OAAOkB,KAAKC,GAAKhD,KAAK+Q,OAAO9Q,MAAQ8C,KAAKC,GAAK,GAExD,IAAMsU,EAAgBtX,KAAKiB,IAAIsW,qBAAqB,EAAG,EAAGvX,KAAK+Q,OAAO5M,MAAO,GAEzEnE,KAAK+Q,OAAOrK,YAAcpH,EAAcmI,SACxCzH,KAAKiB,IAAIQ,UAAU,GAAI,KACvB6V,EAAcE,aAAa,EAAG,iBAAmBxX,KAAK+Q,OAAO2B,QAAU,KACvE4E,EAAcE,aAAa,EAAG,sBAE9BxX,KAAKiB,IAAIQ,WAAWzB,KAAK+Q,OAAO5M,OAAQ,KACxCmT,EAAcE,aAAa,EAAG,oBAC9BF,EAAcE,aAAa,EAAG,iBAAmBxX,KAAK+Q,OAAO2B,QAAU,MAG3E1S,KAAKiB,IAAIa,OAET9B,KAAKiB,IAAIwB,UAAY6U,EACrBtX,KAAKiB,IAAIwW,SAAS,EAAG,EAAGzX,KAAK+Q,OAAO5M,MAAqB,EAAdhC,EAAKZ,QAEhDvB,KAAKiB,IAAIgB,YA1GjB,wCA8GQ,IAAME,EAAOnC,KAAKqB,UAElBrB,KAAKiB,IAAIO,OACTxB,KAAKiB,IAAIS,YAET,IAAM2V,EAAYrX,KAAKmB,gBAAgB,CAAEf,EAAGJ,KAAK+Q,OAAO7M,IAAI9D,EAAGC,EAAGL,KAAK+Q,OAAO7M,IAAI7D,IAE5E4Q,EAAWjR,KAAK0X,oBAAoB1X,KAAKiR,UAC/CjR,KAAKiB,IAAI0W,OAAO1G,EAAS5J,QAAQjH,EAAG6Q,EAAS5J,QAAQhH,GACrDL,KAAKiB,IAAIW,OAAOqP,EAASvJ,SAAStH,EAAG6Q,EAASvJ,SAASrH,GACvDL,KAAKiB,IAAIW,OAAOqP,EAAS3I,YAAYlI,EAAG6Q,EAAS3I,YAAYjI,GAC7DL,KAAKiB,IAAIW,OAAOqP,EAAS1J,WAAWnH,EAAG6Q,EAAS1J,WAAWlH,GAC3DL,KAAKiB,IAAIQ,UAAU4V,EAAUjX,EAAGiX,EAAUhX,GAE1CL,KAAKiB,IAAIY,OAAOkB,KAAKC,GAAKhD,KAAK+Q,OAAO9Q,MAAQ8C,KAAKC,GAAK,GAExD,IAAM4U,EAA2B,EAApB5X,KAAK+Q,OAAO5M,MAAa,EAChC0T,EAAgB7X,KAAKiB,IAAIsW,qBAAqB,EAAG,EAAGK,EAAK,GAE3D5X,KAAK+Q,OAAOrK,YAAcpH,EAAcmI,SACxCzH,KAAKiB,IAAIQ,WAAWmW,GAAM,KAE1BC,EAAcL,aAAa,EAAG,iBAAmBxX,KAAK+Q,OAAO2B,QAAU,KACvEmF,EAAcL,aAAa,GAAK,uBAChCK,EAAcL,aAAa,GAAK,iBAAmBxX,KAAK+Q,OAAO2B,QAAU,KACzEmF,EAAcL,aAAa,EAAG,sBAE9BxX,KAAKiB,IAAIQ,UAAU,GAAI,KAEvBoW,EAAcL,aAAa,EAAG,iBAAmBxX,KAAK+Q,OAAO2B,QAAU,KACvEmF,EAAcL,aAAa,GAAK,uBAChCK,EAAcL,aAAa,GAAK,iBAAmBxX,KAAK+Q,OAAO2B,QAAU,KACzEmF,EAAcL,aAAa,EAAG,qBAGlCxX,KAAKiB,IAAIa,OAET9B,KAAKiB,IAAIwB,UAAYoV,EACrB7X,KAAKiB,IAAIwW,SAAS,EAAG,EAAGG,EAAmB,EAAdzV,EAAKZ,QAElCvB,KAAKiB,IAAIgB,YAtJjB,8BA0JQjC,KAAKiB,IAAIwB,UAAY,QACrBzC,KAAKiB,IAAIwW,SAAS,EAAG,EAAGzX,KAAK6W,OAAO1S,MAAOnE,KAAK6W,OAAOtV,YA3J/D,GAAkCoP,GCKZmH,EAAtB,WAsBE,WAAsBC,EAAsBzO,EAAesH,GAAuB,IAAD,gCArB9DsE,mBAqB8D,OAnB9D5L,SAmB8D,OAlB9D0O,aAkB8D,OAjBvEC,iBAiBuE,OAfzEC,WAAwB,KAeiD,KAdhEC,aAAe,IAciD,KAbhEhI,mBAagE,OAXzEiI,SAAW,WACjB,EAAKnG,UAU0E,KA8IzEoG,YAAc,SAAClR,GACrB,GAAI,EAAKmR,YAAYnR,EAAEoR,QAAS,CAC9B,IAAMrU,EAAM,EAAKsU,YAAYrR,EAAEsR,QAAStR,EAAEuR,SAE1C,EAAKpP,IAAIqP,eAAezU,GAExBiD,EAAEyR,mBApJ2E,KAwJzEC,aAAe,SAAC1R,GACtB,GAAI,EAAKmR,YAAYnR,EAAEoR,SACjBpR,EAAE2R,eAAezS,OAAS,EAAG,CAC/B,IAAM0S,EAAI5R,EAAE2R,eAAe,GACrB5U,EAAM,EAAKsU,YAAYO,EAAEN,QAASM,EAAEL,SAE1C,EAAKR,WAAa,CAChBc,MAAO9U,EACP+U,KAAMC,KAAKC,OAIbC,YAAW,WACe,OAApB,EAAKlB,YACP,EAAK5O,IAAIqP,eAAezU,KAEzB,EAAKiU,cAEH,EAAK7O,IAAIW,cAAciG,qBAAqB/I,EAAEyR,mBA1KwB,KA+KzES,UAAY,SAAClS,GACnB,IAAMjD,EAAM,EAAKsU,YAAYrR,EAAEsR,QAAStR,EAAEuR,SAE1C,EAAKpP,IAAIgQ,SAASpV,IAlL6D,KAqLzEqV,YAAc,SAACpS,GACrB,IAAMjD,EAAM,EAAKsU,YAAYrR,EAAEsR,QAAStR,EAAEuR,SAE1C,EAAKpP,IAAIkQ,SAAStV,GAAK,IAxLwD,KA2LzEuV,YAAc,SAACtS,GACrB,GAAIA,EAAE2R,eAAezS,OAAS,EAAG,CAC/B,IAAM0S,EAAI5R,EAAE2R,eAAe,GACrB5U,EAAM,EAAKsU,YAAYO,EAAEN,QAASM,EAAEL,SAEtC,EAAKpP,IAAIW,cAAciG,qBACD,OAApB,EAAKgI,aAELnV,KAAKyC,IAAI,EAAK0S,WAAWc,MAAM5Y,EAAI8D,EAAI9D,GAAK,IAC5C,EAAKkJ,IAAIoQ,aAAela,EAAckK,OAElCvC,EAAEwS,YAAY,EAAKrQ,IAAIkQ,SAAStV,GAAK,GAIzC,EAAKoF,IAAIoQ,aAAela,EAAckK,MACxCvC,EAAEyR,kBAGJ,EAAKtP,IAAIkQ,SAAStV,GAAK,KA9MoD,KAmNzE0V,WAAa,SAACzS,GACpB,GAAIA,EAAE2R,eAAezS,OAAS,EAAG,CAC/B,IAAM0S,EAAI5R,EAAE2R,eAAe,GACrB5U,EAAM,EAAKsU,YAAYO,EAAEN,QAASM,EAAEL,SACtCmB,GAAU,EAGd,GAAwB,OAApB,EAAK3B,WAAqB,CAC5B,IAAM4B,EAAK5V,EAAI9D,EAAI,EAAK8X,WAAWc,MAAM5Y,EACnC2Z,EAAQhX,KAAKyC,IAAItB,EAAI7D,EAAI,EAAK6X,WAAWc,MAAM3Y,GAGnD0C,KAAKyC,IAAIsU,GAAM,EAAK3J,eACpB4J,EAA6B,EAArB,EAAK5J,eACb+I,KAAKC,MAAQ,EAAKjB,WAAWe,KAAO,EAAKd,eAErC2B,EAAK,EACP,EAAKxQ,IAAImE,SACP,EAAKyK,WAAWc,MAAM3Y,EAAI,EAAKiJ,IAAI0Q,YAAY3Y,UAAUE,OAAS,EAC9DhC,EAAWiI,IACXjI,EAAW+H,QAGjB,EAAKgC,IAAIkE,SACP,EAAK0K,WAAWc,MAAM3Y,EAAI,EAAKiJ,IAAI0Q,YAAY3Y,UAAUE,OAAS,EAC9DhC,EAAWiI,IACXjI,EAAW+H,QAGnBuS,GAAU,GAGZ,EAAK3B,WAAa,KAGpB,EAAK5O,IAAIgQ,SAASpV,EAAK2V,KArPzB7Z,KAAKkV,cAAgB6C,EAErBA,EAAQhD,UAAUC,IAAI,eAEtB+C,EAAQkC,mBAAmB,aAAc,oCAEzCja,KAAKgY,QAAUD,EAAQmC,cAAc,iBAErCla,KAAKsJ,IAAMA,EAEX,IAAM6Q,EAAIna,KAAKsJ,IAAIW,cAAc4F,YAAc,EAAI,EAGnDkI,EAAQzC,MAAM9F,SAAWoB,EAAQpB,SAAW2K,EAAI,KAChDpC,EAAQzC,MAAM5F,UAAYkB,EAAQlB,UAAY,KAE1CkB,EAAQxK,OAASgD,EAASmG,QAC5BwI,EAAQzC,MAAM9F,SAAWoB,EAAQzM,MAAQgW,EAAI,KAC7CpC,EAAQzC,MAAM5F,UAAYkB,EAAQrP,OAAS,MAGzCqP,EAAQb,WACVgI,EAAQzC,MAAMnR,MAAQ,OACtB4T,EAAQzC,MAAM7F,SAA8B,EAAnBmB,EAAQnB,SAAe,MAGlDsI,EAAQzC,MAAMC,QAAU,QAExB/D,OAAO4I,iBAAiB,SAAUpa,KAAKoY,UAAU,GACjDpY,KAAKmQ,cAAgBS,EAAQT,cApDjC,sDA2DQnQ,KAAKsJ,IAAIW,cAAcoG,gBAAgBrQ,KAAKqa,iBAEhDra,KAAKiY,YAAY5C,SACjBrV,KAAKgY,QAAQ3C,WA9DjB,uCA4EI,OAAOrV,KAAKiY,cA5EhB,mCAqFI,OAAOjY,KAAKgY,UArFhB,0CA6F6BnY,GACzBG,KAAKgY,QAAQjD,UAAUM,OAAO,aAAc,eAExCxV,IAAgByL,EAAYuD,UAC1B7O,KAAKsJ,IAAIW,cAAc8F,WACzB/P,KAAKgY,QAAQ1C,MAAMgF,cAChBta,KAAKsJ,IAAIW,cAAc1I,OAASvB,KAAKsJ,IAAIW,cAAc9F,MAAS,IAAM,KAE3EnE,KAAKgY,QAAQjD,UAAUC,IAAI,gBAEvBhV,KAAKsJ,IAAIW,cAAc8F,WACzB/P,KAAKgY,QAAQ1C,MAAMgF,cAChBta,KAAKsJ,IAAIW,cAAc1I,QAAyC,EAA/BvB,KAAKsJ,IAAIW,cAAc9F,OAAc,IACvE,KAEJnE,KAAKgY,QAAQjD,UAAUC,IAAI,gBAG7BhV,KAAKiS,WA/GT,uCAmHIT,OAAO+I,oBAAoB,SAAUva,KAAKoY,UAE1CpY,KAAKiY,YAAYsC,oBAAoB,YAAava,KAAKqY,aACvDrY,KAAKiY,YAAYsC,oBAAoB,aAAcva,KAAK6Y,cACxDrH,OAAO+I,oBAAoB,YAAava,KAAKuZ,aAC7C/H,OAAO+I,oBAAoB,YAAava,KAAKyZ,aAC7CjI,OAAO+I,oBAAoB,UAAWva,KAAKqZ,WAC3C7H,OAAO+I,oBAAoB,WAAYva,KAAK4Z,cA1HhD,oCA8HIpI,OAAO4I,iBAAiB,SAAUpa,KAAKoY,UAAU,GAC5CpY,KAAKsJ,IAAIW,cAAcoG,iBAE5BrQ,KAAKiY,YAAYmC,iBAAiB,YAAapa,KAAKqY,aACpDrY,KAAKiY,YAAYmC,iBAAiB,aAAcpa,KAAK6Y,cACrDrH,OAAO4I,iBAAiB,YAAapa,KAAKuZ,aAC1C/H,OAAO4I,iBAAiB,YAAapa,KAAKyZ,YAAa,CACrDe,SAAUxa,KAAKsJ,IAAIW,cAAciG,sBAEnCsB,OAAO4I,iBAAiB,UAAWpa,KAAKqZ,WACxC7H,OAAO4I,iBAAiB,WAAYpa,KAAK4Z,eAxI7C,kCAiJsBxZ,EAAWC,GAC7B,IAAM8B,EAAOnC,KAAKiY,YAAYwC,wBAE9B,MAAO,CACLra,EAAGA,EAAI+B,EAAKE,KACZhC,EAAGA,EAAI8B,EAAKG,OAtJlB,kCA0JsBiW,GAClB,OAAiD,IAA7CvY,KAAKsJ,IAAIW,cAAcmG,qBACvBsK,MAAMC,QAAQ3a,KAAKsJ,IAAIW,cAAcmG,qBAClCpQ,KAAKsJ,IAAIW,cAAcmG,kBAA+BwK,SAAUrC,EAAuBsC,QAAQC,oBA7J1G,KCPaC,EAAb,kDAGI,WACIhD,EACAzO,EACAsH,EACA2F,GACD,IAAD,uBACE,cAAMwB,EAASzO,EAAKsH,IARhB2F,WAON,EAIE,EAAKyB,QAAQiC,mBAAmB,aAAc,kCAE9C,EAAKhC,YAAcF,EAAQmC,cAAc,eAEzC,EAAK3D,MAAQA,EARf,oBASqBA,GATrB,IASE,2BAA0B,CAAC,IAAhByE,EAAe,QACtB,EAAK/C,YAAY9C,YAAY6F,IAVnC,qCAaE,EAAKC,cAbP,EARN,oDAwB0B,IAAD,gBACEjb,KAAKuW,OADP,IACjB,2BAA+B,CAAC,IAArByE,EAAoB,QAC3Bhb,KAAKkV,cAAcC,YAAY6F,IAFlB,iCAxBzB,kCAmCuBzE,GACfvW,KAAKqa,iBAELra,KAAKiY,YAAYiD,UAAY,GAHwC,oBAKlD3E,GALkD,IAKrE,2BAA0B,CAAC,IAAhByE,EAAe,QACtBhb,KAAKiY,YAAY9C,YAAY6F,IANoC,8BAQrEhb,KAAKuW,MAAQA,EAEbvW,KAAKib,gBA7Cb,+BAiDQjb,KAAKsJ,IAAI0Q,YAAY/H,aAjD7B,GAA4B6F,GCAfqD,EAAb,kDAGI,WAAYpD,EAAsBzO,EAAesH,GAAuB,IAAD,8BACnE,cAAMmH,EAASzO,EAAKsH,IAHPiG,YAEsD,EAGnE,EAAKmB,QAAQkD,UAAY,wCAEzB,EAAKrE,OAASkB,EAAQqD,iBAAiB,UAAU,GAEjD,EAAKnD,YAAc,EAAKpB,OAExB,EAAKwE,eACL,EAAKJ,cAV8D,EAH3E,2DAiBQ,IAAMK,EAAKC,iBAAiBvb,KAAK6W,QAC3B1S,EAAQ4C,SAASuU,EAAGE,iBAAiB,SAAU,IAC/Cja,EAASwF,SAASuU,EAAGE,iBAAiB,UAAW,IAEvDxb,KAAK6W,OAAO1S,MAAQA,EACpBnE,KAAK6W,OAAOtV,OAASA,IAtB7B,kCA6BQ,OAAOvB,KAAK6W,SA7BpB,+BAiCQ7W,KAAKqb,eACLrb,KAAKsJ,IAAI0Q,YAAY/H,aAlC7B,GAA8B6F,GCaR2D,EAAtB,iDACYC,OAAS,IAAIC,IADzB,+CAScC,EAAmBC,GAOzB,OANK7b,KAAK0b,OAAOI,IAAIF,GAGjB5b,KAAK0b,OAAOK,IAAIH,GAAWpV,KAAKqV,GAFhC7b,KAAK0b,OAAOM,IAAIJ,EAAW,CAACC,IAKzB7b,OAhBf,0BAwBeic,GACPjc,KAAK0b,OAAOQ,OAAOD,KAzB3B,8BA4BsBL,EAAmBtS,GAA6C,IAA9B6S,EAA6B,uDAAZ,KACjE,GAAKnc,KAAK0b,OAAOI,IAAIF,GAArB,CAD6E,oBAGtD5b,KAAK0b,OAAOK,IAAIH,IAHsC,IAG7E,2BAAmD,CAAC,IAAzCC,EAAwC,QAC/CA,EAAS,CAAEM,OAAMC,OAAQ9S,KAJgD,oCA5BrF,KCTa+S,EAAb,kDAmBE,WAAY/S,EAAesH,EAAsBgE,GAAuB,IAAD,8BACrE,cAAMtL,EAAKsH,IAlBIgE,aAiBsD,IAdtD2B,WAcsD,IAZ/D+F,YAA2B,KAYoC,EAX/DC,YAA2B,KAWoC,EAV/DC,WAA0B,KAUqC,EAT/DC,gBAA+B,KAYrC,EAAK7H,QAAUA,EAEf,EAAK8H,gBALgE,EAnBzE,4DA4BI1c,KAAK4U,QAAQqF,mBACX,YADF,oMAQAja,KAAKsc,YAActc,KAAK4U,QAAQsF,cAAc,qBAC9Cla,KAAKuc,YAAcvc,KAAK4U,QAAQsF,cAAc,qBAC9Cla,KAAKwc,WAAaxc,KAAK4U,QAAQsF,cAAc,oBAC7Cla,KAAKyc,gBAAkBzc,KAAK4U,QAAQsF,cAAc,2BAvCtD,oCA2CI,oEAEAla,KAAKsc,YAAYhH,MAAMe,QAAU,gBACjCrW,KAAKuc,YAAYjH,MAAMe,QAAU,gBACjCrW,KAAKwc,WAAWlH,MAAMe,QAAU,gBAChCrW,KAAKyc,gBAAgBnH,MAAMe,QAAU,kBAhDzC,+BAoDuBrW,KAAK4U,QAAQsF,cAAc,sBAG5Cla,KAAK0c,kBAvDX,4CA+DI,IAAMva,EAAOnC,KAAKqB,UAEZ4K,EACJjM,KAAK+Q,OAAO9E,SAAW,IAAM,IAAMjM,KAAK+Q,OAAO9E,SAAWjM,KAAK+Q,OAAO9E,SAEpE0Q,GAAoB,IAAM1Q,IAAa,IAAM9J,EAAKf,WAAc,IAAM,GACtEub,EAAkBxa,EAAKf,YAAWub,EAAkBxa,EAAKf,WAsB7DpB,KAAKyc,gBAAgBnH,MAAMC,QAAU,QACrCvV,KAAKyc,gBAAgBnH,MAAMsH,QAAU5c,KAAKiK,cAAc6F,YAAc,GAAG9D,SAAS,IAClFhM,KAAKyc,gBAAgBnH,MAAMnR,MAAQwY,EAAkB,KACrD3c,KAAKyc,gBAAgBnH,MAAM/T,OAASY,EAAKZ,OAAS,KAClDvB,KAAKyc,gBAAgBnH,MAAMuH,WAA3B,+DACyB7c,KAAK+Q,OAAO2B,QAAUzG,EAAY,IAD3D,6CAIAjM,KAAKyc,gBAAgBnH,MAAMjT,KAAOF,EAAKE,KAAOF,EAAKgC,MAAQ,EAAI,KAC/DnE,KAAKyc,gBAAgBnH,MAAMM,gBAAkB,MAE7C5V,KAAKyc,gBAAgBnH,MAAMO,UACxB7V,KAAK4M,iBAAmBtN,EAAcmI,SAAWzH,KAAK+Q,OAAO9E,SAAW,KACtEjM,KAAK4M,iBAAmBtN,EAAcqI,MAAQ3H,KAAK+Q,OAAO9E,UAAY,IACrE,uBACA,yCA1GV,4CAiHI,IAAM9J,EAAOnC,KAAKqB,UAKd+V,GAAe,KAFjBpX,KAAK+Q,OAAO9E,SAAW,IAAM,IAAMjM,KAAK+Q,OAAO9E,SAAWjM,KAAK+Q,OAAO9E,YAElC,IAAM9J,EAAKf,WAAc,IAAM,GACjEgW,EAAajV,EAAKf,YAAWgW,EAAajV,EAAKf,WAqBnDpB,KAAKwc,WAAWlH,MAAMC,QAAU,QAChCvV,KAAKwc,WAAWlH,MAAMsH,QAAU5c,KAAKiK,cAAc6F,YAAc,GAAG9D,SAAS,IAC7EhM,KAAKwc,WAAWlH,MAAMnR,MAAQiT,EAAa,KAC3CpX,KAAKwc,WAAWlH,MAAM/T,OAASY,EAAKZ,OAAS,KAC7CvB,KAAKwc,WAAWlH,MAAMuH,WAAtB,8DACwB7c,KAAK+Q,OAAO2B,QADpC,gCAGA1S,KAAKwc,WAAWlH,MAAMjT,KAAOF,EAAKE,KAAOF,EAAKgC,MAAQ,EAAI,KAC1DnE,KAAKwc,WAAWlH,MAAMM,gBAAkB,MAExC5V,KAAKwc,WAAWlH,MAAMO,UACnB7V,KAAK4M,iBAAmBtN,EAAcmI,SAAWzH,KAAK+Q,OAAO9E,SAAW,KACtEjM,KAAK4M,iBAAmBtN,EAAcqI,MAAQ3H,KAAK+Q,OAAO9E,UAAY,IACrE,uCACA,yBA1JV,wCAqLI,IApBA,IAAM9J,EAAOnC,KAAKqB,UAEZsb,EAAuC,EAApB3c,KAAK+Q,OAAO5M,MAAa,EAC5C2Y,EAAkB9c,KAAK4M,iBAAmBtN,EAAcmI,QAAUkV,EAAkB,EAEpFI,EACJ/c,KAAK4M,iBAAmBtN,EAAcmI,QAAU,UAAY,WAExD4P,EAAYrX,KAAKmB,gBAAgBnB,KAAK+Q,OAAO7M,KAE7CjE,EAAQD,KAAK+Q,OAAO9Q,MAAS,EAAI8C,KAAKC,GAAM,EAS9C+S,EAAU,YACd,MARa,CACX/V,KAAKiR,SAAS5J,QACdrH,KAAKiR,SAASvJ,SACd1H,KAAKiR,SAAS3I,YACdtI,KAAKiR,SAAS1J,YAIhB,eAAsB,CAAjB,IAAM5F,EAAC,KACNqU,EACFhW,KAAK4M,iBAAmBtN,EAAcqI,KAClC,CACAvH,GAAIuB,EAAEvB,EAAIJ,KAAK+Q,OAAO7M,IAAI9D,EAC1BC,EAAGsB,EAAEtB,EAAIL,KAAK+Q,OAAO7M,IAAI7D,GAEzB,CACAD,EAAGuB,EAAEvB,EAAIJ,KAAK+Q,OAAO7M,IAAI9D,EACzBC,EAAGsB,EAAEtB,EAAIL,KAAK+Q,OAAO7M,IAAI7D,GAK/B0V,IAFAC,EAAI7S,EAAO8S,gBAAgBD,EAAG,CAAE5V,EAAG0c,EAAiBzc,EAAG,KAAOJ,IAEjDG,EAAI,MAAQ4V,EAAE3V,EAAI,OAEjC0V,EAAUA,EAAQG,MAAM,GAAI,GAC5BH,GAAW,IAqBX/V,KAAKuc,YAAYjH,MAAMC,QAAU,QACjCvV,KAAKuc,YAAYjH,MAAMsH,QAAU5c,KAAKiK,cAAc6F,YAAc,IAAI9D,SAAS,IAC/EhM,KAAKuc,YAAYjH,MAAMnR,MAAQwY,EAAkB,KACjD3c,KAAKuc,YAAYjH,MAAM/T,OAAuB,EAAdY,EAAKZ,OAAa,KAClDvB,KAAKuc,YAAYjH,MAAMuH,WAAvB,0BAAuDE,EAAvD,wCACwB/c,KAAK+Q,OAAO2B,QADpC,kFAGwB1S,KAAK+Q,OAAO2B,QAHpC,8CAMA1S,KAAKuc,YAAYjH,MAAMM,gBAAkBkH,EAAkB,WAC3D9c,KAAKuc,YAAYjH,MAAMO,UAAvB,sBAAkDwB,EAAUjX,EAAI0c,EAAhE,eAAsFzF,EAAUhX,EAAI,IAApG,yBACmBJ,EADnB,QAEAD,KAAKuc,YAAYjH,MAAMQ,SAAWC,EAClC/V,KAAKuc,YAAYjH,MAAMK,YAAY,oBAAqBI,KAzO5D,wCAkQI,IAlBA,IAAM5T,EAAOnC,KAAKqB,UAEZgW,EAAYrX,KAAKmB,gBAAgB,CAAEf,EAAGJ,KAAK+Q,OAAO7M,IAAI9D,EAAGC,EAAGL,KAAK+Q,OAAO7M,IAAI7D,IAE5EJ,EAAQD,KAAK+Q,OAAO9Q,MAAS,EAAI8C,KAAKC,GAAM,EAC5C8Z,EAAkB9c,KAAK4M,iBAAmBtN,EAAcqI,KAAO3H,KAAK+Q,OAAO5M,MAAQ,EAEnF4Y,EACJ/c,KAAK4M,iBAAmBtN,EAAcmI,QAAU,WAAa,UAS3DsO,EAAU,YACd,MARa,CACX,CAAE3V,EAAG,EAAGC,EAAG,GACX,CAAED,EAAG+B,EAAKf,UAAWf,EAAG,GACxB,CAAED,EAAG+B,EAAKf,UAAWf,EAAG8B,EAAKZ,QAC7B,CAAEnB,EAAG,EAAGC,EAAG8B,EAAKZ,SAIlB,eAAsB,CAAjB,IAAMI,EAAC,KACV,GAAU,OAANA,EAAY,CACd,IAAIqU,EACFhW,KAAK4M,iBAAmBtN,EAAcqI,KAClC,CACAvH,GAAIuB,EAAEvB,EAAIJ,KAAK+Q,OAAO7M,IAAI9D,EAC1BC,EAAGsB,EAAEtB,EAAIL,KAAK+Q,OAAO7M,IAAI7D,GAEzB,CACAD,EAAGuB,EAAEvB,EAAIJ,KAAK+Q,OAAO7M,IAAI9D,EACzBC,EAAGsB,EAAEtB,EAAIL,KAAK+Q,OAAO7M,IAAI7D,GAK/B0V,IAFAC,EAAI7S,EAAO8S,gBAAgBD,EAAG,CAAE5V,EAAG0c,EAAiBzc,EAAG,KAAOJ,IAEjDG,EAAI,MAAQ4V,EAAE3V,EAAI,QAInC0V,EAAUA,EAAQG,MAAM,GAAI,GAC5BH,GAAW,IAkBX/V,KAAKsc,YAAYhH,MAAMC,QAAU,QACjCvV,KAAKsc,YAAYhH,MAAMsH,QAAU5c,KAAKiK,cAAc6F,YAAc,IAAI9D,SAAS,IAC/EhM,KAAKsc,YAAYhH,MAAMnR,MAAQnE,KAAK+Q,OAAO5M,MAAQ,KACnDnE,KAAKsc,YAAYhH,MAAM/T,OAAuB,EAAdY,EAAKZ,OAAa,KAClDvB,KAAKsc,YAAYhH,MAAMuH,WAAvB,0BAAuDE,EAAvD,2BAAyF/c,KAAK+Q,OAAO2B,QAArG,wBACA1S,KAAKsc,YAAYhH,MAAMM,gBAAkBkH,EAAkB,WAC3D9c,KAAKsc,YAAYhH,MAAMO,UAAvB,sBAAkDwB,EAAUjX,EAAI0c,EAAhE,eAAsFzF,EAAUhX,EAAI,IAApG,yBACmBJ,EADnB,QAEAD,KAAKsc,YAAYhH,MAAMQ,SAAWC,EAClC/V,KAAKsc,YAAYhH,MAAMK,YAAY,oBAAqBI,KAjT5D,qCAwTQ/V,KAAKH,cAAgByL,EAAYuD,UAA8B,OAAlB7O,KAAK6Q,WAGpD7Q,KAAK0G,YAAcpH,EAAcqI,MACX,OAAtB3H,KAAKuJ,cACLvJ,KAAKuJ,aAAayT,sBAAwB3d,EAAYuM,MAErD5L,KAAK6Q,SAAsBoM,aAAa3H,MAAMsH,QAC7C5c,KAAKiK,cAAc6F,YAAc,GACjC9D,SAAS,IAEXhM,KAAK6Q,SAASqM,oBAAoB,IAAMld,KAAKuJ,aAAa4T,gBAC1Dnd,KAAK6Q,SAASmG,KAAKhX,KAAKuJ,aAAayT,sBAErChd,KAAK6Q,SAASkG,WAAW3X,EAAgB4T,SAtU/C,sCA8U2B,OAAnBhT,KAAK8Q,YAGP9Q,KAAK0G,YAAcpH,EAAcmI,SACX,OAAtBzH,KAAKuJ,cACLvJ,KAAKuJ,aAAayT,sBAAwB3d,EAAYuM,MAErD5L,KAAK8Q,UAAuBmM,aAAa3H,MAAMsH,QAC9C5c,KAAKiK,cAAc6F,YAAc,GACjC9D,SAAS,IAEXhM,KAAK8Q,UAAUoM,oBAAoB,IAAMld,KAAKuJ,aAAa4T,gBAC3Dnd,KAAK8Q,UAAUkG,KAAKhX,KAAKuJ,aAAayT,sBAEtChd,KAAK8Q,UAAUiG,WAAW3X,EAAgBgD,UA5VhD,uCAoWI,GAAwB,OAApBpC,KAAKwJ,WAAT,CAEA,IAAMxI,EACiB,MAArBhB,KAAKuJ,aAAuBvJ,KAAKuJ,aAAayT,oBAAsB,KAEhEhd,KAAKH,cAAgByL,EAAYuD,UAAY7O,KAAK0G,YAAcpH,EAAcqI,OACjF3H,KAAKwJ,WAAwByT,aAAa3H,MAAMsH,QAC/C5c,KAAKiK,cAAc6F,YAAc,GACjC9D,SAAS,IAEXhM,KAAKwJ,WAAWwN,KAAKhW,OA9W3B,kCAmXIhB,KAAK8W,QAEL9W,KAAKod,eAELpd,KAAKqd,gBAELrd,KAAKsd,iBAEoB,MAArBtd,KAAKuJ,eACNvJ,KAAKuJ,aAA0B0T,aAAa3H,MAAMsH,QACjD5c,KAAKiK,cAAc6F,YAAc,GACjC9D,SAAS,IAEXhM,KAAKuJ,aAAayN,QAGD,MAAfhX,KAAK+Q,QAAwC,OAAtB/Q,KAAKuJ,eAC1BvJ,KAAKuJ,aAAayT,sBAAwB3d,EAAYmV,MACxDxU,KAAKkX,kBACLlX,KAAKmX,oBAELnX,KAAKud,sBACLvd,KAAKwd,0BAzYb,8BA8YyB,IAAD,gBACDxd,KAAKsJ,IAAI4B,oBAAoBuS,YAD5B,IACpB,2BAA4D,CAAC,IAAlDvQ,EAAiD,QAExDA,IAASlN,KAAK6Q,UACd3D,IAASlN,KAAK8Q,WACd5D,IAASlN,KAAKuJ,cACd2D,IAASlN,KAAKwJ,aAEb0D,EAAkB+P,aAAa3H,MAAMC,QAAU,QAG9CrI,EAAKkI,qBAAuBpV,KAAKuJ,cACnC2D,EAAKwQ,qBAZW,iCA9YxB,+BAgaI,+DAEuB,OAAnB1d,KAAK8Q,YACP9Q,KAAK8Q,UAAUiC,eAAe3T,EAAgBgD,OAC7CpC,KAAK8Q,UAAuB6M,cAGT,OAAlB3d,KAAK6Q,WACP7Q,KAAK6Q,SAASkC,eAAe3T,EAAgB4T,MAC5ChT,KAAK6Q,SAAsB8M,kBAzalC,GAAgChN,GCYnBiN,G,MAAb,kDAqBE,WAAY7F,EAAsBnH,GAAgC,IAAD,8BAC/D,gBArBMiN,mBAoByD,IAnBzDC,aAAc,EAmB2C,EAlBzDC,YAAa,EAkB4C,EAhBhDnN,QAAuB,KAgByB,EAfhDoN,WAegD,IAbzD7K,MAAwB,KAaiC,EAZzD8K,oBAYyD,IAXzDve,YAWyD,IATzDwe,QASyD,EAG/D,EAAKtN,SAAU,IAAIxB,GAAWnF,YAAY2G,GAC1C,EAAKoN,MAAQjG,EAJkD,EArBnE,sDAgCI/X,KAAKke,GAAGC,UACRne,KAAKge,MAAM3I,WAjCf,+BAwCIrV,KAAKN,OAAOuS,SACZjS,KAAKmT,MAAMiL,SAzCf,qCAiDwB7J,GAA6B,IAAD,OAChDvU,KAAKke,GAAK,IAAI/C,EAASnb,KAAKge,MAAOhe,KAAMA,KAAK4Q,SAE9C,IAAMiG,EAAU7W,KAAKke,GAAgBG,YACrCre,KAAKN,OAAS,IAAIiX,EAAa3W,KAAMA,KAAK4Q,QAASiG,GAEnD7W,KAAKie,eAAiB,IAAI5U,EAAKrJ,KAAKN,OAAQM,MAE5CA,KAAKmT,MAAQ,IAAImB,EAAoBtU,KAAMA,KAAKN,OAAQ6U,GACxDvU,KAAKmT,MAAMsB,OAEXzU,KAAKN,OAAOoK,QAEZ9J,KAAKmT,MAAMiL,KAAKpe,KAAK4Q,QAAQtB,WAG7B8J,YAAW,WACT,EAAK8E,GAAGjM,SACR,EAAKqM,QAAQ,OAAQ,EAAM,CACzBpR,KAAM,EAAK0D,QAAQtB,UACnBiP,KAAM,EAAK7e,OAAO2L,qBAEnB,KAvEP,mCA+EsBkL,GAAuD,IAAD,OACxEvW,KAAKke,GAAK,IAAInD,EAAO/a,KAAKge,MAAOhe,KAAMA,KAAK4Q,QAAS2F,GAErDvW,KAAKN,OAAS,IAAI2c,EAAWrc,KAAMA,KAAK4Q,QAAS5Q,KAAKke,GAAGtL,kBAEzD5S,KAAKie,eAAiB,IAAI5U,EAAKrJ,KAAKN,OAAQM,MAE5CA,KAAKmT,MAAQ,IAAImD,EAAmBtW,KAAMA,KAAKN,OAAQM,KAAKke,GAAGtL,iBAAkB2D,GACjFvW,KAAKmT,MAAMsB,OAEXzU,KAAKN,OAAOoK,QAEZ9J,KAAKmT,MAAMiL,KAAKpe,KAAK4Q,QAAQtB,WAG7B8J,YAAW,WACT,EAAK8E,GAAGjM,SACR,EAAKqM,QAAQ,OAAQ,EAAM,CACzBpR,KAAM,EAAK0D,QAAQtB,UACnBiP,KAAM,EAAK7e,OAAO2L,qBAEnB,KApGP,uCA4G0BkJ,GACtB,IAAMpH,EAAUnN,KAAKmT,MAAMnE,sBAE3BhP,KAAKmT,MAAMgL,UACXne,KAAKmT,MAAQ,IAAImB,EAAoBtU,KAAMA,KAAKN,OAAQ6U,GACxDvU,KAAKmT,MAAMsB,OAEXzU,KAAKmT,MAAMiL,KAAKjR,GAChBnN,KAAKse,QAAQ,SAAUte,KAAM,CAC3BkN,KAAMC,EACNoR,KAAMve,KAAKN,OAAO2L,qBAtHxB,qCA+HwBkL,GACpB,IAAMpJ,EAAUnN,KAAKmT,MAAMnE,sBAE3BhP,KAAKmT,MAAMgL,UACXne,KAAKmT,MAAQ,IAAImD,EAAmBtW,KAAMA,KAAKN,OAAQM,KAAKke,GAAGtL,iBAAkB2D,GACjFvW,KAAKmT,MAAMsB,OACVzU,KAAKke,GAAcM,YAAYjI,GAChCvW,KAAKN,OAAO+e,SAEZze,KAAKmT,MAAMiL,KAAKjR,GAChBnN,KAAKse,QAAQ,SAAUte,KAAM,CAC3BkN,KAAMC,EACNoR,KAAMve,KAAKN,OAAO2L,qBA3IxB,8BAmJIrL,KAAKmT,MAAMgL,UACVne,KAAKke,GAAcpH,UApJxB,uCA2JI9W,KAAKmT,MAAMuL,aA3Jf,uCAkKI1e,KAAKmT,MAAMwL,aAlKf,iCA0KoBzR,GAChBlN,KAAKmT,MAAMiL,KAAKlR,KA3KpB,iCAmL8D,IAA5CvG,EAA2C,uDAAtBpH,EAAWiI,IAC9CxH,KAAKie,eAAezQ,SAAS7G,KApLjC,iCA4L8D,IAA5CA,EAA2C,uDAAtBpH,EAAWiI,IAC9CxH,KAAKie,eAAexQ,SAAS9G,KA7LjC,2BAsMcuG,GAA0D,IAA5CvG,EAA2C,uDAAtBpH,EAAWiI,IACxDxH,KAAKie,eAAeW,WAAW1R,EAAMvG,KAvMzC,kCA+MqB+H,GACjB1O,KAAKse,QAAQ,cAAete,KAAM0O,KAhNtC,sCAwNyBmQ,GACrB7e,KAAKse,QAAQ,OAAQte,KAAM6e,KAzN/B,wCAiO2BC,GACvB9e,KAAKke,GAAGa,oBAAoBD,GAC5B9e,KAAKiS,SACLjS,KAAKse,QAAQ,oBAAqBte,KAAM8e,KApO5C,qCA6OI,OAAO9e,KAAKmT,MAAMlE,iBA7OtB,4CAsPI,OAAOjP,KAAKmT,MAAMnE,wBAtPtB,8BA+PiB4E,GACb,OAAO5T,KAAKmT,MAAM6L,QAAQpL,KAhQ9B,kCAyQI,OAAO5T,KAAKN,SAzQhB,0CAkRI,OAAOM,KAAKie,iBAlRhB,uCA2RI,OAAOje,KAAKN,OAAO2L,mBA3RvB,sCAoSI,OAAOrL,KAAKN,OAAO2B,YApSvB,oCA6SI,OAAOrB,KAAK4Q,UA7ShB,8BAsTI,OAAO5Q,KAAKke,KAtThB,iCA+TI,OAAOle,KAAKie,eAAevE,aA/T/B,0CAwUI,OAAO1Z,KAAKmT,QAxUhB,qCAgVwBjP,GACpBlE,KAAK6d,cAAgB3Z,EACrBlE,KAAK8d,aAAc,EACnB9d,KAAK+d,YAAa,IAnVtB,+BA4VkB7Z,EAAY+a,GACrBjf,KAAK8d,aAAgBmB,IAAWjf,KAAK4Q,QAAQN,gBAEvCtQ,KAAK8d,aACV3a,EAAOO,2BAA2B1D,KAAK6d,cAAe3Z,GAAO,IAC/DlE,KAAK+d,YAAa,EAClB/d,KAAKie,eAAeiB,KAAKhb,IAJ3BlE,KAAKie,eAAekB,WAAWjb,KA9VrC,+BA6WkBA,GAAoC,IAAxB2V,EAAuB,wDAC7C7Z,KAAK8d,cACP9d,KAAK8d,aAAc,EAEdjE,IACE7Z,KAAK+d,WACL/d,KAAKie,eAAenQ,WADH9N,KAAKie,eAAevQ,KAAKxJ,SAlXvD,GAA8BuX,ICJxB2D,EAAsBC,IAAMC,YAChC,SAACC,EAAeC,GACd,IAAMC,EAAiBC,iBAAuB,MACxCC,EAAWD,iBAAsB,IACjCE,EAAWF,mBAHuC,EAK9BG,mBAAyB,IALK,mBAKjD1M,EALiD,KAK1C2M,EAL0C,KAUxDC,8BAAoBP,GAAK,kBAAMI,EAASzS,WAExC,IAAM6S,EAAsBC,uBAAY,WAClCL,EAASzS,SACXyS,EAASzS,QAAQ2J,UAElB,IAEGuD,EAAiB4F,uBAAY,WACjC,IAAMvS,EAAOkS,EAASzS,QAElBO,IACFA,EAAKwS,IAAI,QACTxS,EAAKwS,IAAI,qBACTxS,EAAKwS,IAAI,eACTxS,EAAKwS,IAAI,QACTxS,EAAKwS,IAAI,aAEV,IAwEH,OAtEAC,qBAAU,WAGR,GAFAR,EAASxS,QAAU,GAEfoS,EAAMa,SAAU,CAClB,IAAMC,EAAYhB,IAAMiB,SAASC,IAAIhB,EAAMa,UAAU,SAACI,GACpD,OAAOnB,IAAMoB,aAAaD,EAAuB,CAC/ChB,IAAK,SAACkB,GACAA,GACFf,EAASxS,QAAQ3G,KAAKka,SAMzBnB,EAAMoB,4BAA8BxN,EAAM9M,SAAWga,EAAUha,SAC9Dga,EAAUha,OAAS8M,EAAM9M,QAC3B2Z,IAGFF,EAASO,OAIZ,CAACd,EAAMa,WAEVD,qBAAU,WA2BJhN,EAAM9M,OAAS,GAAKsZ,EAASxS,QAAQ9G,OAAS,IAChDgU,IAEIoF,EAAetS,UAAYyS,EAASzS,UACtCyS,EAASzS,QAAU,IAAIyQ,EAAS6B,EAAetS,QAASoS,IAGrDK,EAASzS,QAAQyT,oBAGpBhB,EAASzS,QAAQ0T,eAAelB,EAASxS,SAFzCyS,EAASzS,QAAQ2T,aAAanB,EAASxS,SAlCvB,WAClB,IAAMO,EAAOkS,EAASzS,QAElBO,IACE6R,EAAMwB,QACRrT,EAAKsT,GAAG,QAAQ,SAAC7Z,GAAD,OAAgBoY,EAAMwB,OAAO5Z,MAG3CoY,EAAM0B,qBACRvT,EAAKsT,GAAG,qBAAqB,SAAC7Z,GAAD,OAAgBoY,EAAM0B,oBAAoB9Z,MAGrEoY,EAAM2B,eACRxT,EAAKsT,GAAG,eAAe,SAAC7Z,GAAD,OAAgBoY,EAAM2B,cAAc/Z,MAGzDoY,EAAM4B,QACRzT,EAAKsT,GAAG,QAAQ,SAAC7Z,GAAD,OAAgBoY,EAAM4B,OAAOha,MAG3CoY,EAAM6B,UACR1T,EAAKsT,GAAG,UAAU,SAAC7Z,GAAD,OAAgBoY,EAAM6B,SAASja,OAkBrD8T,MAGD,CAAC9H,IAGF,qBAAKqM,IAAKC,EAAgB4B,UAAW9B,EAAM8B,UAAW/L,MAAOiK,EAAMjK,MAAnE,SACGnC,OCxHMmO,ED8HajC,IAAMkC,KAAKnC,GE7HjC3f,G,YAAO4f,IAAMC,YAAW,SAACC,EAAOC,GACpC,OAAQD,EAAMiC,MACZ,IAAK,OACH,OAAO,qBAAKH,UAAU,OAAO7B,IAAKA,EAAKiC,eAAa,OAA7C,SACL,sBAAKJ,UAAU,eAAf,iBAEE,qBAAKA,UAAU,cAAf,SAA8BK,MAAMnC,EAAMoC,YAAc,GAAKpC,EAAMoC,kBAGzE,IAAK,QACH,OACE,qBACEN,UAAW,8BAAgC9B,EAAMrb,IACjDsb,IAAKA,EACLiC,eAAa,OAHf,SAgBE,qBAAKJ,UAAU,eAAf,SACE,6BAAK9B,EAAMqC,gBAKnB,IAAK,OACH,OAAO,qBAAKP,UAAW,SAAW9B,EAAMsC,aAAe,eAAiB,IAAKrC,IAAKA,EAAKiC,eAAa,OAA7F,SACL,sBAAKJ,UAAU,eAAf,eACwBS,IAApBvC,EAAMqC,UACN,oBAAIP,UAAU,cAAd,SAA6B9B,EAAMqC,YAAkB,KAEvD,sBAAKP,UAAU,YAAf,UAC4B,OAAxB9B,EAAMwC,QAAQphB,OAA0C,KAAxB4e,EAAMwC,QAAQphB,MAC9C,qBAAK2U,MAAO,CAAE0M,OAAQ,KAAMC,MAAO,QAAUlhB,IAAKmhB,cAA+B3C,EAAMwC,QAAQphB,MAAOwD,MAAM,MAAMge,IAAI,KAAY,KAEpI,qBAAKC,wBAAyB,CAAEC,OAAQ9C,EAAMwC,QAAQO,KAAKC,gBAE7D,qBAAKlB,UAAU,cAAf,SAA8BK,MAAMnC,EAAMoC,YAAc,GAAKpC,EAAMoC,kBAIzE,IAAK,WACL,IAAK,UACL,IAAK,QACH,OACE,qBAAKN,UAAW,SAAW9B,EAAMsC,aAAe,eAAiB,IAAKrC,IAAKA,EAAKiC,eAAa,OAA7F,SACE,sBAAKJ,UAAU,eAAf,UACE,qCACwBS,IAApBvC,EAAMqC,UACN,oBAAIP,UAAU,cAAd,SAA6B9B,EAAMqC,YAAkB,UAErCE,IAAhBvC,EAAM5e,MACN,qBAAK0gB,UAAU,aAAf,SACE,mCACE,qBACEc,IAAK5C,EAAMiD,aACXzhB,IAAKwe,EAAM5e,MACX8hB,QAwBpB,SAAuBtb,GACrBub,QAAQC,IAAI,QAASpD,GACrBmD,QAAQC,IAAI,MAAOnD,GACnBrY,EAAEoR,OAAOqK,oBAAoBC,MAAK,gBA1BhBC,OAmBpB,SAAuB3b,GACrBA,EAAEoR,OAAOjD,MAASnO,EAAEoR,OAAOpU,MAAQgD,EAAEoR,OAAOhX,OAAU,cAAgB,kBAlBtD,qCAAage,EAAMiD,oBAGrB,QAGJjD,EAAMa,SAAY,qBAAKiB,UAAU,YAAf,SAA4B9B,EAAMa,WAAkB,KACxE,qBAAKiB,UAAU,cAAf,SAA8BK,MAAMnC,EAAMoC,YAAc,GAAKpC,EAAMoC,kBAK3E,QACE,MAAM,IAAIlc,MAAM,4CCAPsd,EA5Eb,WAAYC,GAAU,IAAD,gCANrBC,OAAS,GAMY,KAJrB1E,KAAO,KAIc,KAFrB2E,KAAO,IAEc,KAOrBlO,IAAM,SAACmO,EAAMC,GAEX,OADA,EAAKH,OAAOzc,KAAK,CAAE2c,OAAMC,OAClB,GATY,KAYrB/N,OAAS,SAAA8N,GACP,IAAK,IAAI5c,EAAI,EAAGA,EAAI,EAAK0c,OAAO5c,OAAQE,GAAK,EAC3C,GAAI,EAAK0c,OAAO1c,GAAG4c,OAASA,EAE1B,OADA,EAAKF,OAAO/M,MAAM3P,EAAG,GACd,EAGX,OAAO,GAnBY,KAsBrB8c,MAAQ,WAEN,OADA,EAAKJ,OAAS,GACP,GAxBY,KA2BrBK,aAAe,SAAAH,GAAI,OACjBA,EACGnX,WACAuX,QAAQ,MAAO,IACfA,QAAQ,MAAO,KA/BC,KAiCrBC,YAAc,WACZ,IAAIC,EAAW,GACf,GAAkB,YAAd,EAAKlF,KAEPkF,GADAA,EAAW,EAAKH,aAAaI,UAAUlS,OAAOmS,SAASC,SAAWpS,OAAOmS,SAASE,UAC9DN,QAAQ,UAAW,IACvCE,EAAyB,MAAd,EAAKP,KAAeO,EAASF,QAAQ,EAAKL,KAAM,IAAMO,MAC5D,CACL,IAAMK,EAAQtS,OAAOmS,SAASjjB,KAAKojB,MAAM,UACzCL,EAAWK,EAAQA,EAAM,GAAK,GAEhC,OAAO,EAAKR,aAAaG,IA3CN,KA8CrBM,SAAW,WAAgB,IAAfZ,EAAc,uDAAP,GAMjB,MALkB,YAAd,EAAK5E,KACP/M,OAAOwS,QAAQC,UAAU,KAAM,KAAM,EAAKf,KAAO,EAAKI,aAAaH,IAEnE3R,OAAOmS,SAASjjB,KAAhB,UAA0B8Q,OAAOmS,SAASjjB,KAAK6iB,QAAQ,SAAU,IAAjE,YAAwEJ,GAEnE,GApDY,KAuDrBe,OAAS,WACPC,cAAc,EAAKC,UACnB,EAAKA,SAAWC,YAAY,EAAKD,SAAU,KAzDxB,KA4DrBA,SAAW,WACL,EAAKjX,UAAY,EAAKqW,gBAC1B,EAAKrW,QAAU,EAAKqW,cAEpB,EAAKP,OAAOqB,MAAK,SAAAC,GACf,IAAMT,EAAQ,EAAK3W,QAAQ2W,MAAMS,EAAMpB,MACvC,QAAIW,IACFA,EAAMU,QACND,EAAMnB,GAAGqB,MAAM,GAAIX,GACZA,QApEX9jB,KAAKue,KAAO/M,OAAOwS,QAAQC,UAAY,UAAY,OAC/CjB,EAAQzE,OAAMve,KAAKue,KAAOyE,EAAQzE,MAClCyE,EAAQE,OAAMljB,KAAKkjB,KAAOF,EAAQE,MACtCljB,KAAKkkB,UC4ZMQ,EAhaG,WAAO,IAAD,EACU7E,mBAAS,GADnB,mBACf8E,EADe,KACLC,EADK,OAGoB/E,mBAAS,IAH7B,mBAGfgF,EAHe,KAGAC,EAHA,OAIQjF,qBAJR,mBAIfkF,EAJe,KAINC,EAJM,OAKUnF,mBAAS,CACvCoF,SAAU,GACVC,eAAgB,EAChB/R,MAAO,KARa,mBAKfgS,EALe,KAKLC,EALK,OAWIvF,mBAAS,QAA5BwF,EAXe,sBAaExF,qBAbF,mBAaf3S,EAbe,KAaToY,EAbS,OAkBMzF,qBAlBN,mBAkBf0F,EAlBe,KAkBPC,EAlBO,KAmBhBC,EAAW/F,mBAEjBS,qBAAU,WA0ER,OAzEAuF,MAAMxD,wBAAwC,CAC5CyD,QAAS,CACP,eAAgB,mBAChB,OAAU,sBAEX9C,MAAK,SAAC+C,GACPA,EAAIC,OAAOhD,MAAK,SAAAiD,GAKd,IAAMC,EAAYC,EAAaF,GAE/BC,EAAU5S,MAAM4S,EAAUb,eAAiB,GAAK,cAAC,EAAD,CAC9C1D,KAAK,WAELG,WAAYoE,EAAUb,eAAiB,EACvCtD,UAAWmE,EAAU5S,MAAM4S,EAAUb,eAAiB,GAAG3F,MAAMqC,UAJjB,SAM9C,oBAAIP,UAAU,WAAd,SACG0E,EAAUd,SAAS1E,KAAI,SAAC0F,EAAS1f,GAAV,OACtB,6BAAY,mBAAG7F,MAA4B,SAApB2kB,EAA8B,KAAO,IAAMa,OAAOD,EAAQE,YAAa1D,QAAS2D,EAA3F,SAA4GH,EAAQI,UAAU1B,MAAjIpe,SANRwf,EAAUb,eAAiB,GAoBlC,IATA,IACMoB,EAAiBP,EAAU5S,MAAM+C,MAAM,EADX,GACyCqQ,OAAOR,EAAU5S,MAAM+C,MADhE,EACiG6P,EAAU5S,MAAM9M,QAAQka,KAAI,SAAArT,GAAI,OAAI,cAAC,EAAD,CAAMsU,KAAK,OAAmCG,WAAYzU,EAAKqS,MAAMoC,YAA9CzU,EAAKqS,MAAMoC,gBAGnM6E,EAAW,IAAI9L,MAJa,GAIoB+L,QAAO,SAACb,EAAK1Y,EAAM3G,GAEvE,OADAqf,EAAIrf,IAAK,EACFqf,IACN,IAEMrf,EAAI,EAAGA,EATkB,EASaA,IAC7CigB,EAASjgB,IAAK,EAGhBmc,QAAQC,IAAI,UAAW6D,GAEvB,IAAME,EAAU,IAAI3D,EAAO,CAAExE,KAAM8G,IAI/BsB,EAAQ,EACRC,EAAUF,EAAQlD,eACpBmD,EAAQE,OAAOH,EAAQlD,eAEvBkD,EAAQ3C,SAAS,MAInB,IAAI9R,EAAS6U,EAAoBR,EAAgBE,EAAUT,GAC3DjB,GAAiB,kBAAM7S,EAAO8U,wBAC9B/B,GAAW,kBAAM/S,EAAO+U,kBAIxB5B,EAAYW,GACZP,EAAUkB,GACVpB,EAAQqB,MAIP,SAAAM,GACDC,MAAM,2CACNxE,QAAQyE,MAAMF,SAEf,SAAAA,GACDC,MAAM,2CACNxE,QAAQyE,MAAMF,MAET,eAGN,CAACtC,IAEJxE,qBAAU,WAmBR,QAAyB2B,IAArB2D,EAAStY,SAAqC,OAAZ4X,GAAoBF,EAAcxe,QAAU6G,EAAM,CACtF,IAAI+E,EAAS6U,EAAoBjC,EAAeE,EAASI,GACzDL,GAAiB,kBAAM7S,EAAO8U,wBAC9B/B,GAAW,kBAAM/S,EAAO+U,kBAIxB5N,YAAW,WAnBPyL,EAAcxe,QAAU6G,GAE1BuY,EAAStY,QAAQO,KAAKmZ,OAAO3Z,SAEd4U,IAAXyD,GACFA,EAAOxB,SAAS,IAAM7W,IAGxBoY,EAAQ,KAaP,QAGJ,CAACpY,IAMJiT,qBAAU,WACRuC,QAAQC,IAAI,gBAAiBkC,KAC5B,CAACA,IAEJ1E,qBAAU,WACRuC,QAAQC,IAAI,WAAYwC,KACvB,CAACA,IAGJ,IAAM2B,EAAsB,SAACR,EAAgBE,EAAUT,GAGrD,IAFA,IAAMgB,EAAoB,YAAOT,GAC3BU,EAAc,eAAQR,GACnBjgB,EAAI2G,EAAO,EAAG3G,EAAI2G,EAAO,EAAG3G,IAC/BA,EAAI,GAAKA,EAAI+f,EAAejgB,OAAS,QACrByb,IAAhB0E,EAASjgB,KAEbwgB,EAAqBxgB,GAAKwf,EAAU5S,MAAM5M,GAC1CygB,EAAezgB,IAAK,GAGtB,MAAO,CAAEwgB,uBAAsBC,mBAGjC7G,qBAAU,WACRuC,QAAQC,IAAI,aAuBd,IAAMyE,EAAe,WACnB9B,EAAQuB,OAAOQ,aAAaC,QAAQ,eAShCtB,EAAe,SAACF,GACpB,OAAOA,EAAUW,QAAO,SAACb,EAAK1Y,EAAM5G,GAoBlC,GAnBkB,YAAd4G,EAAKsU,MAAoBoE,EAAIX,SAASze,KAAK,CAC7C6f,UAAWnZ,EAAKmZ,UAChBF,WAAYP,EAAI2B,YAEA,aAAdra,EAAKsU,OAEHoE,EAAI2B,UAAY,IAAM,IACxB3B,EAAIzS,MAAM3M,KAAK,cAAC,EAAD,CAAMgb,KAAK,OAA2BG,WAAYiE,EAAI2B,WAA/B3B,EAAI2B,YAC1C3B,EAAI2B,WAAa,GAEnB3B,EAAIV,eAAiBU,EAAI2B,UAAY,GAEnCjhB,EAAQ,IAAMwf,EAAUzf,QACtBuf,EAAI2B,UAAY,IAAM,IACxB3B,EAAIzS,MAAM3M,KAAK,cAAC,EAAD,CAAMgb,KAAK,OAA2BG,WAAYiE,EAAI2B,WAA/B3B,EAAI2B,YAC1C3B,EAAI2B,WAAa,GAIH,SAAdra,EAAKsU,KAAiB,CAExB,IAAMgG,EAAYC,EAAkBva,EAAK6U,QAAQ4C,GAAUrC,KAAM,IAAK,KACtDkF,EAAUjH,KAAI,SAAC5e,EAAG4E,GAChC,OAAO,cAAC,EAAD,CAELob,WAAYiE,EAAI2B,UAAYhhB,EAC5Bib,KAAMtU,EAAKsU,KACXI,UAAW1U,EAAKmZ,UAAU1B,GAC1B5C,QAAgB,IAANxb,EAAW,CAAE5F,MAAOuM,EAAK6U,QAAQ4C,GAAUhkB,MAAO2hB,KAAM3gB,GAAM,CAAEhB,MAAO,KAAM2hB,KAAM3gB,IAJxFikB,EAAI2B,UAAYhhB,MAOfmhB,SAAQ,SAAA/lB,GAAC,OAAIikB,EAAIzS,MAAM3M,KAAK7E,MACtCikB,EAAI2B,WAAaC,EAAUnhB,WAEtB,CACL,IAAIshB,EAAa,CACfC,IAAKhC,EAAI2B,UACT5F,WAAYiE,EAAI2B,UAChB/F,KAAMtU,EAAKsU,KACXI,UAAY1U,EAAKmZ,UAAanZ,EAAKmZ,UAAU1B,QAAY7C,GAErC,IAAlB8D,EAAI2B,YACNI,EAAWE,UAAW,EACtBF,EAAWG,WAAaV,EACxBO,EAAWzjB,IAAM,OAEf0hB,EAAI2B,YAAczB,EAAUzf,OAAS,IACvCshB,EAAWzjB,IAAM,UAEfgJ,EAAK6a,YACPJ,EAAWhnB,MAAQuhB,cAA+BhV,EAAK6a,UACvDJ,EAAWnF,aAAetV,EAAK8a,aAAarD,IAG9CiB,EAAIzS,MAAM3M,KACR,cAAC,EAAD,eACMmhB,KAGR/B,EAAI2B,WAAa,EAGnB,OAAO3B,IAEN,CACDX,SAAU,GACVsC,UAAW,EACXrC,eAAgB,EAChB/R,MAAO,MAILsU,EAAoB,SAAC1F,EAAS5d,EAAO5C,GACzC,IAAI0mB,EAAYC,SAASC,cAAc,OACvCF,EAAUG,GAAK,YACfH,EAAU3S,MAAMnR,MAAQA,EAAQ,KAChC8jB,EAAU3S,MAAM+S,WAAa,SAC7BJ,EAAU3S,MAAMgT,SAAW,OAC3BL,EAAU/M,UAAY6G,EACtB,IAAIwG,EAAM,GAEVL,SAASM,KAAKrT,YAAY8S,GAE1BA,EAAUQ,WAAWf,SAAQ,SAAAgB,GACL,IAAlBA,EAAKC,SACPJ,EAAI/hB,KAAKkiB,EAAKE,aAEdL,EAAI/hB,KAAKkiB,EAAKnG,cAGlB0F,EAAU/M,UAAY,GAEtB,IAAI/H,EAAQ,GACRS,EAAY,EAEhBT,EAAM,GAAK+U,SAASC,cAAc,WAElC,IAAK,IAAI5hB,EAAI,EAAGA,EAAIgiB,EAAIliB,OAAQE,IAC9B0hB,EAAU/M,WAAaqN,EAAIhiB,GACvB0hB,EAAUY,aAAetnB,IAE3B4R,EADAS,GAAa,GACMsU,SAASC,cAAc,WAC1CF,EAAU/M,UAAY,IAExB/H,EAAMS,GAAWsH,WAAaqN,EAAIhiB,GAIpC,OADA2hB,SAASM,KAAKM,YAAYb,GACnB9U,GAuBHiT,EAAiB,SAACjf,GACtBA,EAAEyR,iBAEF0M,EAAQuB,OAAO1f,EAAEoR,OAAOwQ,KAAKC,UAAU,GAAGC,MAAM,KAAK,MAIjDrC,EAAY,SAACsC,GACjB,MAAkB,iBAAPA,KACHxH,MAAMwH,KACXxH,MAAMyH,WAAWD,MAGtB,OACE,sBAAK7H,UAAU,qBAAf,UAEE,sBAAKA,UAAU,sBAAf,UACE,wBAAQA,UAAU,aAAaoB,QArCd,WACrBmC,GAAY,SAAAD,GAAQ,OAAkB,IAAbA,EAAkB,EAAI,MAoCayE,MACxC,IAAbzE,EAAkB,6BAA+B,8BADpD,SAGiB,IAAbA,EACA,+BAAM,sBAAM0E,MAAM,YAAY/T,MAAO,CAAEgU,gBAAiB,8BAGxD,+BAAM,sBAAMD,MAAM,YAAY/T,MAAO,CAAEgU,gBAAiB,gCAK5D,wBAAQjI,UAAU,aAAaoB,QA7CnB,WAChByE,MAAM,iBA4CF,0BAEF,qBAAK7F,UAAU,8BAAf,SAaIwD,EAAcxe,OAAS,EACvB,cAAC,EAAD,CACElC,MAAO,IACP5C,OAAQ,IACR6E,KAAK,UACLoJ,SAAU,IACVE,UAAW,IACXD,SAAU,IACVE,UAAW,KACXK,iBAAkB,GAClBjB,aAAc,IACdkB,WAAW,EACXC,qBAAqB,EACrBE,kBAAmB,CAAC,MAAO,SAAU,KACrCR,YAAY,EACZO,cAAe,EACfE,gBAAgB,EAChBC,iBAAiB,EAEjByQ,OAAQ,SAAC5Z,GAAD,OAAOme,GAAQ,WAErB,OAAOne,EAAEgV,SAGXkF,UAAU,aAEV7B,IAAKiG,EAzBP,SA2BGZ,IACe,WC5Yb0E,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqB5G,MAAK,YAAkD,IAA/C6G,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOF,GACPG,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAQN,OCAdO,IAASrqB,OACP,cAAC,IAAMsqB,WAAP,UAEE,cAAC,EAAD,MAEF9B,SAAS+B,eAAe,SAM1BV,M","file":"static/js/main.b3b35537.chunk.js","sourcesContent":["import { Render } from '../Render/Render';\nimport { Point } from '../BasicTypes';\n\n/**\n * State of the page on the basis of which rendering\n */\nexport interface PageState {\n  /** Page rotation angle */\n  angle: number;\n\n  /** Page scope */\n  area: Point[];\n\n  /** Page position */\n  position: Point;\n\n  /** Rotate angle for hard pages */\n  hardAngle: number;\n\n  /** Rotate angle for hard pages at renedering time */\n  hardDrawingAngle: number;\n}\n\nexport enum PageOrientation {\n  /** Left side page */\n  LEFT,\n\n  /** Right side page */\n  RIGHT,\n}\n\nexport enum PageDensity {\n  SOFT = 'soft',\n  HARD = 'hard',\n}\n\n/**\n * Class representing a book page\n */\nexport abstract class Page {\n  /** State of the page on the basis of which rendering */\n  protected state: PageState;\n  /** Render object */\n  protected render: Render;\n\n  /** Page Orientation */\n  protected orientation: PageOrientation;\n\n  /** Density at creation */\n  protected createdDensity: PageDensity;\n  /** Density at the time of rendering (Depends on neighboring pages) */\n  protected nowDrawingDensity: PageDensity;\n\n  protected constructor(render: Render, density: PageDensity) {\n    this.state = {\n      angle: 0,\n      area: [],\n      position: { x: 0, y: 0 },\n      hardAngle: 0,\n      hardDrawingAngle: 0,\n    };\n\n    this.createdDensity = density;\n    this.nowDrawingDensity = this.createdDensity;\n\n    this.render = render;\n  }\n\n  /**\n   * Render static page\n   * \n   * @param {PageOrientation} orient - Static page orientation\n   */\n  public abstract simpleDraw(orient: PageOrientation): void;\n\n  /**\n   * Render dynamic page, using state\n   * \n   * @param {PageDensity} tempDensity - Density at the time of rendering \n   */\n  public abstract draw(tempDensity?: PageDensity): void;\n\n  /**\n   * Page loading\n   */\n  public abstract load(): void;\n\n  /**\n   * Set a constant page density\n   * \n   * @param {PageDensity} density \n   */\n  public setDensity(density: PageDensity): void {\n    this.createdDensity = density;\n    this.nowDrawingDensity = density;\n  }\n\n  /**\n   * Set temp page density to next render\n   * \n   * @param {PageDensity}  density \n   */\n  public setDrawingDensity(density: PageDensity): void {\n    this.nowDrawingDensity = density;\n  }\n\n  /**\n   * Set page position\n   * \n   * @param {Point} pagePos \n   */\n  public setPosition(pagePos: Point): void {\n    this.state.position = pagePos;\n  }\n\n  /**\n   * Set page angle\n   * \n   * @param {number} angle \n   */\n  public setAngle(angle: number): void {\n    this.state.angle = angle;\n  }\n\n  /**\n   * Set page crop area\n   * \n   * @param {Point[]} area \n   */\n  public setArea(area: Point[]): void {\n    this.state.area = area;\n  }\n\n  /**\n   * Rotate angle for hard pages to next render\n   * \n   * @param {number} angle \n   */\n  public setHardDrawingAngle(angle: number): void {\n    this.state.hardDrawingAngle = angle;\n  }\n\n  /**\n   * Rotate angle for hard pages\n   * \n   * @param {number} angle \n   */\n  public setHardAngle(angle: number): void {\n    this.state.hardAngle = angle;\n    this.state.hardDrawingAngle = angle;\n  }\n\n  /**\n   * Set page orientation\n   * \n   * @param {PageOrientation} orientation \n   */\n  public setOrientation(orientation: PageOrientation): void {\n    this.orientation = orientation;\n  }\n\n  /**\n   * Get temp page density\n   */\n  public getDrawingDensity(): PageDensity {\n    return this.nowDrawingDensity;\n  }\n\n  /**\n   * Get a constant page density\n   */\n  public getDensity(): PageDensity {\n    return this.createdDensity;\n  }\n\n  /**\n   * Get rotate angle for hard pages\n   */\n  public getHardAngle(): number {\n    return this.state.hardAngle;\n  }\n\n  public abstract newTemporaryCopy(): Page;\n  public abstract getTemporaryCopy(): Page;\n  public abstract hideTemporaryCopy(): void;\n}\n","import { Orientation, Render } from '../Render/Render';\nimport { PageFlip } from '../PageFlip';\nimport { Helper } from '../Helper';\nimport { PageRect, Point } from '../BasicTypes';\nimport { FlipCalculation } from './FlipCalculation';\nimport { Page, PageDensity } from '../Page/Page';\n\n/**\n * Flipping direction\n */\nexport enum FlipDirection {\n  FORWARD,\n  BACK,\n}\n\n/**\n * Active corner when flipping\n */\nexport enum FlipCorner {\n  TOP = 'top',\n  BOTTOM = 'bottom',\n}\n\n/**\n * State of the book\n */\nexport enum FlippingState {\n  /** The user folding the page */\n  USER_FOLD = 'user_fold',\n\n  /** Mouse over active corners */\n  FOLD_CORNER = 'fold_corner',\n\n  /** During flipping animation */\n  FLIPPING = 'flipping',\n\n  /** Base state */\n  READ = 'read',\n}\n\n/**\n * Class representing the flipping process\n */\nexport class Flip {\n  private readonly render: Render;\n  private readonly app: PageFlip;\n\n  private flippingPage: Page = null;\n  private bottomPage: Page = null;\n\n  private calc: FlipCalculation = null;\n\n  private state: FlippingState = FlippingState.READ;\n\n  constructor(render: Render, app: PageFlip) {\n    this.render = render;\n    this.app = app;\n  }\n\n  /**\n   * Called when the page folding (User drags page corner)\n   *\n   * @param globalPos - Touch Point Coordinates (relative window)\n   */\n  public fold(globalPos: Point): void {\n    this.setState(FlippingState.USER_FOLD);\n\n    // If the process has not started yet\n    if (this.calc === null) this.start(globalPos);\n\n    this.do(this.render.convertToPage(globalPos));\n  }\n\n  /**\n   * Page turning with animation\n   *\n   * @param globalPos - Touch Point Coordinates (relative window)\n   */\n  public flip(globalPos: Point): void {\n    if (this.app.getSettings().disableFlipByClick && !this.isPointOnCorners(globalPos)) return;\n\n    // the flipiing process is already running\n    if (this.calc !== null) this.render.finishAnimation();\n\n    if (!this.start(globalPos)) return;\n\n    const rect = this.getBoundsRect();\n\n    this.setState(FlippingState.FLIPPING);\n\n    // Margin from top to start flipping\n    const topMargins = rect.height / 10;\n\n    // Defining animation start points\n    const yStart =\n      this.calc.getCorner() === FlipCorner.BOTTOM ? rect.height - topMargins : topMargins;\n\n    const yDest = this.calc.getCorner() === FlipCorner.BOTTOM ? rect.height : 0;\n\n    // Сalculations for these points\n    this.calc.calc({ x: rect.pageWidth - topMargins, y: yStart });\n\n    // Run flipping animation\n    this.animateFlippingTo(\n      { x: rect.pageWidth - topMargins, y: yStart },\n      { x: -rect.pageWidth, y: yDest },\n      true\n    );\n  }\n\n  /**\n   * Start the flipping process. Find direction and corner of flipping. Creating an object for calculation.\n   *\n   * @param {Point} globalPos - Touch Point Coordinates (relative window)\n   *\n   * @returns {boolean} True if flipping is possible, false otherwise\n   */\n  public start(globalPos: Point): boolean {\n    this.reset();\n\n    const bookPos = this.render.convertToBook(globalPos);\n    const rect = this.getBoundsRect();\n\n    // Find the direction of flipping\n    const direction = this.getDirectionByPoint(bookPos);\n\n    // Find the active corner\n    const flipCorner = bookPos.y >= rect.height / 2 ? FlipCorner.BOTTOM : FlipCorner.TOP;\n\n    if (!this.checkDirection(direction)) return false;\n\n    try {\n      this.flippingPage = this.app.getPageCollection().getFlippingPage(direction);\n      this.bottomPage = this.app.getPageCollection().getBottomPage(direction);\n\n      // In landscape mode, needed to set the density  of the next page to the same as that of the flipped\n      if (this.render.getOrientation() === Orientation.LANDSCAPE) {\n        if (direction === FlipDirection.BACK) {\n          const nextPage = this.app.getPageCollection().nextBy(this.flippingPage);\n\n          if (nextPage !== null) {\n            if (this.flippingPage.getDensity() !== nextPage.getDensity()) {\n              this.flippingPage.setDrawingDensity(PageDensity.HARD);\n              nextPage.setDrawingDensity(PageDensity.HARD);\n            }\n          }\n        } else {\n          const prevPage = this.app.getPageCollection().prevBy(this.flippingPage);\n\n          if (prevPage !== null) {\n            if (this.flippingPage.getDensity() !== prevPage.getDensity()) {\n              this.flippingPage.setDrawingDensity(PageDensity.HARD);\n              prevPage.setDrawingDensity(PageDensity.HARD);\n            }\n          }\n        }\n      }\n\n      this.render.setDirection(direction);\n      this.calc = new FlipCalculation(\n        direction,\n        flipCorner,\n        rect.pageWidth.toString(10), // fix bug with type casting\n        rect.height.toString(10) // fix bug with type casting\n      );\n\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * Perform calculations for the current page position. Pass data to render object\n   *\n   * @param {Point} pagePos - Touch Point Coordinates (relative active page)\n   */\n  private do(pagePos: Point): void {\n    if (this.calc === null) return; // Flipping process not started\n\n    if (this.calc.calc(pagePos)) {\n      // Perform calculations for a specific position\n      const progress = this.calc.getFlippingProgress();\n\n      this.bottomPage.setArea(this.calc.getBottomClipArea());\n      this.bottomPage.setPosition(this.calc.getBottomPagePosition());\n      this.bottomPage.setAngle(0);\n      this.bottomPage.setHardAngle(0);\n\n      this.flippingPage.setArea(this.calc.getFlippingClipArea());\n      this.flippingPage.setPosition(this.calc.getActiveCorner());\n      this.flippingPage.setAngle(this.calc.getAngle());\n\n      if (this.calc.getDirection() === FlipDirection.FORWARD) {\n        this.flippingPage.setHardAngle((90 * (200 - progress * 2)) / 100);\n      } else {\n        this.flippingPage.setHardAngle((-90 * (200 - progress * 2)) / 100);\n      }\n\n      this.render.setPageRect(this.calc.getRect());\n\n      this.render.setBottomPage(this.bottomPage);\n      this.render.setFlippingPage(this.flippingPage);\n\n      this.render.setShadowData(\n        this.calc.getShadowStartPoint(),\n        this.calc.getShadowAngle(),\n        progress,\n        this.calc.getDirection()\n      );\n    }\n  }\n\n  /**\n   * Turn to the specified page number (with animation)\n   *\n   * @param {number} page - New page number\n   * @param {FlipCorner} corner - Active page corner when turning\n   */\n  public flipToPage(page: number, corner: FlipCorner): void {\n    const current = this.app.getPageCollection().getCurrentSpreadIndex();\n    const next = this.app.getPageCollection().getSpreadIndexByPage(page);\n\n    try {\n      if (next > current) {\n        this.app.getPageCollection().setCurrentSpreadIndex(next - 1);\n        this.flipNext(corner);\n      }\n      if (next < current) {\n        this.app.getPageCollection().setCurrentSpreadIndex(next + 1);\n        this.flipPrev(corner);\n      }\n    } catch (e) {\n      //\n    }\n  }\n\n  /**\n   * Turn to the next page (with animation)\n   *\n   * @param {FlipCorner} corner - Active page corner when turning\n   */\n  public flipNext(corner: FlipCorner): void {\n    this.flip({\n      x: this.render.getRect().left + this.render.getRect().pageWidth * 2 - 10,\n      y: corner === FlipCorner.TOP ? 1 : this.render.getRect().height - 2,\n    });\n  }\n\n  /**\n   * Turn to the prev page (with animation)\n   *\n   * @param {FlipCorner} corner - Active page corner when turning\n   */\n  public flipPrev(corner: FlipCorner): void {\n    this.flip({\n      x: 10,\n      y: corner === FlipCorner.TOP ? 1 : this.render.getRect().height - 2,\n    });\n  }\n\n  /**\n   * Called when the user has stopped flipping\n   */\n  public stopMove(): void {\n    if (this.calc === null) return;\n\n    const pos = this.calc.getPosition();\n    const rect = this.getBoundsRect();\n\n    const y = this.calc.getCorner() === FlipCorner.BOTTOM ? rect.height : 0;\n\n    if (pos.x <= 0) this.animateFlippingTo(pos, { x: -rect.pageWidth, y }, true);\n    else this.animateFlippingTo(pos, { x: rect.pageWidth, y }, false);\n  }\n\n  /**\n   * Fold the corners of the book when the mouse pointer is over them.\n   * Called when the mouse pointer is over the book without clicking\n   *\n   * @param globalPos\n   */\n  public showCorner(globalPos: Point): void {\n    if (!this.checkState(FlippingState.READ, FlippingState.FOLD_CORNER)) return;\n\n    const rect = this.getBoundsRect();\n    const pageWidth = rect.pageWidth;\n\n    if (this.isPointOnCorners(globalPos)) {\n      if (this.calc === null) {\n        if (!this.start(globalPos)) return;\n\n        this.setState(FlippingState.FOLD_CORNER);\n\n        this.calc.calc({ x: pageWidth - 1, y: 1 });\n\n        const fixedCornerSize = 50;\n        const yStart = this.calc.getCorner() === FlipCorner.BOTTOM ? rect.height - 1 : 1;\n\n        const yDest =\n          this.calc.getCorner() === FlipCorner.BOTTOM\n            ? rect.height - fixedCornerSize\n            : fixedCornerSize;\n\n        this.animateFlippingTo(\n          { x: pageWidth - 1, y: yStart },\n          { x: pageWidth - fixedCornerSize, y: yDest },\n          false,\n          false\n        );\n      } else {\n        this.do(this.render.convertToPage(globalPos));\n      }\n    } else {\n      this.setState(FlippingState.READ);\n      this.render.finishAnimation();\n\n      this.stopMove();\n    }\n  }\n\n  /**\n   * Starting the flipping animation process\n   *\n   * @param {Point} start - animation start point\n   * @param {Point} dest - animation end point\n   * @param {boolean} isTurned - will the page turn over, or just bring it back\n   * @param {boolean} needReset - reset the flipping process at the end of the animation\n   */\n  private animateFlippingTo(\n    start: Point,\n    dest: Point,\n    isTurned: boolean,\n    needReset = true\n  ): void {\n    const points = Helper.GetCordsFromTwoPoint(start, dest);\n\n    // Create frames\n    const frames = [];\n    for (const p of points) frames.push(() => this.do(p));\n\n    const duration = this.getAnimationDuration(points.length);\n\n    this.render.startAnimation(frames, duration, () => {\n      // callback function\n      if (!this.calc) return;\n\n      if (isTurned) {\n        if (this.calc.getDirection() === FlipDirection.BACK) this.app.turnToPrevPage();\n        else this.app.turnToNextPage();\n      }\n\n      if (needReset) {\n        this.render.setBottomPage(null);\n        this.render.setFlippingPage(null);\n        this.render.clearShadow();\n\n        this.setState(FlippingState.READ);\n        this.reset();\n      }\n    });\n  }\n\n  /**\n   * Get the current calculations object\n   */\n  public getCalculation(): FlipCalculation {\n    return this.calc;\n  }\n\n  /**\n   * Get current flipping state\n   */\n  public getState(): FlippingState {\n    return this.state;\n  }\n\n  private setState(newState: FlippingState): void {\n    if (this.state !== newState) {\n      this.app.updateState(newState);\n      this.state = newState;\n    }\n  }\n\n  private getDirectionByPoint(touchPos: Point): FlipDirection {\n    const rect = this.getBoundsRect();\n\n    if (this.render.getOrientation() === Orientation.PORTRAIT) {\n      if (touchPos.x - rect.pageWidth <= rect.width / 5) {\n        return FlipDirection.BACK;\n      }\n    } else if (touchPos.x < rect.width / 2) {\n      return FlipDirection.BACK;\n    }\n\n    return FlipDirection.FORWARD;\n  }\n\n  private getAnimationDuration(size: number): number {\n    const defaultTime = this.app.getSettings().flippingTime;\n\n    if (size >= 1000) return defaultTime;\n\n    return (size / 1000) * defaultTime;\n  }\n\n  private checkDirection(direction: FlipDirection): boolean {\n    if (direction === FlipDirection.FORWARD)\n      return this.app.getCurrentPageIndex() < this.app.getPageCount() - 1;\n\n    return this.app.getCurrentPageIndex() >= 1;\n  }\n\n  private reset(): void {\n    this.calc = null;\n    this.flippingPage = null;\n    this.bottomPage = null;\n  }\n\n  private getBoundsRect(): PageRect {\n    return this.render.getRect();\n  }\n\n  private checkState(...states: FlippingState[]): boolean {\n    for (const state of states) {\n      if (this.state === state) return true;\n    }\n\n    return false;\n  }\n\n  private isPointOnCorners(globalPos: Point): boolean {\n    const rect = this.getBoundsRect();\n    const pageWidth = rect.pageWidth;\n\n    const operatingDistance = Math.sqrt(Math.pow(pageWidth, 2) + Math.pow(rect.height, 2)) / 5;\n\n    const bookPos = this.render.convertToBook(globalPos);\n\n    return (\n      bookPos.x > 0 &&\n      bookPos.y > 0 &&\n      bookPos.x < rect.width &&\n      bookPos.y < rect.height &&\n      (bookPos.x < operatingDistance || bookPos.x > rect.width - operatingDistance) &&\n      (bookPos.y < operatingDistance || bookPos.y > rect.height - operatingDistance)\n    );\n  }\n}\n","import { CanvasRender } from '../Render/CanvasRender';\nimport { Page, PageDensity, PageOrientation } from './Page';\nimport { Render } from '../Render/Render';\nimport { Point } from '../BasicTypes';\n\n/**\n * Class representing a book page as an image on Canvas\n */\nexport class ImagePage extends Page {\n    private readonly image: HTMLImageElement = null;\n    private isLoad = false;\n\n    private loadingAngle = 0;\n\n    constructor(render: Render, href: string, density: PageDensity) {\n        super(render, density);\n\n        this.image = new Image();\n        this.image.src = href;\n    }\n\n    public draw(tempDensity?: PageDensity): void {\n        const ctx = (this.render as CanvasRender).getContext();\n\n        const pagePos = this.render.convertToGlobal(this.state.position);\n        const pageWidth = this.render.getRect().pageWidth;\n        const pageHeight = this.render.getRect().height;\n\n        ctx.save();\n        ctx.translate(pagePos.x, pagePos.y);\n        ctx.beginPath();\n\n        for (let p of this.state.area) {\n            if (p !== null) {\n                p = this.render.convertToGlobal(p);\n                ctx.lineTo(p.x - pagePos.x, p.y - pagePos.y);\n            }\n        }\n\n        ctx.rotate(this.state.angle);\n\n        ctx.clip();\n\n        if (!this.isLoad) {\n            this.drawLoader(ctx, { x: 0, y: 0 }, pageWidth, pageHeight);\n        } else {\n            ctx.drawImage(this.image, 0, 0, pageWidth, pageHeight);\n        }\n\n        ctx.restore();\n    }\n\n    public simpleDraw(orient: PageOrientation): void {\n        const rect = this.render.getRect();\n        const ctx = (this.render as CanvasRender).getContext();\n\n        const pageWidth = rect.pageWidth;\n        const pageHeight = rect.height;\n\n        const x = orient === PageOrientation.RIGHT ? rect.left + rect.pageWidth : rect.left;\n\n        const y = rect.top;\n\n        if (!this.isLoad) {\n            this.drawLoader(ctx, { x, y }, pageWidth, pageHeight);\n        } else {\n            ctx.drawImage(this.image, x, y, pageWidth, pageHeight);\n        }\n    }\n\n    private drawLoader(\n        ctx: CanvasRenderingContext2D,\n        shiftPos: Point,\n        pageWidth: number,\n        pageHeight: number\n    ): void {\n        ctx.beginPath();\n        ctx.strokeStyle = 'rgb(200, 200, 200)';\n        ctx.fillStyle = 'rgb(255, 255, 255)';\n        ctx.lineWidth = 1;\n        ctx.rect(shiftPos.x + 1, shiftPos.y + 1, pageWidth - 1, pageHeight - 1);\n        ctx.stroke();\n        ctx.fill();\n\n        const middlePoint: Point = {\n            x: shiftPos.x + pageWidth / 2,\n            y: shiftPos.y + pageHeight / 2,\n        };\n\n        ctx.beginPath();\n        ctx.lineWidth = 10;\n        ctx.arc(\n            middlePoint.x,\n            middlePoint.y,\n            20,\n            this.loadingAngle,\n            (3 * Math.PI) / 2 + this.loadingAngle\n        );\n        ctx.stroke();\n        ctx.closePath();\n\n        this.loadingAngle += 0.07;\n        if (this.loadingAngle >= 2 * Math.PI) {\n            this.loadingAngle = 0;\n        }\n    }\n\n    public load(): void {\n        if (!this.isLoad)\n            this.image.onload = (): void => {\n                this.isLoad = true;\n            };\n    }\n\n    public newTemporaryCopy(): Page {\n        return this;\n    }\n\n    public getTemporaryCopy(): Page {\n        return this;\n    }\n\n    public hideTemporaryCopy(): void {\n        return;\n    }\n}\n","import { Point, Rect, Segment } from './BasicTypes';\n\n/**\n * A class containing helping mathematical methods\n */\nexport class Helper {\n    /**\n     * Get the distance between two points\n     *\n     * @param {Point} point1\n     * @param {Point} point2\n     */\n    public static GetDistanceBetweenTwoPoint(point1: Point, point2: Point): number {\n        if (point1 === null || point2 === null) {\n            return Infinity;\n        }\n\n        return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));\n    }\n\n    /**\n     * Get the length of the line segment\n     *\n     * @param {Segment} segment\n     */\n    public static GetSegmentLength(segment: Segment): number {\n        return Helper.GetDistanceBetweenTwoPoint(segment[0], segment[1]);\n    }\n\n    /**\n     * Get the angle between two lines\n     *\n     * @param {Segment} line1\n     * @param {Segment} line2\n     */\n    public static GetAngleBetweenTwoLine(line1: Segment, line2: Segment): number {\n        const A1 = line1[0].y - line1[1].y;\n        const A2 = line2[0].y - line2[1].y;\n\n        const B1 = line1[1].x - line1[0].x;\n        const B2 = line2[1].x - line2[0].x;\n\n        return Math.acos((A1 * A2 + B1 * B2) / (Math.sqrt(A1 * A1 + B1 * B1) * Math.sqrt(A2 * A2 + B2 * B2)));\n    }\n\n    /**\n     * Check for a point in a rectangle\n     *\n     * @param {Rect} rect\n     * @param {Point} pos\n     *\n     * @returns {Point} If the point enters the rectangle its coordinates will be returned, otherwise - null\n     */\n    public static PointInRect(rect: Rect, pos: Point): Point {\n        if (pos === null) {\n            return null;\n        }\n\n        if (\n            pos.x >= rect.left &&\n            pos.x <= rect.width + rect.left &&\n            pos.y >= rect.top &&\n            pos.y <= rect.top + rect.height\n        ) {\n            return pos;\n        }\n        return null;\n    }\n\n    /**\n     * Transform point coordinates to a given angle\n     *\n     * @param {Point} transformedPoint - Point to rotate\n     * @param {Point} startPoint - Transformation reference point\n     * @param {number} angle - Rotation angle (in radians)\n     *\n     * @returns {Point} Point coordinates after rotation\n     */\n    public static GetRotatedPoint(transformedPoint: Point, startPoint: Point, angle: number): Point {\n        return {\n            x: transformedPoint.x * Math.cos(angle) + transformedPoint.y * Math.sin(angle) + startPoint.x,\n            y: transformedPoint.y * Math.cos(angle) - transformedPoint.x * Math.sin(angle) + startPoint.y,\n        };\n    }\n\n    /**\n     * Limit a point \"linePoint\" to a given circle centered at point \"startPoint\" and a given radius\n     *\n     * @param {Point} startPoint - Circle center\n     * @param {number} radius - Circle radius\n     * @param {Point} limitedPoint - Сhecked point\n     *\n     * @returns {Point} If \"linePoint\" enters the circle, then its coordinates are returned.\n     * Else will be returned the intersection point between the line ([startPoint, linePoint]) and the circle\n     */\n    public static LimitPointToCircle(startPoint: Point, radius: number, limitedPoint: Point): Point {\n        // If \"linePoint\" enters the circle, do nothing\n        if (Helper.GetDistanceBetweenTwoPoint(startPoint, limitedPoint) <= radius) {\n            return limitedPoint;\n        }\n\n        const a = startPoint.x;\n        const b = startPoint.y;\n        const n = limitedPoint.x;\n        const m = limitedPoint.y;\n\n        // Find the intersection between the line at two points: (startPoint and limitedPoint) and the circle.\n        let x = Math.sqrt((Math.pow(radius, 2) * Math.pow(a - n, 2)) / (Math.pow(a - n, 2) + Math.pow(b - m, 2))) + a;\n        if (limitedPoint.x < 0) {\n            x *= -1;\n        }\n\n        let y = ((x - a) * (b - m)) / (a - n) + b;\n        if (a - n + b === 0) {\n            y = radius;\n        }\n\n        return { x, y };\n    }\n\n    /**\n     * Find the intersection of two lines bounded by a rectangle \"rectBorder\"\n     *\n     * @param {Rect} rectBorder\n     * @param {Segment} one\n     * @param {Segment} two\n     *\n     * @returns {Point} The intersection point, or \"null\" if it does not exist, or it lies outside the rectangle \"rectBorder\"\n     */\n    public static GetIntersectBetweenTwoSegment(rectBorder: Rect, one: Segment, two: Segment): Point {\n        return Helper.PointInRect(rectBorder, Helper.GetIntersectBeetwenTwoLine(one, two));\n    }\n\n    /**\n     * Find the intersection point of two lines\n     *\n     * @param one\n     * @param two\n     *\n     * @returns {Point} The intersection point, or \"null\" if it does not exist\n     * @throws Error if the segments are on the same line\n     */\n    public static GetIntersectBeetwenTwoLine(one: Segment, two: Segment): Point {\n        const A1 = one[0].y - one[1].y;\n        const A2 = two[0].y - two[1].y;\n\n        const B1 = one[1].x - one[0].x;\n        const B2 = two[1].x - two[0].x;\n\n        const C1 = one[0].x * one[1].y - one[1].x * one[0].y;\n        const C2 = two[0].x * two[1].y - two[1].x * two[0].y;\n\n        const det1 = A1 * C2 - A2 * C1;\n        const det2 = B1 * C2 - B2 * C1;\n\n        const x = -((C1 * B2 - C2 * B1) / (A1 * B2 - A2 * B1));\n        const y = -((A1 * C2 - A2 * C1) / (A1 * B2 - A2 * B1));\n\n        if (isFinite(x) && isFinite(y)) {\n            return { x, y };\n        } else {\n            if (Math.abs(det1 - det2) < 0.1) throw new Error('Segment included');\n        }\n\n        return null;\n    }\n\n    /**\n     * Get a list of coordinates (step: 1px) between two points\n     *\n     * @param pointOne\n     * @param pointTwo\n     *\n     * @returns {Point[]}\n     */\n    public static GetCordsFromTwoPoint(pointOne: Point, pointTwo: Point): Point[] {\n        const sizeX = Math.abs(pointOne.x - pointTwo.x);\n        const sizeY = Math.abs(pointOne.y - pointTwo.y);\n\n        const lengthLine = Math.max(sizeX, sizeY);\n\n        const result: Point[] = [pointOne];\n\n        function getCord(c1: number, c2: number, size: number, length: number, index: number): number {\n            if (c2 > c1) {\n                return c1 + index * (size / length);\n            } else if (c2 < c1) {\n                return c1 - index * (size / length);\n            }\n\n            return c1;\n        }\n\n        for (let i = 1; i <= lengthLine; i += 1) {\n            result.push({\n                x: getCord(pointOne.x, pointTwo.x, sizeX, lengthLine, i),\n                y: getCord(pointOne.y, pointTwo.y, sizeY, lengthLine, i),\n            });\n        }\n\n        return result;\n    }\n}\n","import { Helper } from '../Helper';\nimport { Point, Rect, RectPoints, Segment } from '../BasicTypes';\nimport { FlipCorner, FlipDirection } from './Flip';\n\n/**\n * Class representing mathematical methods for calculating page position (rotation angle, clip area ...)\n */\nexport class FlipCalculation {\n  /** Calculated rotation angle to flipping page */\n  private angle: number;\n  /** Calculated position to flipping page */\n  private position: Point;\n\n  private rect: RectPoints;\n\n  /** The point of intersection of the page with the borders of the book */\n  private topIntersectPoint: Point = null; // With top border\n  private sideIntersectPoint: Point = null; // With side border\n  private bottomIntersectPoint: Point = null; // With bottom border\n\n  private readonly pageWidth: number;\n  private readonly pageHeight: number;\n\n  /**\n   * @constructor\n   *\n   * @param {FlipDirection} direction - Flipping direction\n   * @param {FlipCorner} corner - Flipping corner\n   * @param pageWidth - Current page width\n   * @param pageHeight - Current page height\n   */\n  constructor(\n    private direction: FlipDirection,\n    private corner: FlipCorner,\n\n    pageWidth: string,\n    pageHeight: string\n  ) {\n    this.pageWidth = parseInt(pageWidth, 10);\n    this.pageHeight = parseInt(pageHeight, 10);\n  }\n\n  /**\n   * The main calculation method\n   * \n   * @param {Point} localPos - Touch Point Coordinates (relative active page!)\n   * \n   * @returns {boolean} True - if the calculations were successful, false if errors occurred\n   */\n  public calc(localPos: Point): boolean {\n    try {\n      // Find: page rotation angle and active corner position\n      this.position = this.calcAngleAndPosition(localPos);\n      // Find the intersection points of the scrolling page and the book\n      this.calculateIntersectPoint(this.position);\n\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * Get the crop area for the flipping page\n   * \n   * @returns {Point[]} Polygon page\n   */\n  public getFlippingClipArea(): Point[] {\n    const result = [];\n    let clipBottom = false;\n\n    result.push(this.rect.topLeft);\n    result.push(this.topIntersectPoint);\n\n    if (this.sideIntersectPoint === null) {\n      clipBottom = true;\n    } else {\n      result.push(this.sideIntersectPoint);\n\n      if (this.bottomIntersectPoint === null) clipBottom = false;\n    }\n\n    result.push(this.bottomIntersectPoint);\n\n    if (clipBottom || this.corner === FlipCorner.BOTTOM) {\n      result.push(this.rect.bottomLeft);\n    }\n\n    return result;\n  }\n\n  /**\n   * Get the crop area for the page that is below the page to be flipped\n   * \n   * @returns {Point[]} Polygon page\n   */\n  public getBottomClipArea(): Point[] {\n    const result = [];\n\n    result.push(this.topIntersectPoint);\n\n    if (this.corner === FlipCorner.TOP) {\n      result.push({ x: this.pageWidth, y: 0 });\n    } else {\n      if (this.topIntersectPoint !== null) {\n        result.push({ x: this.pageWidth, y: 0 });\n      }\n      result.push({ x: this.pageWidth, y: this.pageHeight });\n    }\n\n    if (this.sideIntersectPoint !== null) {\n      if (\n        Helper.GetDistanceBetweenTwoPoint(\n          this.sideIntersectPoint,\n          this.topIntersectPoint\n        ) >= 10\n      )\n        result.push(this.sideIntersectPoint);\n    } else {\n      if (this.corner === FlipCorner.TOP) {\n        result.push({ x: this.pageWidth, y: this.pageHeight });\n      }\n    }\n\n    result.push(this.bottomIntersectPoint);\n    result.push(this.topIntersectPoint);\n\n    return result;\n  }\n\n  /**\n   * Get page rotation angle\n   */\n  public getAngle(): number {\n    if (this.direction === FlipDirection.FORWARD) {\n      return -this.angle;\n    }\n\n    return this.angle;\n  }\n\n  /**\n   * Get page area while flipping\n   */\n  public getRect(): RectPoints {\n    return this.rect;\n  }\n\n  /**\n   * Get the position of the active angle when turning\n   */\n  public getPosition(): Point {\n    return this.position;\n  }\n\n  /**\n   * Get the active corner of the page (which pull)\n   */\n  public getActiveCorner(): Point {\n    if (this.direction === FlipDirection.FORWARD) {\n      return this.rect.topLeft;\n    }\n\n    return this.rect.topRight;\n  }\n\n  /**\n   * Get flipping direction\n   */\n  public getDirection(): FlipDirection {\n    return this.direction;\n  }\n\n  /**\n   * Get flipping progress (0-100)\n   */\n  public getFlippingProgress(): number {\n    return Math.abs(((this.position.x - this.pageWidth) / (2 * this.pageWidth)) * 100);\n  }\n\n  /**\n   * Get flipping corner position (top, bottom)\n   */\n  public getCorner(): FlipCorner {\n    return this.corner;\n  }\n\n  /**\n   * Get start position for the page that is below the page to be flipped\n   */\n  public getBottomPagePosition(): Point {\n    if (this.direction === FlipDirection.BACK) {\n      return { x: this.pageWidth, y: 0 };\n    }\n\n    return { x: 0, y: 0 };\n  }\n\n  /**\n   * Get the starting position of the shadow\n   */\n  public getShadowStartPoint(): Point {\n    if (this.corner === FlipCorner.TOP) {\n      return this.topIntersectPoint;\n    } else {\n      if (this.sideIntersectPoint !== null) return this.sideIntersectPoint;\n\n      return this.topIntersectPoint;\n    }\n  }\n\n  /**\n   * Get the rotate angle of the shadow\n   */\n  public getShadowAngle(): number {\n    const angle = Helper.GetAngleBetweenTwoLine(this.getSegmentToShadowLine(), [\n      { x: 0, y: 0 },\n      { x: this.pageWidth, y: 0 },\n    ]);\n\n    if (this.direction === FlipDirection.FORWARD) {\n      return angle;\n    }\n\n    return Math.PI - angle;\n  }\n\n  private calcAngleAndPosition(pos: Point): Point {\n    let result = pos;\n\n    this.updateAngleAndGeometry(result);\n\n    if (this.corner === FlipCorner.TOP) {\n      result = this.checkPositionAtCenterLine(\n        result,\n        { x: 0, y: 0 },\n        { x: 0, y: this.pageHeight }\n      );\n    } else {\n      result = this.checkPositionAtCenterLine(\n        result,\n        { x: 0, y: this.pageHeight },\n        { x: 0, y: 0 }\n      );\n    }\n\n    if (Math.abs(result.x - this.pageWidth) < 1 && Math.abs(result.y) < 1) {\n      throw new Error('Point is too small');\n    }\n\n    return result;\n  }\n\n  private updateAngleAndGeometry(pos: Point): void {\n    this.angle = this.calculateAngle(pos);\n    this.rect = this.getPageRect(pos);\n  }\n\n  private calculateAngle(pos: Point): number {\n    const left = this.pageWidth - pos.x + 1;\n    const top = this.corner === FlipCorner.BOTTOM ? this.pageHeight - pos.y : pos.y;\n\n    let angle = 2 * Math.acos(left / Math.sqrt(top * top + left * left));\n\n    if (top < 0) angle = -angle;\n\n    const da = Math.PI - angle;\n    if (!isFinite(angle) || (da >= 0 && da < 0.003))\n      throw new Error('The G point is too small');\n\n    if (this.corner === FlipCorner.BOTTOM) angle = -angle;\n\n    return angle;\n  }\n\n\n  private getPageRect(localPos: Point): RectPoints {\n    if (this.corner === FlipCorner.TOP) {\n      return this.getRectFromBasePoint(\n        [\n          { x: 0, y: 0 },\n          { x: this.pageWidth, y: 0 },\n          { x: 0, y: this.pageHeight },\n          { x: this.pageWidth, y: this.pageHeight },\n        ],\n        localPos\n      );\n    }\n\n    return this.getRectFromBasePoint(\n      [\n        { x: 0, y: -this.pageHeight },\n        { x: this.pageWidth, y: -this.pageHeight },\n        { x: 0, y: 0 },\n        { x: this.pageWidth, y: 0 },\n      ],\n      localPos\n    );\n  }\n\n  private getRectFromBasePoint(points: Point[], localPos: Point): RectPoints {\n    return {\n      topLeft: this.getRotatedPoint(points[0], localPos),\n      topRight: this.getRotatedPoint(points[1], localPos),\n      bottomLeft: this.getRotatedPoint(points[2], localPos),\n      bottomRight: this.getRotatedPoint(points[3], localPos),\n    };\n  }\n\n  private getRotatedPoint(transformedPoint: Point, startPoint: Point): Point {\n    return {\n      x:\n        transformedPoint.x * Math.cos(this.angle) +\n        transformedPoint.y * Math.sin(this.angle) +\n        startPoint.x,\n      y:\n        transformedPoint.y * Math.cos(this.angle) -\n        transformedPoint.x * Math.sin(this.angle) +\n        startPoint.y,\n    };\n  }\n\n  private calculateIntersectPoint(pos: Point): void {\n    const boundRect: Rect = {\n      left: -1,\n      top: -1,\n      width: this.pageWidth + 2,\n      height: this.pageHeight + 2,\n    };\n\n    if (this.corner === FlipCorner.TOP) {\n      this.topIntersectPoint = Helper.GetIntersectBetweenTwoSegment(\n        boundRect,\n        [pos, this.rect.topRight],\n        [\n          { x: 0, y: 0 },\n          { x: this.pageWidth, y: 0 },\n        ]\n      );\n\n      this.sideIntersectPoint = Helper.GetIntersectBetweenTwoSegment(\n        boundRect,\n        [pos, this.rect.bottomLeft],\n        [\n          { x: this.pageWidth, y: 0 },\n          { x: this.pageWidth, y: this.pageHeight },\n        ]\n      );\n\n      this.bottomIntersectPoint = Helper.GetIntersectBetweenTwoSegment(\n        boundRect,\n        [this.rect.bottomLeft, this.rect.bottomRight],\n        [\n          { x: 0, y: this.pageHeight },\n          { x: this.pageWidth, y: this.pageHeight },\n        ]\n      );\n    } else {\n      this.topIntersectPoint = Helper.GetIntersectBetweenTwoSegment(\n        boundRect,\n        [this.rect.topLeft, this.rect.topRight],\n        [\n          { x: 0, y: 0 },\n          { x: this.pageWidth, y: 0 },\n        ]\n      );\n\n      this.sideIntersectPoint = Helper.GetIntersectBetweenTwoSegment(\n        boundRect,\n        [pos, this.rect.topLeft],\n        [\n          { x: this.pageWidth, y: 0 },\n          { x: this.pageWidth, y: this.pageHeight },\n        ]\n      );\n\n      this.bottomIntersectPoint = Helper.GetIntersectBetweenTwoSegment(\n        boundRect,\n        [this.rect.bottomLeft, this.rect.bottomRight],\n        [\n          { x: 0, y: this.pageHeight },\n          { x: this.pageWidth, y: this.pageHeight },\n        ]\n      );\n    }\n  }\n\n  private checkPositionAtCenterLine(\n    checkedPos: Point,\n    centerOne: Point,\n    centerTwo: Point\n  ): Point {\n    let result = checkedPos;\n\n    const tmp = Helper.LimitPointToCircle(centerOne, this.pageWidth, result);\n    if (result !== tmp) {\n      result = tmp;\n      this.updateAngleAndGeometry(result);\n    }\n\n    const rad = Math.sqrt(Math.pow(this.pageWidth, 2) + Math.pow(this.pageHeight, 2));\n\n    let checkPointOne = this.rect.bottomRight;\n    let checkPointTwo = this.rect.topLeft;\n\n    if (this.corner === FlipCorner.BOTTOM) {\n      checkPointOne = this.rect.topRight;\n      checkPointTwo = this.rect.bottomLeft;\n    }\n\n    if (checkPointOne.x <= 0) {\n      const bottomPoint = Helper.LimitPointToCircle(centerTwo, rad, checkPointTwo);\n\n      if (bottomPoint !== result) {\n        result = bottomPoint;\n        this.updateAngleAndGeometry(result);\n      }\n    }\n\n    return result;\n  }\n\n  private getSegmentToShadowLine(): Segment {\n    const first = this.getShadowStartPoint();\n\n    const second =\n      first !== this.sideIntersectPoint && this.sideIntersectPoint !== null\n        ? this.sideIntersectPoint\n        : this.bottomIntersectPoint;\n\n    return [first, second];\n  }\n}\n","/**\n * Book size calculation type\n */\nexport enum SizeType {\n  /** Dimensions are fixed */\n  FIXED = 'fixed',\n  /** Dimensions are calculated based on the parent element */\n  STRETCH = 'stretch',\n}\n\n/**\n * Configuration object\n */\nexport interface FlipSetting {\n  /** Page number from which to start viewing */\n  startPage: number;\n  /** Whether the book will be stretched under the parent element or not */\n  size: SizeType;\n\n  width: number;\n  height: number;\n\n  minWidth: number;\n  maxWidth: number;\n  minHeight: number;\n  maxHeight: number;\n\n  /** Draw shadows or not when page flipping */\n  drawShadow: boolean;\n  /** Flipping animation time */\n  flippingTime: number;\n\n  /** Enable switching to portrait mode */\n  usePortrait: boolean;\n  /** Initial value to z-index */\n  startZIndex: number;\n  /** If this value is true, the parent element will be equal to the size of the book */\n  autoSize: boolean;\n  /** Shadow intensity (1: max intensity, 0: hidden shadows) */\n  maxShadowOpacity: number;\n\n  /** If this value is true, the first and the last pages will be marked as hard and will be shown in single page mode */\n  showCover: boolean;\n  /** Disable content scrolling when touching a book on mobile devices */\n  mobileScrollSupport: boolean;\n\n  /** Set the forward event of clicking on child elements (buttons, links) */\n  clickEventForward: boolean | string[];\n\n  /** Using mouse and touch events to page flipping */\n  useMouseEvents: boolean;\n\n  swipeDistance: number;\n\n  /** if this value is true, fold the corners of the book when the mouse pointer is over them. */\n  showPageCorners: boolean;\n\n  /** if this value is true, flipping by clicking on the whole book will be locked. Only on corners */\n  disableFlipByClick: boolean;\n}\n\nexport class Settings {\n  private _default: FlipSetting = {\n    startPage: 0,\n    size: SizeType.FIXED,\n    width: 0,\n    height: 0,\n    minWidth: 0,\n    maxWidth: 0,\n    minHeight: 0,\n    maxHeight: 0,\n    drawShadow: true,\n    flippingTime: 1000,\n    usePortrait: true,\n    startZIndex: 0,\n    autoSize: true,\n    maxShadowOpacity: 1,\n    showCover: false,\n    mobileScrollSupport: true,\n    swipeDistance: 30,\n    clickEventForward: false,\n    useMouseEvents: true,\n    showPageCorners: true,\n    disableFlipByClick: false,\n  };\n\n  /**\n   * Processing parameters received from the user. Substitution default values\n   *\n   * @param userSetting\n   * @returns {FlipSetting} Сonfiguration object\n   */\n  public getSettings(userSetting: Record<string, number | string | boolean | string[]>): FlipSetting {\n    const result = this._default;\n    Object.assign(result, userSetting);\n\n    if (result.size !== SizeType.STRETCH && result.size !== SizeType.FIXED)\n      throw new Error('Invalid size type. Available only \"fixed\" and \"stretch\" value');\n\n    if (result.width <= 0 || result.height <= 0) throw new Error('Invalid width or height');\n\n    if (result.flippingTime <= 0) throw new Error('Invalid flipping time');\n\n    if (result.size === SizeType.STRETCH) {\n      if (result.minWidth <= 0) result.minWidth = 100;\n\n      if (result.maxWidth < result.minWidth) result.maxWidth = 2000;\n\n      if (result.minHeight <= 0) result.minHeight = 100;\n\n      if (result.maxHeight < result.minHeight) result.maxHeight = 2000;\n    } else {\n      result.minWidth = result.width;\n      result.maxWidth = result.width;\n      result.minHeight = result.height;\n      result.maxHeight = result.height;\n    }\n\n    return result;\n  }\n}\n","import { PageFlip } from '../PageFlip';\nimport { Point, PageRect, RectPoints } from '../BasicTypes';\nimport { FlipDirection } from '../Flip/Flip';\nimport { Page, PageOrientation } from '../Page/Page';\nimport { FlipSetting, SizeType } from '../Settings';\n\ntype FrameAction = () => void;\ntype AnimationSuccessAction = () => void;\n\n/**\n * Type describing calculated values for drop shadows\n */\ntype Shadow = {\n  /** Shadow Position Start Point */\n  pos: Point;\n  /** The angle of the shadows relative to the book */\n  angle: number;\n  /** Base width shadow */\n  width: number;\n  /** Base shadow opacity */\n  opacity: number;\n  /** Flipping Direction, the direction of the shadow gradients */\n  direction: FlipDirection;\n  /** Flipping progress in percent (0 - 100) */\n  progress: number;\n};\n\n/**\n * Type describing the animation process\n * Only one animation process can be started at a same time\n */\ntype AnimationProcess = {\n  /** List of frames in playback order. Each frame is a function. */\n  frames: FrameAction[];\n  /** Total animation duration */\n  duration: number;\n  /** Animation duration of one frame */\n  durationFrame: number;\n  /** Сallback at the end of the animation */\n  onAnimateEnd: AnimationSuccessAction;\n  /** Animation start time (Global Timer) */\n  startedAt: number;\n};\n\n/**\n * Book orientation\n */\nexport enum Orientation {\n  PORTRAIT = 'portrait',\n  LANDSCAPE = 'landscape',\n}\n\n/**\n * Class responsible for rendering the book\n */\nexport abstract class Render {\n  protected readonly setting: FlipSetting;\n  protected readonly app: PageFlip;\n\n  /** Left static book page */\n  protected leftPage: Page = null;\n  /** Right static book page */\n  protected rightPage: Page = null;\n\n  /** Page currently flipping */\n  protected flippingPage: Page = null;\n  /** Next page at the time of flipping */\n  protected bottomPage: Page = null;\n\n  /** Current flipping direction */\n  protected direction: FlipDirection = null;\n  /** Current book orientation */\n  protected orientation: Orientation = null;\n  /** Сurrent state of the shadows */\n  protected shadow: Shadow = null;\n  /** Сurrent animation process */\n  protected animation: AnimationProcess = null;\n  /** Page borders while flipping */\n  protected pageRect: RectPoints = null;\n  /** Current book area */\n  private boundsRect: PageRect = null;\n\n  /** Timer started from start of rendering */\n  protected timer = 0;\n\n  /**\n   * Safari browser definitions for resolving a bug with a css property clip-area\n   *\n   * https://bugs.webkit.org/show_bug.cgi?id=126207\n   */\n  private safari = false;\n\n  protected constructor(app: PageFlip, setting: FlipSetting) {\n    this.setting = setting;\n    this.app = app;\n\n    // detect safari\n    const regex = new RegExp('Version\\\\/[\\\\d\\\\.]+.*Safari/');\n    this.safari = regex.exec(window.navigator.userAgent) !== null;\n  }\n\n  /**\n   * Rendering action on each requestAnimationFrame call. The entire rendering process is performed only in this method\n   */\n  protected abstract drawFrame(): void;\n\n  /**\n   * Reload the render area, after update pages\n   */\n  public abstract reload(): void;\n\n  /**\n   * Executed when requestAnimationFrame is called. Performs the current animation process and call drawFrame()\n   *\n   * @param timer\n   */\n  private render(timer: number): void {\n    if (this.animation !== null) {\n      // Find current frame of animation\n      const frameIndex = Math.round(\n        (timer - this.animation.startedAt) / this.animation.durationFrame\n      );\n\n      if (frameIndex < this.animation.frames.length) {\n        this.animation.frames[frameIndex]();\n      } else {\n        this.animation.onAnimateEnd();\n        this.animation = null;\n      }\n    }\n\n    this.timer = timer;\n    this.drawFrame();\n  }\n\n  /**\n   * Running requestAnimationFrame, and rendering process\n   */\n  public start(): void {\n    this.update();\n\n    const loop = (timer: number): void => {\n      this.render(timer);\n      requestAnimationFrame(loop);\n    };\n\n    requestAnimationFrame(loop);\n  }\n\n  /**\n   * Start a new animation process\n   *\n   * @param {FrameAction[]} frames - Frame list\n   * @param {number} duration - total animation duration\n   * @param {AnimationSuccessAction} onAnimateEnd - Animation callback function\n   */\n  public startAnimation(\n    frames: FrameAction[],\n    duration: number,\n    onAnimateEnd: AnimationSuccessAction\n  ): void {\n    this.finishAnimation(); // finish the previous animation process\n\n    this.animation = {\n      frames,\n      duration,\n      durationFrame: duration / frames.length,\n      onAnimateEnd,\n      startedAt: this.timer,\n    };\n  }\n\n  /**\n   * End the current animation process and call the callback\n   */\n  public finishAnimation(): void {\n    if (this.animation !== null) {\n      this.animation.frames[this.animation.frames.length - 1]();\n\n      if (this.animation.onAnimateEnd !== null) {\n        this.animation.onAnimateEnd();\n      }\n    }\n\n    this.animation = null;\n  }\n\n  /**\n   * Recalculate the size of the displayed area, and update the page orientation\n   */\n  public update(): void {\n    this.boundsRect = null;\n    const orientation = this.calculateBoundsRect();\n\n    if (this.orientation !== orientation) {\n      this.orientation = orientation;\n      this.app.updateOrientation(orientation);\n    }\n  }\n\n  /**\n   * Calculate the size and position of the book depending on the parent element and configuration parameters\n   */\n  private calculateBoundsRect(): Orientation {\n    let orientation = Orientation.LANDSCAPE;\n\n    const blockWidth = this.getBlockWidth();\n    const middlePoint: Point = {\n      x: blockWidth / 2,\n      y: this.getBlockHeight() / 2,\n    };\n\n    const ratio = this.setting.width / this.setting.height;\n\n    let pageWidth = this.setting.width;\n    let pageHeight = this.setting.height;\n\n    let left = middlePoint.x - pageWidth;\n\n    if (this.setting.size === SizeType.STRETCH) {\n      if (blockWidth < this.setting.minWidth * 2 && this.app.getSettings().usePortrait)\n        orientation = Orientation.PORTRAIT;\n\n      pageWidth =\n        orientation === Orientation.PORTRAIT\n          ? this.getBlockWidth()\n          : this.getBlockWidth() / 2;\n\n      if (pageWidth > this.setting.maxWidth) pageWidth = this.setting.maxWidth;\n\n      pageHeight = pageWidth / ratio;\n      if (pageHeight > this.getBlockHeight()) {\n        pageHeight = this.getBlockHeight();\n        pageWidth = pageHeight * ratio;\n      }\n\n      left =\n        orientation === Orientation.PORTRAIT\n          ? middlePoint.x - pageWidth / 2 - pageWidth\n          : middlePoint.x - pageWidth;\n    } else {\n      if (blockWidth < pageWidth * 2) {\n        if (this.app.getSettings().usePortrait) {\n          orientation = Orientation.PORTRAIT;\n          left = middlePoint.x - pageWidth / 2 - pageWidth;\n        }\n      }\n    }\n\n    this.boundsRect = {\n      left,\n      top: middlePoint.y - pageHeight / 2,\n      width: pageWidth * 2,\n      height: pageHeight,\n      pageWidth: pageWidth,\n    };\n\n    return orientation;\n  }\n\n  /**\n   * Set the current parameters of the drop shadow\n   *\n   * @param {Point} pos - Shadow Position Start Point\n   * @param {number} angle - The angle of the shadows relative to the book\n   * @param {number} progress - Flipping progress in percent (0 - 100)\n   * @param {FlipDirection} direction - Flipping Direction, the direction of the shadow gradients\n   */\n  public setShadowData(\n    pos: Point,\n    angle: number,\n    progress: number,\n    direction: FlipDirection\n  ): void {\n    if (!this.app.getSettings().drawShadow) return;\n\n    const maxShadowOpacity = 100 * this.getSettings().maxShadowOpacity;\n\n    this.shadow = {\n      pos,\n      angle,\n      width: (((this.getRect().pageWidth * 3) / 4) * progress) / 100,\n      opacity: ((100 - progress) * maxShadowOpacity) / 100 / 100,\n      direction,\n      progress: progress * 2,\n    };\n  }\n\n  /**\n   * Clear shadow\n   */\n  public clearShadow(): void {\n    this.shadow = null;\n  }\n\n  /**\n   * Get parent block offset width\n   */\n  public getBlockWidth(): number {\n    return this.app.getUI().getDistElement().offsetWidth;\n  }\n\n  /**\n   * Get parent block offset height\n   */\n  public getBlockHeight(): number {\n    return this.app.getUI().getDistElement().offsetHeight;\n  }\n\n  /**\n   * Get current flipping direction\n   */\n  public getDirection(): FlipDirection {\n    return this.direction;\n  }\n\n  /**\n   * Сurrent size and position of the book\n   */\n  public getRect(): PageRect {\n    if (this.boundsRect === null) this.calculateBoundsRect();\n\n    return this.boundsRect;\n  }\n\n  /**\n   * Get configuration object\n   */\n  public getSettings(): FlipSetting {\n    return this.app.getSettings();\n  }\n\n  /**\n   * Get current book orientation\n   */\n  public getOrientation(): Orientation {\n    return this.orientation;\n  }\n\n  /**\n   * Set page area while flipping\n   *\n   * @param direction\n   */\n  public setPageRect(pageRect: RectPoints): void {\n    this.pageRect = pageRect;\n  }\n\n  /**\n   * Set flipping direction\n   *\n   * @param direction\n   */\n  public setDirection(direction: FlipDirection): void {\n    this.direction = direction;\n  }\n\n  /**\n   * Set right static book page\n   *\n   * @param page\n   */\n  public setRightPage(page: Page): void {\n    if (page !== null) page.setOrientation(PageOrientation.RIGHT);\n\n    this.rightPage = page;\n  }\n\n  /**\n   * Set left static book page\n   * @param page\n   */\n  public setLeftPage(page: Page): void {\n    if (page !== null) page.setOrientation(PageOrientation.LEFT);\n\n    this.leftPage = page;\n  }\n\n  /**\n   * Set next page at the time of flipping\n   * @param page\n   */\n  public setBottomPage(page: Page): void {\n    if (page !== null)\n      page.setOrientation(\n        this.direction === FlipDirection.BACK ? PageOrientation.LEFT : PageOrientation.RIGHT\n      );\n\n    this.bottomPage = page;\n  }\n\n  /**\n   * Set currently flipping page\n   *\n   * @param page\n   */\n  public setFlippingPage(page: Page): void {\n    if (page !== null)\n      page.setOrientation(\n        this.direction === FlipDirection.FORWARD &&\n          this.orientation !== Orientation.PORTRAIT\n          ? PageOrientation.LEFT\n          : PageOrientation.RIGHT\n      );\n\n    this.flippingPage = page;\n  }\n\n  /**\n   * Coordinate conversion function. Window coordinates -> to book coordinates\n   *\n   * @param {Point} pos - Global coordinates relative to the window\n   * @returns {Point} Coordinates relative to the book\n   */\n  public convertToBook(pos: Point): Point {\n    const rect = this.getRect();\n\n    return {\n      x: pos.x - rect.left,\n      y: pos.y - rect.top,\n    };\n  }\n\n  public isSafari(): boolean {\n    return this.safari;\n  }\n\n  /**\n   * Coordinate conversion function. Window coordinates -> to current coordinates of the working page\n   *\n   * @param {Point} pos - Global coordinates relative to the window\n   * @param {FlipDirection} direction  - Current flipping direction\n   *\n   * @returns {Point} Coordinates relative to the work page\n   */\n  public convertToPage(pos: Point, direction?: FlipDirection): Point {\n    if (!direction) direction = this.direction;\n\n    const rect = this.getRect();\n    const x =\n      direction === FlipDirection.FORWARD\n        ? pos.x - rect.left - rect.width / 2\n        : rect.width / 2 - pos.x + rect.left;\n\n    return {\n      x,\n      y: pos.y - rect.top,\n    };\n  }\n\n  /**\n   * Coordinate conversion function. Coordinates relative to the work page -> Window coordinates\n   *\n   * @param {Point} pos - Coordinates relative to the work page\n   * @param {FlipDirection} direction  - Current flipping direction\n   *\n   * @returns {Point} Global coordinates relative to the window\n   */\n  public convertToGlobal(pos: Point, direction?: FlipDirection): Point {\n    if (!direction) direction = this.direction;\n\n    if (pos == null) return null;\n\n    const rect = this.getRect();\n\n    const x =\n      direction === FlipDirection.FORWARD\n        ? pos.x + rect.left + rect.width / 2\n        : rect.width / 2 - pos.x + rect.left;\n\n    return {\n      x,\n      y: pos.y + rect.top,\n    };\n  }\n\n  /**\n   * Casting the coordinates of the corners of the rectangle in the coordinates relative to the window\n   *\n   * @param {RectPoints} rect - Coordinates of the corners of the rectangle relative to the work page\n   * @param {FlipDirection} direction  - Current flipping direction\n   *\n   * @returns {RectPoints} Coordinates of the corners of the rectangle relative to the window\n   */\n  public convertRectToGlobal(rect: RectPoints, direction?: FlipDirection): RectPoints {\n    if (!direction) direction = this.direction;\n\n    return {\n      topLeft: this.convertToGlobal(rect.topLeft, direction),\n      topRight: this.convertToGlobal(rect.topRight, direction),\n      bottomLeft: this.convertToGlobal(rect.bottomLeft, direction),\n      bottomRight: this.convertToGlobal(rect.bottomRight, direction),\n    };\n  }\n}\n","import { Orientation, Render } from '../Render/Render';\nimport { Page, PageDensity } from '../Page/Page';\nimport { PageFlip } from '../PageFlip';\nimport { FlipDirection } from '../Flip/Flip';\n\ntype NumberArray = number[];\n\n/**\n * Сlass representing a collection of pages\n */\nexport abstract class PageCollection {\n    protected readonly app: PageFlip;\n    protected readonly render: Render;\n    protected readonly isShowCover: boolean;\n\n    /** Pages List */\n    protected pages: Page[] = [];\n    /** Index of the current page in list */\n    protected currentPageIndex = 0;\n\n    /** Number of the current spread in book */\n    protected currentSpreadIndex = 0;\n    /**  Two-page spread in landscape mode */\n    protected landscapeSpread: NumberArray[] = [];\n    /**  One-page spread in portrait mode */\n    protected portraitSpread: NumberArray[] = [];\n\n    protected constructor(app: PageFlip, render: Render) {\n        this.render = render;\n        this.app = app;\n\n        this.currentPageIndex = 0;\n        this.isShowCover = this.app.getSettings().showCover;\n    }\n\n    /**\n     * Load pages\n     */\n    public abstract load(): void;\n\n    /**\n     * Clear pages list\n     */\n    public destroy(): void {\n        this.pages = [];\n    }\n\n    /**\n     * Split the book on the two-page spread in landscape mode and one-page spread in portrait mode\n     */\n    protected createSpread(): void {\n        this.landscapeSpread = [];\n        this.portraitSpread = [];\n\n        for (let i = 0; i < this.pages.length; i++) {\n            this.portraitSpread.push([i]); // In portrait mode - (one spread = one page)\n        }\n\n        let start = 0;\n        if (this.isShowCover) {\n            this.pages[0].setDensity(PageDensity.HARD);\n            this.landscapeSpread.push([start]);\n            start++;\n        }\n\n        for (let i = start; i < this.pages.length; i += 2) {\n            if (i < this.pages.length - 1) this.landscapeSpread.push([i, i + 1]);\n            else {\n                this.landscapeSpread.push([i]);\n                this.pages[i].setDensity(PageDensity.HARD);\n            }\n        }\n    }\n\n    /**\n     * Get spread by mode (portrait or landscape)\n     */\n    protected getSpread(): NumberArray[] {\n        return this.render.getOrientation() === Orientation.LANDSCAPE\n            ? this.landscapeSpread\n            : this.portraitSpread;\n    }\n\n    /**\n     * Get spread index by page number\n     *\n     * @param {number} pageNum - page index\n     */\n    public getSpreadIndexByPage(pageNum: number): number {\n        const spread = this.getSpread();\n\n        for (let i = 0; i < spread.length; i++)\n            if (pageNum === spread[i][0] || pageNum === spread[i][1]) return i;\n\n        return null;\n    }\n\n    /**\n     * Get the total number of pages\n     */\n    public getPageCount(): number {\n        return this.pages.length;\n    }\n\n    /**\n     * Get the pages list\n     */\n    public getPages(): Page[] {\n        return this.pages;\n    }\n\n    /**\n     * Get page by index\n     *\n     * @param {number} pageIndex\n     */\n    public getPage(pageIndex: number): Page {\n        if (pageIndex >= 0 && pageIndex < this.pages.length) {\n            return this.pages[pageIndex];\n        }\n\n        throw new Error('Invalid page number');\n    }\n\n    /**\n     * Get the next page from the specified\n     *\n     * @param {Page} current\n     */\n    public nextBy(current: Page): Page {\n        const idx = this.pages.indexOf(current);\n\n        if (idx < this.pages.length - 1) return this.pages[idx + 1];\n\n        return null;\n    }\n\n    /**\n     * Get previous page from specified\n     *\n     * @param {Page} current\n     */\n    public prevBy(current: Page): Page {\n        const idx = this.pages.indexOf(current);\n\n        if (idx > 0) return this.pages[idx - 1];\n\n        return null;\n    }\n\n    /**\n     * Get flipping page depending on the direction\n     *\n     * @param {FlipDirection} direction\n     */\n    public getFlippingPage(direction: FlipDirection): Page {\n        const current = this.currentSpreadIndex;\n\n        if (this.render.getOrientation() === Orientation.PORTRAIT) {\n            return direction === FlipDirection.FORWARD\n                ? this.pages[current].newTemporaryCopy()\n                : this.pages[current - 1];\n        } else {\n            const spread =\n                direction === FlipDirection.FORWARD\n                    ? this.getSpread()[current + 1]\n                    : this.getSpread()[current - 1];\n\n            if (spread.length === 1) return this.pages[spread[0]];\n\n            return direction === FlipDirection.FORWARD\n                ? this.pages[spread[0]]\n                : this.pages[spread[1]];\n        }\n    }\n\n    /**\n     * Get Next page at the time of flipping\n     *\n     * @param {FlipDirection}  direction\n     */\n    public getBottomPage(direction: FlipDirection): Page {\n        const current = this.currentSpreadIndex;\n\n        if (this.render.getOrientation() === Orientation.PORTRAIT) {\n            return direction === FlipDirection.FORWARD\n                ? this.pages[current + 1]\n                : this.pages[current - 1];\n        } else {\n            const spread =\n                direction === FlipDirection.FORWARD\n                    ? this.getSpread()[current + 1]\n                    : this.getSpread()[current - 1];\n\n            if (spread.length === 1) return this.pages[spread[0]];\n\n            return direction === FlipDirection.FORWARD\n                ? this.pages[spread[1]]\n                : this.pages[spread[0]];\n        }\n    }\n\n    /**\n     * Show next spread\n     */\n    public showNext(): void {\n        if (this.currentSpreadIndex < this.getSpread().length) {\n            this.currentSpreadIndex++;\n            this.showSpread();\n        }\n    }\n\n    /**\n     * Show prev spread\n     */\n    public showPrev(): void {\n        if (this.currentSpreadIndex > 0) {\n            this.currentSpreadIndex--;\n            this.showSpread();\n        }\n    }\n\n    /**\n     * Get the number of the current spread in book\n     */\n    public getCurrentPageIndex(): number {\n        return this.currentPageIndex;\n    }\n\n    /**\n     * Show specified page\n     * @param {number} pageNum - Page index (from 0s)\n     */\n    public show(pageNum: number = null): void {\n        if (pageNum === null) pageNum = this.currentPageIndex;\n\n        if (pageNum < 0 || pageNum >= this.pages.length) return;\n\n        const spreadIndex = this.getSpreadIndexByPage(pageNum);\n        if (spreadIndex !== null) {\n            this.currentSpreadIndex = spreadIndex;\n            this.showSpread();\n        }\n    }\n\n    /**\n     * Index of the current page in list\n     */\n    public getCurrentSpreadIndex(): number {\n        return this.currentSpreadIndex;\n    }\n\n    /**\n     * Set new spread index as current\n     *\n     * @param {number} newIndex - new spread index\n     */\n    public setCurrentSpreadIndex(newIndex: number): void {\n        if (newIndex >= 0 && newIndex < this.getSpread().length) {\n            this.currentSpreadIndex = newIndex;\n        } else {\n            throw new Error('Invalid page');\n        }\n    }\n\n    /**\n     * Show current spread\n     */\n    private showSpread(): void {\n        const spread = this.getSpread()[this.currentSpreadIndex];\n\n        if (spread.length === 2) {\n            this.render.setLeftPage(this.pages[spread[0]]);\n            this.render.setRightPage(this.pages[spread[1]]);\n        } else {\n            if (this.render.getOrientation() === Orientation.LANDSCAPE) {\n                if (spread[0] === this.pages.length - 1) {\n                    this.render.setLeftPage(this.pages[spread[0]]);\n                    this.render.setRightPage(null);\n                } else {\n                    this.render.setLeftPage(null);\n                    this.render.setRightPage(this.pages[spread[0]]);\n                }\n            } else {\n                this.render.setLeftPage(null);\n                this.render.setRightPage(this.pages[spread[0]]);\n            }\n        }\n\n        this.currentPageIndex = spread[0];\n        this.app.updatePageIndex(this.currentPageIndex);\n    }\n}\n","import { ImagePage } from '../Page/ImagePage';\nimport { Render } from '../Render/Render';\nimport { PageCollection } from './PageCollection';\nimport { PageFlip } from '../PageFlip';\nimport { PageDensity } from '../Page/Page';\n\n/**\n * Сlass representing a collection of pages as images on the canvas\n */\nexport class ImagePageCollection extends PageCollection {\n    private readonly imagesHref: string[];\n\n    constructor(app: PageFlip, render: Render, imagesHref: string[]) {\n        super(app, render);\n\n        this.imagesHref = imagesHref;\n    }\n\n    public load(): void {\n        for (const href of this.imagesHref) {\n            const page = new ImagePage(this.render, href, PageDensity.SOFT);\n\n            page.load();\n            this.pages.push(page);\n        }\n\n        this.createSpread();\n    }\n}\n","import { Page, PageDensity, PageOrientation } from './Page';\r\nimport { Render } from '../Render/Render';\r\nimport { Helper } from '../Helper';\r\nimport { FlipDirection } from '../Flip/Flip';\r\nimport { Point } from '../BasicTypes';\r\n\r\n/**\r\n * Class representing a book page as a HTML Element\r\n */\r\nexport class HTMLPage extends Page {\r\n  private readonly element: HTMLElement;\r\n  private copiedElement: HTMLElement = null;\r\n\r\n  private temporaryCopy: Page = null;\r\n\r\n  private isLoad = false;\r\n\r\n  constructor(render: Render, element: HTMLElement, density: PageDensity) {\r\n    super(render, density);\r\n\r\n    this.element = element;\r\n    this.element.classList.add('stf__item');\r\n    this.element.classList.add('--' + density);\r\n  }\r\n\r\n  public newTemporaryCopy(): Page {\r\n    if (this.nowDrawingDensity === PageDensity.HARD) {\r\n      return this;\r\n    }\r\n\r\n    if (this.temporaryCopy === null) {\r\n      this.copiedElement = this.element.cloneNode(true) as HTMLElement;\r\n      this.element.parentElement.appendChild(this.copiedElement);\r\n\r\n      this.temporaryCopy = new HTMLPage(\r\n        this.render,\r\n        this.copiedElement,\r\n        this.nowDrawingDensity\r\n      );\r\n    }\r\n\r\n    return this.getTemporaryCopy();\r\n  }\r\n\r\n  public getTemporaryCopy(): Page {\r\n    return this.temporaryCopy;\r\n  }\r\n\r\n  public hideTemporaryCopy(): void {\r\n    if (this.temporaryCopy !== null) {\r\n      this.copiedElement.remove();\r\n      this.copiedElement = null;\r\n      this.temporaryCopy = null;\r\n    }\r\n  }\r\n\r\n  public draw(tempDensity?: PageDensity): void {\r\n    const density = tempDensity ? tempDensity : this.nowDrawingDensity;\r\n\r\n    const pagePos = this.render.convertToGlobal(this.state.position);\r\n    const pageWidth = this.render.getRect().pageWidth;\r\n    const pageHeight = this.render.getRect().height;\r\n\r\n    this.element.classList.remove('--simple');\r\n\r\n    // const commonStyle = `\r\n    //         display: block;\r\n    //         z-index: ${this.element.style.zIndex};\r\n    //         left: 0;\r\n    //         top: 0;\r\n    //         width: ${pageWidth}px;\r\n    //         height: ${pageHeight}px;\r\n    //     `;\r\n\r\n    this.element.style.display = 'block';\r\n    this.element.style.left = '0';\r\n    this.element.style.top = '0';\r\n\r\n    this.element.style.width = pageWidth + 'px';\r\n    this.element.style.height = pageHeight + 'px';\r\n\r\n    density === PageDensity.HARD\r\n      ? this.drawHard()\r\n      : this.drawSoft(pagePos);\r\n  }\r\n\r\n  private drawHard(commonStyle = ''): void {\r\n    const pos = this.render.getRect().left + this.render.getRect().width / 2;\r\n\r\n    const angle = this.state.hardDrawingAngle;\r\n\r\n    this.element.style.backfaceVisibility = 'hidden';\r\n    this.element.style.setProperty('-webkit-backface-visibility', 'hidden');\r\n    if (this.orientation === PageOrientation.LEFT) {\r\n      this.element.style.transformOrigin = this.render.getRect().pageWidth + 'px 0';\r\n      this.element.style.transform =\r\n        'translate3d(' + 0 + 'px, ' + 0 + 'px, 0) rotateY(' + angle + 'deg)';\r\n    } else {\r\n      this.element.style.transformOrigin = '0 0';\r\n      this.element.style.transform =\r\n        'translate3d(' + pos + 'px, ' + 0 + 'px, 0) rotateY(' + angle + 'deg)';\r\n    }\r\n    this.element.style.clipPath = 'none';\r\n    this.element.style.setProperty('-webkit-clip-path', 'none');\r\n\r\n    // const newStyle =\r\n    //   commonStyle +\r\n    //   `\r\n    //             backface-visibility: hidden;\r\n    //             -webkit-backface-visibility: hidden;\r\n    //             clip-path: none;\r\n    //             -webkit-clip-path: none;\r\n    //         ` +\r\n    //   (this.orientation === PageOrientation.LEFT\r\n    //     ? `transform-origin: ${this.render.getRect().pageWidth}px 0; \r\n    //                transform: translate3d(0, 0, 0) rotateY(${angle}deg);`\r\n    //     : `transform-origin: 0 0; \r\n    //                transform: translate3d(${pos}px, 0, 0) rotateY(${angle}deg);`);\r\n\r\n    // this.element.style.cssText = newStyle;\r\n\r\n\r\n  }\r\n\r\n  private drawSoft(position: Point, commonStyle = ''): void {\r\n    let polygon = 'polygon( ';\r\n    for (const p of this.state.area) {\r\n      if (p !== null) {\r\n        let g =\r\n          this.render.getDirection() === FlipDirection.BACK\r\n            ? {\r\n              x: -p.x + this.state.position.x,\r\n              y: p.y - this.state.position.y,\r\n            }\r\n            : {\r\n              x: p.x - this.state.position.x,\r\n              y: p.y - this.state.position.y,\r\n            };\r\n\r\n        g = Helper.GetRotatedPoint(g, { x: 0, y: 0 }, this.state.angle);\r\n        polygon += g.x + 'px ' + g.y + 'px, ';\r\n      }\r\n    }\r\n    polygon = polygon.slice(0, -2);\r\n    polygon += ')';\r\n\r\n    // const newStyle =\r\n    //   commonStyle +\r\n    //   `transform-origin: 0 0; clip-path: ${polygon}; -webkit-clip-path: ${polygon};` +\r\n    //   (this.render.isSafari() && this.state.angle === 0\r\n    //     ? `transform: translate(${position.x}px, ${position.y}px);`\r\n    //     : `transform: translate3d(${position.x}px, ${position.y}px, 0) rotate(${this.state.angle}rad);`);\r\n\r\n    // this.element.style.cssText = newStyle;\r\n\r\n    this.element.style.transformOrigin = '0 0';\r\n    if (this.render.isSafari() && this.state.angle === 0) {\r\n      this.element.style.transform = 'translate(' + position.x + 'px, ' + position.y + 'px)';\r\n    } else {\r\n      this.element.style.transform =\r\n        'translate3d(' +\r\n        position.x +\r\n        'px, ' +\r\n        position.y +\r\n        'px, 0) rotate(' +\r\n        this.state.angle +\r\n        'rad)';\r\n    }\r\n\r\n    this.element.style.clipPath = polygon;\r\n    this.element.style.setProperty('-webkit-clip-path', polygon);\r\n  }\r\n\r\n  public simpleDraw(orient: PageOrientation): void {\r\n    if (this.element.classList.contains('--simple')) return;\r\n\r\n    const rect = this.render.getRect();\r\n\r\n    const pageWidth = rect.pageWidth;\r\n    const pageHeight = rect.height;\r\n\r\n    const x = orient === PageOrientation.RIGHT ? rect.left + rect.pageWidth : rect.left;\r\n\r\n    const y = rect.top;\r\n\r\n    this.element.classList.add('--simple');\r\n    this.element.style.cssText = `\r\n            position: absolute; \r\n            display: block; \r\n            height: ${pageHeight}px; \r\n            left: ${x}px; \r\n            top: ${y}px; \r\n            width: ${pageWidth}px; \r\n            z-index: ${this.render.getSettings().startZIndex + 1};`;\r\n\r\n    // this.element.style.position = 'absolute';\r\n    // this.element.style.display = 'block';\r\n    // this.element.style.height = pageHeight + 'px';\r\n    // this.element.style.top = y + 'px';\r\n    // this.element.style.left = x + 'px';\r\n    // this.element.style.width = pageWidth + 'px';\r\n    // this.element.style.zIndex = String(this.render.getSettings().startZIndex + 1);\r\n  }\r\n\r\n  public clearSaved(): void {\r\n    this.element.classList.remove('--simple');\r\n\r\n    if (this.copiedElement !== null) {\r\n      this.copiedElement.remove();\r\n      this.copiedElement = null;\r\n    }\r\n  }\r\n\r\n  public getElement(): HTMLElement {\r\n    return this.element;\r\n  }\r\n\r\n  public load(): void {\r\n    this.isLoad = true;\r\n  }\r\n\r\n  public setOrientation(orientation: PageOrientation): void {\r\n    super.setOrientation(orientation);\r\n    this.element.classList.remove('--left', '--right');\r\n\r\n    this.element.classList.add(orientation === PageOrientation.RIGHT ? '--right' : '--left');\r\n  }\r\n\r\n  public setDrawingDensity(density: PageDensity): void {\r\n    this.element.classList.remove('--soft', '--hard');\r\n    this.element.classList.add('--' + density);\r\n\r\n    super.setDrawingDensity(density);\r\n  }\r\n}\r\n","import { HTMLPage } from '../Page/HTMLPage';\nimport { Render } from '../Render/Render';\nimport { PageCollection } from './PageCollection';\nimport { PageFlip } from '../PageFlip';\nimport { PageDensity } from '../Page/Page';\n\n/**\n * Сlass representing a collection of pages as HTML Element\n */\nexport class HTMLPageCollection extends PageCollection {\n    private readonly element: HTMLElement;\n    private readonly pagesElement: NodeListOf<HTMLElement> | HTMLElement[];\n\n    constructor(\n        app: PageFlip,\n        render: Render,\n        element: HTMLElement,\n        items: NodeListOf<HTMLElement> | HTMLElement[]\n    ) {\n        super(app, render);\n\n        this.element = element;\n        this.pagesElement = items;\n    }\n\n    public load(): void {\n        for (const pageElement of this.pagesElement) {\n            const page = new HTMLPage(\n                this.render,\n                pageElement,\n                pageElement.dataset['density'] === 'hard' ? PageDensity.HARD : PageDensity.SOFT\n            );\n\n            page.load();\n            this.pages.push(page);\n        }\n\n        this.createSpread();\n    }\n}\n","import { Orientation, Render } from './Render';\nimport { PageFlip } from '../PageFlip';\nimport { FlipDirection } from '../Flip/Flip';\nimport { PageOrientation } from '../Page/Page';\nimport { FlipSetting } from '../Settings';\n\n/**\n * Class responsible for rendering the Canvas book\n */\nexport class CanvasRender extends Render {\n    private readonly canvas: HTMLCanvasElement;\n    private readonly ctx: CanvasRenderingContext2D;\n\n    constructor(app: PageFlip, setting: FlipSetting, inCanvas: HTMLCanvasElement) {\n        super(app, setting);\n\n        this.canvas = inCanvas;\n        this.ctx = inCanvas.getContext('2d');\n    }\n\n    public getContext(): CanvasRenderingContext2D {\n        return this.ctx;\n    }\n\n    public reload(): void {\n        //\n    }\n\n    protected drawFrame(): void {\n        this.clear();\n\n        if (this.orientation !== Orientation.PORTRAIT)\n            if (this.leftPage != null) this.leftPage.simpleDraw(PageOrientation.LEFT);\n\n        if (this.rightPage != null) this.rightPage.simpleDraw(PageOrientation.RIGHT);\n\n        if (this.bottomPage != null) this.bottomPage.draw();\n\n        this.drawBookShadow();\n\n        if (this.flippingPage != null) this.flippingPage.draw();\n\n        if (this.shadow != null) {\n            this.drawOuterShadow();\n            this.drawInnerShadow();\n        }\n\n        const rect = this.getRect();\n\n        if (this.orientation === Orientation.PORTRAIT) {\n            this.ctx.beginPath();\n            this.ctx.rect(rect.left + rect.pageWidth, rect.top, rect.width, rect.height);\n            this.ctx.clip();\n        }\n    }\n\n    private drawBookShadow(): void {\n        const rect = this.getRect();\n\n        this.ctx.save();\n        this.ctx.beginPath();\n\n        const shadowSize = rect.width / 20;\n        this.ctx.rect(rect.left, rect.top, rect.width, rect.height);\n\n        const shadowPos = { x: rect.left + rect.width / 2 - shadowSize / 2, y: 0 };\n        this.ctx.translate(shadowPos.x, shadowPos.y);\n\n        const outerGradient = this.ctx.createLinearGradient(0, 0, shadowSize, 0);\n\n        outerGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');\n        outerGradient.addColorStop(0.4, 'rgba(0, 0, 0, 0.2)');\n        outerGradient.addColorStop(0.49, 'rgba(0, 0, 0, 0.1)');\n        outerGradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.5)');\n        outerGradient.addColorStop(0.51, 'rgba(0, 0, 0, 0.4)');\n        outerGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n\n        this.ctx.clip();\n\n        this.ctx.fillStyle = outerGradient;\n        this.ctx.fillRect(0, 0, shadowSize, rect.height * 2);\n\n        this.ctx.restore();\n    }\n\n    private drawOuterShadow(): void {\n        const rect = this.getRect();\n\n        this.ctx.save();\n        this.ctx.beginPath();\n\n        this.ctx.rect(rect.left, rect.top, rect.width, rect.height);\n\n        const shadowPos = this.convertToGlobal({ x: this.shadow.pos.x, y: this.shadow.pos.y });\n        this.ctx.translate(shadowPos.x, shadowPos.y);\n\n        this.ctx.rotate(Math.PI + this.shadow.angle + Math.PI / 2);\n\n        const outerGradient = this.ctx.createLinearGradient(0, 0, this.shadow.width, 0);\n\n        if (this.shadow.direction === FlipDirection.FORWARD) {\n            this.ctx.translate(0, -100);\n            outerGradient.addColorStop(0, 'rgba(0, 0, 0, ' + this.shadow.opacity + ')');\n            outerGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n        } else {\n            this.ctx.translate(-this.shadow.width, -100);\n            outerGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');\n            outerGradient.addColorStop(1, 'rgba(0, 0, 0, ' + this.shadow.opacity + ')');\n        }\n\n        this.ctx.clip();\n\n        this.ctx.fillStyle = outerGradient;\n        this.ctx.fillRect(0, 0, this.shadow.width, rect.height * 2);\n\n        this.ctx.restore();\n    }\n\n    private drawInnerShadow(): void {\n        const rect = this.getRect();\n\n        this.ctx.save();\n        this.ctx.beginPath();\n\n        const shadowPos = this.convertToGlobal({ x: this.shadow.pos.x, y: this.shadow.pos.y });\n\n        const pageRect = this.convertRectToGlobal(this.pageRect);\n        this.ctx.moveTo(pageRect.topLeft.x, pageRect.topLeft.y);\n        this.ctx.lineTo(pageRect.topRight.x, pageRect.topRight.y);\n        this.ctx.lineTo(pageRect.bottomRight.x, pageRect.bottomRight.y);\n        this.ctx.lineTo(pageRect.bottomLeft.x, pageRect.bottomLeft.y);\n        this.ctx.translate(shadowPos.x, shadowPos.y);\n\n        this.ctx.rotate(Math.PI + this.shadow.angle + Math.PI / 2);\n\n        const isw = (this.shadow.width * 3) / 4;\n        const innerGradient = this.ctx.createLinearGradient(0, 0, isw, 0);\n\n        if (this.shadow.direction === FlipDirection.FORWARD) {\n            this.ctx.translate(-isw, -100);\n\n            innerGradient.addColorStop(1, 'rgba(0, 0, 0, ' + this.shadow.opacity + ')');\n            innerGradient.addColorStop(0.9, 'rgba(0, 0, 0, 0.05)');\n            innerGradient.addColorStop(0.7, 'rgba(0, 0, 0, ' + this.shadow.opacity + ')');\n            innerGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');\n        } else {\n            this.ctx.translate(0, -100);\n\n            innerGradient.addColorStop(0, 'rgba(0, 0, 0, ' + this.shadow.opacity + ')');\n            innerGradient.addColorStop(0.1, 'rgba(0, 0, 0, 0.05)');\n            innerGradient.addColorStop(0.3, 'rgba(0, 0, 0, ' + this.shadow.opacity + ')');\n            innerGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n        }\n\n        this.ctx.clip();\n\n        this.ctx.fillStyle = innerGradient;\n        this.ctx.fillRect(0, 0, isw, rect.height * 2);\n\n        this.ctx.restore();\n    }\n\n    private clear(): void {\n        this.ctx.fillStyle = 'white';\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n    }\n}\n","import { PageFlip } from '../PageFlip';\nimport { Point } from '../BasicTypes';\nimport { FlipSetting, SizeType } from '../Settings';\nimport { FlipCorner, FlippingState } from '../Flip/Flip';\nimport { Orientation } from '../Render/Render';\n\ntype SwipeData = {\n  point: Point;\n  time: number;\n};\n\n/**\n * UI Class, represents work with DOM\n */\nexport abstract class UI {\n  protected readonly parentElement: HTMLElement;\n\n  protected readonly app: PageFlip;\n  protected readonly wrapper: HTMLElement;\n  protected distElement: HTMLElement;\n\n  private touchPoint: SwipeData = null;\n  private readonly swipeTimeout = 250;\n  private readonly swipeDistance: number;\n\n  private onResize = (): void => {\n    this.update();\n  };\n\n  /**\n   * @constructor\n   *\n   * @param {HTMLElement} inBlock - Root HTML Element\n   * @param {PageFlip} app - PageFlip instanse\n   * @param {FlipSetting} setting - Configuration object\n   */\n  protected constructor(inBlock: HTMLElement, app: PageFlip, setting: FlipSetting) {\n    this.parentElement = inBlock;\n\n    inBlock.classList.add('stf__parent');\n    // Add first wrapper\n    inBlock.insertAdjacentHTML('afterbegin', '<div class=\"stf__wrapper\"></div>');\n\n    this.wrapper = inBlock.querySelector('.stf__wrapper');\n\n    this.app = app;\n\n    const k = this.app.getSettings().usePortrait ? 1 : 2;\n\n    // Setting block sizes based on configuration\n    inBlock.style.minWidth = setting.minWidth * k + 'px';\n    inBlock.style.minHeight = setting.minHeight + 'px';\n\n    if (setting.size === SizeType.FIXED) {\n      inBlock.style.minWidth = setting.width * k + 'px';\n      inBlock.style.minHeight = setting.height + 'px';\n    }\n\n    if (setting.autoSize) {\n      inBlock.style.width = '100%';\n      inBlock.style.maxWidth = setting.maxWidth * 2 + 'px';\n    }\n\n    inBlock.style.display = 'block';\n\n    window.addEventListener('resize', this.onResize, false);\n    this.swipeDistance = setting.swipeDistance;\n  }\n\n  /**\n   * Destructor. Remove all HTML elements and all event handlers\n   */\n  public destroy(): void {\n    if (this.app.getSettings().useMouseEvents) this.removeHandlers();\n\n    this.distElement.remove();\n    this.wrapper.remove();\n  }\n\n  /**\n   * Updating child components when resizing\n   */\n  public abstract update(): void;\n\n  /**\n   * Get parent element for book\n   *\n   * @returns {HTMLElement}\n   */\n  public getDistElement(): HTMLElement {\n    return this.distElement;\n  }\n\n  /**\n   * Get wrapper element\n   *\n   * @returns {HTMLElement}\n   */\n  public getWrapper(): HTMLElement {\n    return this.wrapper;\n  }\n\n  /**\n   * Updates styles and sizes based on book orientation\n   *\n   * @param {Orientation} orientation - New book orientation\n   */\n  public setOrientationStyle(orientation: Orientation): void {\n    this.wrapper.classList.remove('--portrait', '--landscape');\n\n    if (orientation === Orientation.PORTRAIT) {\n      if (this.app.getSettings().autoSize)\n        this.wrapper.style.paddingBottom =\n          (this.app.getSettings().height / this.app.getSettings().width) * 100 + '%';\n\n      this.wrapper.classList.add('--portrait');\n    } else {\n      if (this.app.getSettings().autoSize)\n        this.wrapper.style.paddingBottom =\n          (this.app.getSettings().height / (this.app.getSettings().width * 2)) * 100 +\n          '%';\n\n      this.wrapper.classList.add('--landscape');\n    }\n\n    this.update();\n  }\n\n  protected removeHandlers(): void {\n    window.removeEventListener('resize', this.onResize);\n\n    this.distElement.removeEventListener('mousedown', this.onMouseDown);\n    this.distElement.removeEventListener('touchstart', this.onTouchStart);\n    window.removeEventListener('mousemove', this.onMouseMove);\n    window.removeEventListener('touchmove', this.onTouchMove);\n    window.removeEventListener('mouseup', this.onMouseUp);\n    window.removeEventListener('touchend', this.onTouchEnd);\n  }\n\n  protected setHandlers(): void {\n    window.addEventListener('resize', this.onResize, false);\n    if (!this.app.getSettings().useMouseEvents) return;\n\n    this.distElement.addEventListener('mousedown', this.onMouseDown);\n    this.distElement.addEventListener('touchstart', this.onTouchStart);\n    window.addEventListener('mousemove', this.onMouseMove);\n    window.addEventListener('touchmove', this.onTouchMove, {\n      passive: !this.app.getSettings().mobileScrollSupport,\n    });\n    window.addEventListener('mouseup', this.onMouseUp);\n    window.addEventListener('touchend', this.onTouchEnd);\n  }\n\n  /**\n   * Convert global coordinates to relative book coordinates\n   *\n   * @param x\n   * @param y\n   */\n  private getMousePos(x: number, y: number): Point {\n    const rect = this.distElement.getBoundingClientRect();\n\n    return {\n      x: x - rect.left,\n      y: y - rect.top,\n    };\n  }\n\n  private checkTarget(target: EventTarget): boolean {\n    if (this.app.getSettings().clickEventForward === true) return false;\n    if (Array.isArray(this.app.getSettings().clickEventForward)) {\n      if ((this.app.getSettings().clickEventForward as string[]).includes((target as HTMLElement).tagName.toLowerCase())) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private onMouseDown = (e: MouseEvent): void => {\n    if (this.checkTarget(e.target)) {\n      const pos = this.getMousePos(e.clientX, e.clientY);\n\n      this.app.startUserTouch(pos);\n\n      e.preventDefault();\n    }\n  };\n\n  private onTouchStart = (e: TouchEvent): void => {\n    if (this.checkTarget(e.target)) {\n      if (e.changedTouches.length > 0) {\n        const t = e.changedTouches[0];\n        const pos = this.getMousePos(t.clientX, t.clientY);\n\n        this.touchPoint = {\n          point: pos,\n          time: Date.now(),\n        };\n\n        // part of swipe detection\n        setTimeout(() => {\n          if (this.touchPoint !== null) {\n            this.app.startUserTouch(pos);\n          }\n        }, this.swipeTimeout);\n\n        if (!this.app.getSettings().mobileScrollSupport) e.preventDefault();\n      }\n    }\n  };\n\n  private onMouseUp = (e: MouseEvent): void => {\n    const pos = this.getMousePos(e.clientX, e.clientY);\n\n    this.app.userStop(pos);\n  };\n\n  private onMouseMove = (e: MouseEvent): void => {\n    const pos = this.getMousePos(e.clientX, e.clientY);\n\n    this.app.userMove(pos, false);\n  };\n\n  private onTouchMove = (e: TouchEvent): void => {\n    if (e.changedTouches.length > 0) {\n      const t = e.changedTouches[0];\n      const pos = this.getMousePos(t.clientX, t.clientY);\n\n      if (this.app.getSettings().mobileScrollSupport) {\n        if (this.touchPoint !== null) {\n          if (\n            Math.abs(this.touchPoint.point.x - pos.x) > 10 ||\n            this.app.getState() !== FlippingState.READ\n          ) {\n            if (e.cancelable) this.app.userMove(pos, true);\n          }\n        }\n\n        if (this.app.getState() !== FlippingState.READ) {\n          e.preventDefault();\n        }\n      } else {\n        this.app.userMove(pos, true);\n      }\n    }\n  };\n\n  private onTouchEnd = (e: TouchEvent): void => {\n    if (e.changedTouches.length > 0) {\n      const t = e.changedTouches[0];\n      const pos = this.getMousePos(t.clientX, t.clientY);\n      let isSwipe = false;\n\n      // swipe detection\n      if (this.touchPoint !== null) {\n        const dx = pos.x - this.touchPoint.point.x;\n        const distY = Math.abs(pos.y - this.touchPoint.point.y);\n\n        if (\n          Math.abs(dx) > this.swipeDistance &&\n          distY < this.swipeDistance * 2 &&\n          Date.now() - this.touchPoint.time < this.swipeTimeout\n        ) {\n          if (dx > 0) {\n            this.app.flipPrev(\n              this.touchPoint.point.y < this.app.getRender().getRect().height / 2\n                ? FlipCorner.TOP\n                : FlipCorner.BOTTOM\n            );\n          } else {\n            this.app.flipNext(\n              this.touchPoint.point.y < this.app.getRender().getRect().height / 2\n                ? FlipCorner.TOP\n                : FlipCorner.BOTTOM\n            );\n          }\n          isSwipe = true;\n        }\n\n        this.touchPoint = null;\n      }\n\n      this.app.userStop(pos, isSwipe);\n    }\n  };\n}\n","import { UI } from './UI';\nimport { PageFlip } from '../PageFlip';\nimport { FlipSetting } from '../Settings';\n\n/**\n * UI for HTML mode\n */\nexport class HTMLUI extends UI {\n    private items: NodeListOf<HTMLElement> | HTMLElement[];\n\n    constructor(\n        inBlock: HTMLElement,\n        app: PageFlip,\n        setting: FlipSetting,\n        items: NodeListOf<HTMLElement> | HTMLElement[]\n    ) {\n        super(inBlock, app, setting);\n\n        // Second wrapper to HTML page\n        this.wrapper.insertAdjacentHTML('afterbegin', '<div class=\"stf__block\"></div>');\n\n        this.distElement = inBlock.querySelector('.stf__block');\n\n        this.items = items;\n        for (const item of items) {\n            this.distElement.appendChild(item);\n        }\n\n        this.setHandlers();\n    }\n\n    public clear(): void {\n        for (const item of this.items) {\n            this.parentElement.appendChild(item);\n        }\n    }\n\n    /**\n     * Update page list from HTMLElements\n     *\n     * @param {(NodeListOf<HTMLElement>|HTMLElement[])} items - List of pages as HTML Element\n     */\n    public updateItems(items: NodeListOf<HTMLElement> | HTMLElement[]): void {\n        this.removeHandlers();\n\n        this.distElement.innerHTML = '';\n\n        for (const item of items) {\n            this.distElement.appendChild(item);\n        }\n        this.items = items;\n\n        this.setHandlers();\n    }\n\n    public update(): void {\n        this.app.getRender().update();\n    }\n}\n","import {UI} from \"./UI\";\nimport {PageFlip} from \"../PageFlip\";\nimport {FlipSetting} from \"../Settings\";\n\n/**\n * UI for canvas mode\n */\nexport class CanvasUI extends UI {\n    private readonly canvas: HTMLCanvasElement;\n\n    constructor(inBlock: HTMLElement, app: PageFlip, setting: FlipSetting) {\n        super(inBlock, app, setting);\n\n        this.wrapper.innerHTML = '<canvas class=\"stf__canvas\"></canvas>';\n\n        this.canvas = inBlock.querySelectorAll('canvas')[0];\n\n        this.distElement = this.canvas;\n\n        this.resizeCanvas();\n        this.setHandlers();\n    }\n\n    private resizeCanvas(): void {\n        const cs = getComputedStyle(this.canvas);\n        const width = parseInt(cs.getPropertyValue('width'), 10);\n        const height = parseInt(cs.getPropertyValue('height'), 10);\n\n        this.canvas.width = width;\n        this.canvas.height = height;\n    }\n\n    /**\n     * Get canvas element\n     */\n    public getCanvas(): HTMLCanvasElement {\n        return this.canvas;\n    }\n\n    public update(): void {\n        this.resizeCanvas();\n        this.app.getRender().update();\n    }\n}","import { PageFlip } from '../PageFlip';\n\n/**\n * Data type passed to the event handler\n */\nexport type DataType = number | string | boolean | object;\n\n/**\n * Type of object in event handlers\n */\nexport interface WidgetEvent {\n    data: DataType;\n    object: PageFlip;\n}\n\ntype EventCallback = (e: WidgetEvent) => void;\n\n/**\n * A class implementing a basic event model\n */\nexport abstract class EventObject {\n    private events = new Map<string, EventCallback[]>();\n\n    /**\n     * Add new event handler\n     *\n     * @param {string} eventName\n     * @param {EventCallback} callback\n     */\n    public on(eventName: string, callback: EventCallback): EventObject {\n        if (!this.events.has(eventName)) {\n            this.events.set(eventName, [callback]);\n        } else {\n            this.events.get(eventName).push(callback);\n        }\n\n        return this;\n    }\n\n    /**\n     * Removing all handlers from an event\n     *\n     * @param {string} event - Event name\n     */\n    public off(event: string): void {\n        this.events.delete(event);\n    }\n\n    protected trigger(eventName: string, app: PageFlip, data: DataType = null): void {\n        if (!this.events.has(eventName)) return;\n\n        for (const callback of this.events.get(eventName)) {\n            callback({ data, object: app });\n        }\n    }\n}\n","import { Orientation, Render } from './Render';\nimport { PageFlip } from '../PageFlip';\nimport { FlipDirection } from '../Flip/Flip';\nimport { PageDensity, PageOrientation } from '../Page/Page';\nimport { HTMLPage } from '../Page/HTMLPage';\nimport { Helper } from '../Helper';\nimport { FlipSetting } from '../Settings';\n\n/**\n * Class responsible for rendering the HTML book\n */\nexport class HTMLRender extends Render {\n  /** Parent HTML Element */\n  private readonly element: HTMLElement;\n\n  /** Pages List as HTMLElements */\n  private readonly items: NodeListOf<HTMLElement> | HTMLElement[];\n\n  private outerShadow: HTMLElement = null;\n  private innerShadow: HTMLElement = null;\n  private hardShadow: HTMLElement = null;\n  private hardInnerShadow: HTMLElement = null;\n\n  /**\n   * @constructor\n   *\n   * @param {PageFlip} app - PageFlip object\n   * @param {FlipSetting} setting - Configuration object\n   * @param {HTMLElement} element - Parent HTML Element\n   */\n  constructor(app: PageFlip, setting: FlipSetting, element: HTMLElement) {\n    super(app, setting);\n\n    this.element = element;\n\n    this.createShadows();\n  }\n\n  private createShadows(): void {\n    this.element.insertAdjacentHTML(\n      'beforeend',\n      `<div class=\"stf__outerShadow\"></div>\n             <div class=\"stf__innerShadow\"></div>\n             <div class=\"stf__hardShadow\"></div>\n             <div class=\"stf__hardInnerShadow\"></div>`\n    );\n\n    this.outerShadow = this.element.querySelector('.stf__outerShadow');\n    this.innerShadow = this.element.querySelector('.stf__innerShadow');\n    this.hardShadow = this.element.querySelector('.stf__hardShadow');\n    this.hardInnerShadow = this.element.querySelector('.stf__hardInnerShadow');\n  }\n\n  public clearShadow(): void {\n    super.clearShadow();\n\n    this.outerShadow.style.cssText = 'display: none';\n    this.innerShadow.style.cssText = 'display: none';\n    this.hardShadow.style.cssText = 'display: none';\n    this.hardInnerShadow.style.cssText = 'display: none';\n  }\n\n  public reload(): void {\n    const testShadow = this.element.querySelector('.stf__outerShadow');\n\n    if (!testShadow) {\n      this.createShadows();\n    }\n  }\n\n  /**\n   * Draw inner shadow to the hard page\n   */\n  private drawHardInnerShadow(): void {\n    const rect = this.getRect();\n\n    const progress =\n      this.shadow.progress > 100 ? 200 - this.shadow.progress : this.shadow.progress;\n\n    let innerShadowSize = ((100 - progress) * (2.5 * rect.pageWidth)) / 100 + 20;\n    if (innerShadowSize > rect.pageWidth) innerShadowSize = rect.pageWidth;\n\n    // let newStyle = `\n    //         display: block;\n    //         z-index: ${(this.getSettings().startZIndex + 5).toString(10)};\n    //         width: ${innerShadowSize}px;\n    //         height: ${rect.height}px;\n    //         background: linear-gradient(to right,\n    //             rgba(0, 0, 0, ${(this.shadow.opacity * progress) / 100}) 5%,\n    //             rgba(0, 0, 0, 0) 100%);\n    //         left: ${rect.left + rect.width / 2}px;\n    //         transform-origin: 0 0;\n    //     `;\n\n    // newStyle +=\n    //   (this.getDirection() === FlipDirection.FORWARD && this.shadow.progress > 100) ||\n    //     (this.getDirection() === FlipDirection.BACK && this.shadow.progress <= 100)\n    //     ? `transform: translate3d(0, 0, 0);`\n    //     : `transform: translate3d(0, 0, 0) rotateY(180deg);`;\n\n    // this.hardInnerShadow.style.cssText = newStyle;\n\n    this.hardInnerShadow.style.display = 'block';\n    this.hardInnerShadow.style.zIndex = (this.getSettings().startZIndex + 5).toString(10);\n    this.hardInnerShadow.style.width = innerShadowSize + 'px';\n    this.hardInnerShadow.style.height = rect.height + 'px';\n    this.hardInnerShadow.style.background = `linear-gradient(to right,\n            rgba(0, 0, 0, ${(this.shadow.opacity * progress) / 100}) 5%,\n            rgba(0, 0, 0, 0) 100%)`;\n\n    this.hardInnerShadow.style.left = rect.left + rect.width / 2 + 'px';\n    this.hardInnerShadow.style.transformOrigin = '0 0';\n\n    this.hardInnerShadow.style.transform =\n      (this.getDirection() === FlipDirection.FORWARD && this.shadow.progress > 100) ||\n        (this.getDirection() === FlipDirection.BACK && this.shadow.progress <= 100)\n        ? 'translate3d(0, 0, 0)'\n        : 'translate3d(0, 0, 0) rotateY(180deg)';\n  }\n\n  /**\n   * Draw outer shadow to the hard page\n   */\n  private drawHardOuterShadow(): void {\n    const rect = this.getRect();\n\n    const progress =\n      this.shadow.progress > 100 ? 200 - this.shadow.progress : this.shadow.progress;\n\n    let shadowSize = ((100 - progress) * (2.5 * rect.pageWidth)) / 100 + 20;\n    if (shadowSize > rect.pageWidth) shadowSize = rect.pageWidth;\n\n    // let newStyle = `\n    //         display: block;\n    //         z-index: ${(this.getSettings().startZIndex + 4).toString(10)};\n    //         width: ${shadowSize}px;\n    //         height: ${rect.height}px;\n    //         background: linear-gradient(to left, rgba(0, 0, 0, ${this.shadow.opacity\n    //   }) 5%, rgba(0, 0, 0, 0) 100%);\n    //         left: ${rect.left + rect.width / 2}px;\n    //         transform-origin: 0 0;\n    //     `;\n\n    // newStyle +=\n    //   (this.getDirection() === FlipDirection.FORWARD && this.shadow.progress > 100) ||\n    //     (this.getDirection() === FlipDirection.BACK && this.shadow.progress <= 100)\n    //     ? `transform: translate3d(0, 0, 0) rotateY(180deg);`\n    //     : `transform: translate3d(0, 0, 0);`;\n\n    // this.hardShadow.style.cssText = newStyle;\n\n    this.hardShadow.style.display = 'block';\n    this.hardShadow.style.zIndex = (this.getSettings().startZIndex + 4).toString(10);\n    this.hardShadow.style.width = shadowSize + 'px';\n    this.hardShadow.style.height = rect.height + 'px';\n    this.hardShadow.style.background = `linear-gradient(to left,\n            rgba(0, 0, 0, ${this.shadow.opacity}) 5%, rgba(0, 0, 0, 0) 100%)`;\n\n    this.hardShadow.style.left = rect.left + rect.width / 2 + 'px';\n    this.hardShadow.style.transformOrigin = '0 0';\n\n    this.hardShadow.style.transform =\n      (this.getDirection() === FlipDirection.FORWARD && this.shadow.progress > 100) ||\n        (this.getDirection() === FlipDirection.BACK && this.shadow.progress <= 100)\n        ? 'translate3d(0, 0, 0) rotateY(180deg)'\n        : 'translate3d(0, 0, 0)';\n  }\n\n  /**\n   * Draw inner shadow to the soft page\n   */\n  private drawInnerShadow(): void {\n    const rect = this.getRect();\n\n    const innerShadowSize = (this.shadow.width * 3) / 4;\n    const shadowTranslate = this.getDirection() === FlipDirection.FORWARD ? innerShadowSize : 0;\n\n    const shadowDirection =\n      this.getDirection() === FlipDirection.FORWARD ? 'to left' : 'to right';\n\n    const shadowPos = this.convertToGlobal(this.shadow.pos);\n\n    const angle = this.shadow.angle + (3 * Math.PI) / 2;\n\n    const clip = [\n      this.pageRect.topLeft,\n      this.pageRect.topRight,\n      this.pageRect.bottomRight,\n      this.pageRect.bottomLeft,\n    ];\n\n    let polygon = 'polygon( ';\n    for (const p of clip) {\n      let g =\n        this.getDirection() === FlipDirection.BACK\n          ? {\n            x: -p.x + this.shadow.pos.x,\n            y: p.y - this.shadow.pos.y,\n          }\n          : {\n            x: p.x - this.shadow.pos.x,\n            y: p.y - this.shadow.pos.y,\n          };\n\n      g = Helper.GetRotatedPoint(g, { x: shadowTranslate, y: 100 }, angle);\n\n      polygon += g.x + 'px ' + g.y + 'px, ';\n    }\n    polygon = polygon.slice(0, -2);\n    polygon += ')';\n\n    // const newStyle = `\n    //         display: block;\n    //         z-index: ${(this.getSettings().startZIndex + 10).toString(10)};\n    //         width: ${innerShadowSize}px;\n    //         height: ${rect.height * 2}px;\n    //         background: linear-gradient(${shadowDirection},\n    //             rgba(0, 0, 0, ${this.shadow.opacity}) 5%,\n    //             rgba(0, 0, 0, 0.05) 15%,\n    //             rgba(0, 0, 0, ${this.shadow.opacity}) 35%,\n    //             rgba(0, 0, 0, 0) 100%);\n    //         transform-origin: ${shadowTranslate}px 100px;\n    //         transform: translate3d(${shadowPos.x - shadowTranslate}px, ${shadowPos.y - 100\n    //   }px, 0) rotate(${angle}rad);\n    //         clip-path: ${polygon};\n    //         -webkit-clip-path: ${polygon};\n    //     `;\n\n    // this.innerShadow.style.cssText = newStyle;\n\n    this.innerShadow.style.display = 'block';\n    this.innerShadow.style.zIndex = (this.getSettings().startZIndex + 10).toString(10);\n    this.innerShadow.style.width = innerShadowSize + 'px';\n    this.innerShadow.style.height = rect.height * 2 + 'px';\n    this.innerShadow.style.background = `linear-gradient(${shadowDirection},\n            rgba(0, 0, 0, ${this.shadow.opacity}) 5%,\n            rgba(0, 0, 0, 0.05) 15%,\n            rgba(0, 0, 0, ${this.shadow.opacity}) 35%,\n            rgba(0, 0, 0, 0) 100%)`;\n\n    this.innerShadow.style.transformOrigin = shadowTranslate + 'px 100px';\n    this.innerShadow.style.transform = `translate3d(${shadowPos.x - shadowTranslate}px, ${shadowPos.y - 100\n      }px, 0) rotate(${angle}rad)`;\n    this.innerShadow.style.clipPath = polygon;\n    this.innerShadow.style.setProperty('-webkit-clip-path', polygon);\n  }\n\n  /**\n   * Draw outer shadow to the soft page\n   */\n  private drawOuterShadow(): void {\n    const rect = this.getRect();\n\n    const shadowPos = this.convertToGlobal({ x: this.shadow.pos.x, y: this.shadow.pos.y });\n\n    const angle = this.shadow.angle + (3 * Math.PI) / 2;\n    const shadowTranslate = this.getDirection() === FlipDirection.BACK ? this.shadow.width : 0;\n\n    const shadowDirection =\n      this.getDirection() === FlipDirection.FORWARD ? 'to right' : 'to left';\n\n    const clip = [\n      { x: 0, y: 0 },\n      { x: rect.pageWidth, y: 0 },\n      { x: rect.pageWidth, y: rect.height },\n      { x: 0, y: rect.height },\n    ];\n\n    let polygon = 'polygon( ';\n    for (const p of clip) {\n      if (p !== null) {\n        let g =\n          this.getDirection() === FlipDirection.BACK\n            ? {\n              x: -p.x + this.shadow.pos.x,\n              y: p.y - this.shadow.pos.y,\n            }\n            : {\n              x: p.x - this.shadow.pos.x,\n              y: p.y - this.shadow.pos.y,\n            };\n\n        g = Helper.GetRotatedPoint(g, { x: shadowTranslate, y: 100 }, angle);\n\n        polygon += g.x + 'px ' + g.y + 'px, ';\n      }\n    }\n\n    polygon = polygon.slice(0, -2);\n    polygon += ')';\n\n    // const newStyle = `\n    //         display: block;\n    //         z-index: ${(this.getSettings().startZIndex + 10).toString(10)};\n    //         width: ${this.shadow.width}px;\n    //         height: ${rect.height * 2}px;\n    //         background: linear-gradient(${shadowDirection}, rgba(0, 0, 0, ${this.shadow.opacity\n    //   }), rgba(0, 0, 0, 0));\n    //         transform-origin: ${shadowTranslate}px 100px;\n    //         transform: translate3d(${shadowPos.x - shadowTranslate}px, ${shadowPos.y - 100\n    //   }px, 0) rotate(${angle}rad);\n    //         clip-path: ${polygon};\n    //         -webkit-clip-path: ${polygon};\n    //     `;\n\n    // this.outerShadow.style.cssText = newStyle;\n\n    this.outerShadow.style.display = 'block';\n    this.outerShadow.style.zIndex = (this.getSettings().startZIndex + 10).toString(10);\n    this.outerShadow.style.width = this.shadow.width + 'px';\n    this.outerShadow.style.height = rect.height * 2 + 'px';\n    this.outerShadow.style.background = `linear-gradient(${shadowDirection}, rgba(0, 0, 0, ${this.shadow.opacity}), rgba(0, 0, 0, 0))`;\n    this.outerShadow.style.transformOrigin = shadowTranslate + 'px 100px';\n    this.outerShadow.style.transform = `translate3d(${shadowPos.x - shadowTranslate}px, ${shadowPos.y - 100\n      }px, 0) rotate(${angle}rad)`;\n    this.outerShadow.style.clipPath = polygon;\n    this.outerShadow.style.setProperty('-webkit-clip-path', polygon);\n  }\n\n  /**\n   * Draw left static page\n   */\n  private drawLeftPage(): void {\n    if (this.orientation === Orientation.PORTRAIT || this.leftPage === null) return;\n\n    if (\n      this.direction === FlipDirection.BACK &&\n      this.flippingPage !== null &&\n      this.flippingPage.getDrawingDensity() === PageDensity.HARD\n    ) {\n      (this.leftPage as HTMLPage).getElement().style.zIndex = (\n        this.getSettings().startZIndex + 5\n      ).toString(10);\n\n      this.leftPage.setHardDrawingAngle(180 + this.flippingPage.getHardAngle());\n      this.leftPage.draw(this.flippingPage.getDrawingDensity());\n    } else {\n      this.leftPage.simpleDraw(PageOrientation.LEFT);\n    }\n  }\n\n  /**\n   * Draw right static page\n   */\n  private drawRightPage(): void {\n    if (this.rightPage === null) return;\n\n    if (\n      this.direction === FlipDirection.FORWARD &&\n      this.flippingPage !== null &&\n      this.flippingPage.getDrawingDensity() === PageDensity.HARD\n    ) {\n      (this.rightPage as HTMLPage).getElement().style.zIndex = (\n        this.getSettings().startZIndex + 5\n      ).toString(10);\n\n      this.rightPage.setHardDrawingAngle(180 + this.flippingPage.getHardAngle());\n      this.rightPage.draw(this.flippingPage.getDrawingDensity());\n    } else {\n      this.rightPage.simpleDraw(PageOrientation.RIGHT);\n    }\n  }\n\n  /**\n   * Draw the next page at the time of flipping\n   */\n  private drawBottomPage(): void {\n    if (this.bottomPage === null) return;\n\n    const tempDensity =\n      this.flippingPage != null ? this.flippingPage.getDrawingDensity() : null;\n\n    if (!(this.orientation === Orientation.PORTRAIT && this.direction === FlipDirection.BACK)) {\n      (this.bottomPage as HTMLPage).getElement().style.zIndex = (\n        this.getSettings().startZIndex + 3\n      ).toString(10);\n\n      this.bottomPage.draw(tempDensity);\n    }\n  }\n\n  protected drawFrame(): void {\n    this.clear();\n\n    this.drawLeftPage();\n\n    this.drawRightPage();\n\n    this.drawBottomPage();\n\n    if (this.flippingPage != null) {\n      (this.flippingPage as HTMLPage).getElement().style.zIndex = (\n        this.getSettings().startZIndex + 5\n      ).toString(10);\n\n      this.flippingPage.draw();\n    }\n\n    if (this.shadow != null && this.flippingPage !== null) {\n      if (this.flippingPage.getDrawingDensity() === PageDensity.SOFT) {\n        this.drawOuterShadow();\n        this.drawInnerShadow();\n      } else {\n        this.drawHardOuterShadow();\n        this.drawHardInnerShadow();\n      }\n    }\n  }\n\n  private clear(): void {\n    for (const page of this.app.getPageCollection().getPages()) {\n      if (\n        page !== this.leftPage &&\n        page !== this.rightPage &&\n        page !== this.flippingPage &&\n        page !== this.bottomPage\n      ) {\n        (page as HTMLPage).getElement().style.display = 'none';\n      }\n\n      if (page.getTemporaryCopy() !== this.flippingPage) {\n        page.hideTemporaryCopy();\n      }\n    }\n  }\n\n  public update(): void {\n    super.update();\n\n    if (this.rightPage !== null) {\n      this.rightPage.setOrientation(PageOrientation.RIGHT);\n      (this.rightPage as HTMLPage).clearSaved();\n    }\n\n    if (this.leftPage !== null) {\n      this.leftPage.setOrientation(PageOrientation.LEFT);\n      (this.leftPage as HTMLPage).clearSaved();\n    }\n  }\n}\n","import { PageCollection } from './Collection/PageCollection';\nimport { ImagePageCollection } from './Collection/ImagePageCollection';\nimport { HTMLPageCollection } from './Collection/HTMLPageCollection';\nimport { PageRect, Point } from './BasicTypes';\nimport { Flip, FlipCorner, FlippingState } from './Flip/Flip';\nimport { Orientation, Render } from './Render/Render';\nimport { CanvasRender } from './Render/CanvasRender';\nimport { HTMLUI } from './UI/HTMLUI';\nimport { CanvasUI } from './UI/CanvasUI';\nimport { Helper } from './Helper';\nimport { Page } from './Page/Page';\nimport { EventObject } from './Event/EventObject';\nimport { HTMLRender } from './Render/HTMLRender';\nimport { FlipSetting, Settings } from './Settings';\nimport { UI } from './UI/UI';\n\nimport './Style/stPageFlip.css';\n\n/**\n * Class representing a main PageFlip object\n *\n * @extends EventObject\n */\nexport class PageFlip extends EventObject {\n  private mousePosition: Point;\n  private isUserTouch = false;\n  private isUserMove = false;\n\n  private readonly setting: FlipSetting = null;\n  private readonly block: HTMLElement; // Root HTML Element\n\n  private pages: PageCollection = null;\n  private flipController: Flip;\n  private render: Render;\n\n  private ui: UI;\n\n  /**\n   * Create a new PageFlip instance\n   *\n   * @constructor\n   * @param {HTMLElement} inBlock - Root HTML Element\n   * @param {Object} setting - Configuration object\n   */\n  constructor(inBlock: HTMLElement, setting: Partial<FlipSetting>) {\n    super();\n\n    this.setting = new Settings().getSettings(setting);\n    this.block = inBlock;\n  }\n\n  /**\n   * Destructor. Remove a root HTML element and all event handlers\n   */\n  public destroy(): void {\n    this.ui.destroy();\n    this.block.remove();\n  }\n\n  /**\n   * Update the render area. Re-show current page.\n   */\n  public update(): void {\n    this.render.update();\n    this.pages.show();\n  }\n\n  /**\n   * Load pages from images on the Canvas mode\n   *\n   * @param {string[]} imagesHref - List of paths to images\n   */\n  public loadFromImages(imagesHref: string[]): void {\n    this.ui = new CanvasUI(this.block, this, this.setting);\n\n    const canvas = (this.ui as CanvasUI).getCanvas();\n    this.render = new CanvasRender(this, this.setting, canvas);\n\n    this.flipController = new Flip(this.render, this);\n\n    this.pages = new ImagePageCollection(this, this.render, imagesHref);\n    this.pages.load();\n\n    this.render.start();\n\n    this.pages.show(this.setting.startPage);\n\n    // safari fix\n    setTimeout(() => {\n      this.ui.update();\n      this.trigger('init', this, {\n        page: this.setting.startPage,\n        mode: this.render.getOrientation(),\n      });\n    }, 1);\n  }\n\n  /**\n   * Load pages from HTML elements on the HTML mode\n   *\n   * @param {(NodeListOf<HTMLElement>|HTMLElement[])} items - List of pages as HTML Element\n   */\n  public loadFromHTML(items: NodeListOf<HTMLElement> | HTMLElement[]): void {\n    this.ui = new HTMLUI(this.block, this, this.setting, items);\n\n    this.render = new HTMLRender(this, this.setting, this.ui.getDistElement());\n\n    this.flipController = new Flip(this.render, this);\n\n    this.pages = new HTMLPageCollection(this, this.render, this.ui.getDistElement(), items);\n    this.pages.load();\n\n    this.render.start();\n\n    this.pages.show(this.setting.startPage);\n\n    // safari fix\n    setTimeout(() => {\n      this.ui.update();\n      this.trigger('init', this, {\n        page: this.setting.startPage,\n        mode: this.render.getOrientation(),\n      });\n    }, 1);\n  }\n\n  /**\n   * Update current pages from images\n   *\n   * @param {string[]} imagesHref - List of paths to images\n   */\n  public updateFromImages(imagesHref: string[]): void {\n    const current = this.pages.getCurrentPageIndex();\n\n    this.pages.destroy();\n    this.pages = new ImagePageCollection(this, this.render, imagesHref);\n    this.pages.load();\n\n    this.pages.show(current);\n    this.trigger('update', this, {\n      page: current,\n      mode: this.render.getOrientation(),\n    });\n  }\n\n  /**\n   * Update current pages from HTML\n   *\n   * @param {(NodeListOf<HTMLElement>|HTMLElement[])} items - List of pages as HTML Element\n   */\n  public updateFromHtml(items: NodeListOf<HTMLElement> | HTMLElement[]): void {\n    const current = this.pages.getCurrentPageIndex();\n\n    this.pages.destroy();\n    this.pages = new HTMLPageCollection(this, this.render, this.ui.getDistElement(), items);\n    this.pages.load();\n    (this.ui as HTMLUI).updateItems(items);\n    this.render.reload();\n\n    this.pages.show(current);\n    this.trigger('update', this, {\n      page: current,\n      mode: this.render.getOrientation(),\n    });\n  }\n\n  /**\n   * Clear pages from HTML (remove to initinalState)\n   */\n  public clear(): void {\n    this.pages.destroy();\n    (this.ui as HTMLUI).clear();\n  }\n\n  /**\n   * Turn to the previous page (without animation)\n   */\n  public turnToPrevPage(): void {\n    this.pages.showPrev();\n  }\n\n  /**\n   * Turn to the next page (without animation)\n   */\n  public turnToNextPage(): void {\n    this.pages.showNext();\n  }\n\n  /**\n   * Turn to the specified page number (without animation)\n   *\n   * @param {number} page - New page number\n   */\n  public turnToPage(page: number): void {\n    this.pages.show(page);\n  }\n\n  /**\n   * Turn to the next page (with animation)\n   *\n   * @param {FlipCorner} corner - Active page corner when turning\n   */\n  public flipNext(corner: FlipCorner = FlipCorner.TOP): void {\n    this.flipController.flipNext(corner);\n  }\n\n  /**\n   * Turn to the prev page (with animation)\n   *\n   * @param {FlipCorner} corner - Active page corner when turning\n   */\n  public flipPrev(corner: FlipCorner = FlipCorner.TOP): void {\n    this.flipController.flipPrev(corner);\n  }\n\n  /**\n   * Turn to the specified page number (with animation)\n   *\n   * @param {number} page - New page number\n   * @param {FlipCorner} corner - Active page corner when turning\n   */\n  public flip(page: number, corner: FlipCorner = FlipCorner.TOP): void {\n    this.flipController.flipToPage(page, corner);\n  }\n\n  /**\n   * Call a state change event trigger\n   *\n   * @param {FlippingState} newState - New  state of the object\n   */\n  public updateState(newState: FlippingState): void {\n    this.trigger('changeState', this, newState);\n  }\n\n  /**\n   * Call a page number change event trigger\n   *\n   * @param {number} newPage - New page Number\n   */\n  public updatePageIndex(newPage: number): void {\n    this.trigger('flip', this, newPage);\n  }\n\n  /**\n   * Call a page orientation change event trigger. Update UI and rendering area\n   *\n   * @param {Orientation} newOrientation - New page orientation (portrait, landscape)\n   */\n  public updateOrientation(newOrientation: Orientation): void {\n    this.ui.setOrientationStyle(newOrientation);\n    this.update();\n    this.trigger('changeOrientation', this, newOrientation);\n  }\n\n  /**\n   * Get the total number of pages in a book\n   *\n   * @returns {number}\n   */\n  public getPageCount(): number {\n    return this.pages.getPageCount();\n  }\n\n  /**\n   * Get the index of the current page in the page list (starts at 0)\n   *\n   * @returns {number}\n   */\n  public getCurrentPageIndex(): number {\n    return this.pages.getCurrentPageIndex();\n  }\n\n  /**\n   * Get page from collection by number\n   *\n   * @param {number} pageIndex\n   * @returns {Page}\n   */\n  public getPage(pageIndex: number): Page {\n    return this.pages.getPage(pageIndex);\n  }\n\n  /**\n   * Get the current rendering object\n   *\n   * @returns {Render}\n   */\n  public getRender(): Render {\n    return this.render;\n  }\n\n  /**\n   * Get current object responsible for flipping\n   *\n   * @returns {Flip}\n   */\n  public getFlipController(): Flip {\n    return this.flipController;\n  }\n\n  /**\n   * Get current page orientation\n   *\n   * @returns {Orientation} Сurrent orientation: portrait or landscape\n   */\n  public getOrientation(): Orientation {\n    return this.render.getOrientation();\n  }\n\n  /**\n   * Get current book sizes and position\n   *\n   * @returns {PageRect}\n   */\n  public getBoundsRect(): PageRect {\n    return this.render.getRect();\n  }\n\n  /**\n   * Get configuration object\n   *\n   * @returns {FlipSetting}\n   */\n  public getSettings(): FlipSetting {\n    return this.setting;\n  }\n\n  /**\n   * Get UI object\n   *\n   * @returns {UI}\n   */\n  public getUI(): UI {\n    return this.ui;\n  }\n\n  /**\n   * Get current flipping state\n   *\n   * @returns {FlippingState}\n   */\n  public getState(): FlippingState {\n    return this.flipController.getState();\n  }\n\n  /**\n   * Get page collection\n   *\n   * @returns {PageCollection}\n   */\n  public getPageCollection(): PageCollection {\n    return this.pages;\n  }\n\n  /**\n   * Start page turning. Called when a user clicks or touches\n   *\n   * @param {Point} pos - Touch position in coordinates relative to the book\n   */\n  public startUserTouch(pos: Point): void {\n    this.mousePosition = pos; // Save touch position\n    this.isUserTouch = true;\n    this.isUserMove = false;\n  }\n\n  /**\n   * Called when a finger / mouse moves\n   *\n   * @param {Point} pos - Touch position in coordinates relative to the book\n   * @param {boolean} isTouch - True if there was a touch event, not a mouse click\n   */\n  public userMove(pos: Point, isTouch: boolean): void {\n    if (!this.isUserTouch && !isTouch && this.setting.showPageCorners) {\n      this.flipController.showCorner(pos); // fold Page Corner\n    } else if (this.isUserTouch) {\n      if (Helper.GetDistanceBetweenTwoPoint(this.mousePosition, pos) > 5) {\n        this.isUserMove = true;\n        this.flipController.fold(pos);\n      }\n    }\n  }\n\n  /**\n   * Сalled when the user has stopped touching\n   *\n   * @param {Point} pos - Touch end position in coordinates relative to the book\n   * @param {boolean} isSwipe - true if there was a mobile swipe event\n   */\n  public userStop(pos: Point, isSwipe = false): void {\n    if (this.isUserTouch) {\n      this.isUserTouch = false;\n\n      if (!isSwipe) {\n        if (!this.isUserMove) this.flipController.flip(pos);\n        else this.flipController.stopMove();\n      }\n    }\n  }\n}\n","import React, {\n  ReactElement,\n  useCallback,\n  useEffect,\n  useImperativeHandle,\n  useRef,\n  useState,\n} from 'react';\n\nimport { PageFlip } from '../../PageFlip';\nimport { IFlipSetting, IEventProps } from './settings';\n\ninterface IProps extends IFlipSetting, IEventProps {\n  className: string;\n  style: React.CSSProperties;\n  children: React.ReactNode;\n  renderOnlyPageLengthChange?: boolean;\n}\n\nconst HTMLFlipBookForward = React.forwardRef(\n  (props: IProps, ref: React.MutableRefObject<PageFlip>) => {\n    const htmlElementRef = useRef<HTMLDivElement>(null);\n    const childRef = useRef<HTMLElement[]>([]);\n    const pageFlip = useRef<PageFlip>();\n\n    const [pages, setPages] = useState<ReactElement[]>([]);\n\n    // useImperativeHandle(ref, () => ({\n    //   pageFlip: () => pageFlip.current,\n    // }));\n    useImperativeHandle(ref, () => pageFlip.current);\n\n    const refreshOnPageDelete = useCallback(() => {\n      if (pageFlip.current) {\n        pageFlip.current.clear();\n      }\n    }, []);\n\n    const removeHandlers = useCallback(() => {\n      const flip = pageFlip.current;\n\n      if (flip) {\n        flip.off('flip');\n        flip.off('changeOrientation');\n        flip.off('changeState');\n        flip.off('init');\n        flip.off('update');\n      }\n    }, []);\n\n    useEffect(() => {\n      childRef.current = [];\n\n      if (props.children) {\n        const childList = React.Children.map(props.children, (child) => {\n          return React.cloneElement(child as ReactElement, {\n            ref: (dom) => {\n              if (dom) {\n                childRef.current.push(dom);\n              }\n            },\n          });\n        });\n\n        if (!props.renderOnlyPageLengthChange || pages.length !== childList.length) {\n          if (childList.length < pages.length) {\n            refreshOnPageDelete();\n          }\n\n          setPages(childList);\n        }\n      }\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [props.children]);\n\n    useEffect(() => {\n      const setHandlers = () => {\n        const flip = pageFlip.current;\n\n        if (flip) {\n          if (props.onFlip) {\n            flip.on('flip', (e: unknown) => props.onFlip(e));\n          }\n\n          if (props.onChangeOrientation) {\n            flip.on('changeOrientation', (e: unknown) => props.onChangeOrientation(e));\n          }\n\n          if (props.onChangeState) {\n            flip.on('changeState', (e: unknown) => props.onChangeState(e));\n          }\n\n          if (props.onInit) {\n            flip.on('init', (e: unknown) => props.onInit(e));\n          }\n\n          if (props.onUpdate) {\n            flip.on('update', (e: unknown) => props.onUpdate(e));\n          }\n        }\n      };\n\n      if (pages.length > 0 && childRef.current.length > 0) {\n        removeHandlers();\n\n        if (htmlElementRef.current && !pageFlip.current) {\n          pageFlip.current = new PageFlip(htmlElementRef.current, props);\n        }\n\n        if (!pageFlip.current.getFlipController()) {\n          pageFlip.current.loadFromHTML(childRef.current);\n        } else {\n          pageFlip.current.updateFromHtml(childRef.current);\n        }\n\n        setHandlers();\n      }\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [pages]);\n\n    return (\n      <div ref={htmlElementRef} className={props.className} style={props.style}>\n        {pages}\n      </div>\n    );\n  }\n);\n\nexport const HTMLFlipBook = React.memo(HTMLFlipBookForward);\n","import { HTMLFlipBook } from './html-flip-book';\n\nexport default HTMLFlipBook;\n","import React from 'react'\r\nimport './Page.scss';\r\n\r\nconst Page = React.forwardRef((props, ref) => {\r\n  switch (props.type) {\r\n    case 'temp':\r\n      return <div className='page' ref={ref} data-density='soft'>\r\n        <div className=\"page-content\">\r\n          &nbsp;\r\n          <div className='page-footer'>{isNaN(props.pageNumber) ? '' : props.pageNumber}</div>\r\n        </div>\r\n      </div>;\r\n    case 'cover':\r\n      return (\r\n        <div\r\n          className={'page page-cover page-cover-' + props.pos}\r\n          ref={ref}\r\n          data-density='soft'\r\n        >\r\n          {/* {(props.bookmark === true) ?\r\n            <img\r\n              className='bookmark'\r\n              src={process.env.PUBLIC_URL + '/bookmark.png'}\r\n              style={{ filter: 'invert(10%) sepia(96%) saturate(6344%) hue-rotate(1deg) brightness(121%) contrast(113%)' }}\r\n              alt=\"könyvjelző\"\r\n              title='Kinyitás a könyvjelzőnél'\r\n              onClick={() => props.onBookmark()}\r\n            />\r\n            : null\r\n          } */}\r\n          <div className='page-content'>\r\n            <h2>{props.pageTitle}</h2>\r\n          </div>\r\n        </div>\r\n      );\r\n\r\n    case 'html':\r\n      return <div className={'page ' + (props.no_animation ? 'no-animation' : '')} ref={ref} data-density='soft'>\r\n        <div className=\"page-content\">\r\n          {(props.pageTitle !== undefined) ?\r\n            <h2 className='page-header'>{props.pageTitle}</h2> : null\r\n          }\r\n          <div className=\"page-text\">\r\n            {(props.content.image !== null && props.content.image !== '') ?\r\n              <img style={{ margin: '1%', float: 'left' }} src={process.env.PUBLIC_URL + '/' + props.content.image} width='40%' alt=\"\"></img> : null\r\n            }\r\n            <div dangerouslySetInnerHTML={{ __html: props.content.html.outerHTML }}></div>\r\n          </div>\r\n          <div className='page-footer'>{isNaN(props.pageNumber) ? '' : props.pageNumber}</div>\r\n        </div>\r\n      </div>;\r\n\r\n    case 'contents':\r\n    case 'chapter':\r\n    case 'image':\r\n      return (\r\n        <div className={'page ' + (props.no_animation ? 'no-animation' : '')} ref={ref} data-density='soft'>\r\n          <div className='page-content'>\r\n            <div>\r\n              {(props.pageTitle !== undefined) ?\r\n                <h2 className='page-header'>{props.pageTitle}</h2> : null\r\n              }\r\n              {(props.image !== undefined) ?\r\n                <div className='page-image'>\r\n                  <figure>\r\n                    <img\r\n                      alt={props.imageCaption}\r\n                      src={props.image}\r\n                      onClick={showFullImage}\r\n                      onLoad={setDimensions}\r\n                    ></img>\r\n                    <figcaption>{props.imageCaption}</figcaption>\r\n                  </figure>\r\n                </div>\r\n                : null\r\n              }\r\n            </div>\r\n            {(props.children) ? <div className='page-text'>{props.children}</div> : null}\r\n            <div className='page-footer'>{isNaN(props.pageNumber) ? '' : props.pageNumber}</div>\r\n          </div>\r\n        </div >\r\n      );\r\n\r\n    default:\r\n      throw new Error('unrecognizable or missing page type');\r\n  }\r\n\r\n\r\n  function setDimensions(e) {\r\n    e.target.style = (e.target.width > e.target.height) ? 'width: 100%' : 'height: 100%';\r\n  }\r\n\r\n  function showFullImage(e) {\r\n    console.log('props', props);\r\n    console.log('ref', ref);\r\n    e.target.requestFullscreen().then(() => {\r\n\r\n    });\r\n  }\r\n});\r\n\r\nexport { Page };","// https://github.com/thecreazy/create-a-modern-javascript-router/blob/master/src/Router.js\r\nclass Router {\r\n  routes = [];\r\n\r\n  mode = null;\r\n\r\n  root = '/';\r\n\r\n  constructor(options) {\r\n    this.mode = window.history.pushState ? 'history' : 'hash';\r\n    if (options.mode) this.mode = options.mode;\r\n    if (options.root) this.root = options.root;\r\n    this.listen();\r\n  }\r\n\r\n  add = (path, cb) => {\r\n    this.routes.push({ path, cb });\r\n    return this;\r\n  };\r\n\r\n  remove = path => {\r\n    for (let i = 0; i < this.routes.length; i += 1) {\r\n      if (this.routes[i].path === path) {\r\n        this.routes.slice(i, 1);\r\n        return this;\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  flush = () => {\r\n    this.routes = [];\r\n    return this;\r\n  };\r\n\r\n  clearSlashes = path =>\r\n    path\r\n      .toString()\r\n      .replace(/\\/$/, '')\r\n      .replace(/^\\//, '');\r\n\r\n  getFragment = () => {\r\n    let fragment = '';\r\n    if (this.mode === 'history') {\r\n      fragment = this.clearSlashes(decodeURI(window.location.pathname + window.location.search));\r\n      fragment = fragment.replace(/\\?(.*)$/, '');\r\n      fragment = this.root !== '/' ? fragment.replace(this.root, '') : fragment;\r\n    } else {\r\n      const match = window.location.href.match(/#(.*)$/);\r\n      fragment = match ? match[1] : '';\r\n    }\r\n    return this.clearSlashes(fragment);\r\n  };\r\n\r\n  navigate = (path = '') => {\r\n    if (this.mode === 'history') {\r\n      window.history.pushState(null, null, this.root + this.clearSlashes(path));\r\n    } else {\r\n      window.location.href = `${window.location.href.replace(/#(.*)$/, '')}#${path}`;\r\n    }\r\n    return this;\r\n  };\r\n\r\n  listen = () => {\r\n    clearInterval(this.interval);\r\n    this.interval = setInterval(this.interval, 50);\r\n  };\r\n\r\n  interval = () => {\r\n    if (this.current === this.getFragment()) return;\r\n    this.current = this.getFragment();\r\n\r\n    this.routes.some(route => {\r\n      const match = this.current.match(route.path);\r\n      if (match) {\r\n        match.shift();\r\n        route.cb.apply({}, match);\r\n        return match;\r\n      }\r\n      return false;\r\n    });\r\n  };\r\n}\r\n\r\nexport default Router;","/* eslint-disable no-restricted-globals */\r\nimport { useState, useEffect, useRef } from 'react'\r\nimport HTMLFlipBook from '../PageFlip/react-pageflip';\r\n// import HTMLFlipBook from 'react-pageflip';\r\nimport './ImageBook.scss';\r\nimport { Page } from './Page/Page';\r\nimport Router from '../Router';\r\n\r\nconst ImageBook = () => {\r\n  const [language, setLanguage] = useState(0);\r\n  // const [renderedPages, setRenderedPages] = useState([<Page type=\"cover\" key=\"1\"></Page>, <Page type=\"cover\" key=\"2\"></Page>, <Page type=\"cover\" key=\"3\"></Page>, <Page type=\"cover\" key=\"4\"></Page>, <Page type=\"cover\" key=\"5\"></Page>, <Page type=\"cover\" key=\"6\"></Page>,]);\r\n  const [renderedPages, setRenderedPages] = useState([]);\r\n  const [pageMap, setPageMap] = useState();\r\n  const [pageData, setPageData] = useState({\r\n    chapters: [],\r\n    pageOfContents: 0,\r\n    pages: []\r\n  });\r\n  // const [routingStrategy, setRoutingStrategy] = useState('hash');\r\n  const [routingStrategy] = useState('hash')\r\n  // const [bookmark, setBookmark] = useState();\r\n  const [page, setPage] = useState();\r\n  // const [orientation, setOrientation] = useState('landscape');\r\n  // const [orientation] = useState('landscape');\r\n  // const [bookstate] = useState('read');\r\n  // const [totalPage, setTotalPage] = useState(0);\r\n  const [router, setRouter] = useState();\r\n  const flipBook = useRef();\r\n\r\n  useEffect(() => {\r\n    fetch(process.env.PUBLIC_URL + '/pages.json', {\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'Accept': 'application/json'\r\n      }\r\n    }).then((res) => {\r\n      res.json().then(pageArray => {\r\n        // console.log(res);\r\n        // console.log(window.innerWidth);\r\n        // const isMobile = window.innerWidth < 1440;\r\n\r\n        const _pageData = preparePages(pageArray);\r\n\r\n        _pageData.pages[_pageData.pageOfContents - 1] = <Page\r\n          type='contents'\r\n          key={_pageData.pageOfContents - 1}\r\n          pageNumber={_pageData.pageOfContents - 1}\r\n          pageTitle={_pageData.pages[_pageData.pageOfContents - 1].props.pageTitle}\r\n        >\r\n          <ul className='contents'>\r\n            {_pageData.chapters.map((chapter, i) =>\r\n              <li key={i}><a href={((routingStrategy === 'hash') ? '#/' : '') + String(chapter.pagenumber)} onClick={navigateToPage}>{chapter.pagetitle[language]}</a></li>\r\n            )}\r\n          </ul>\r\n        </Page>;\r\n\r\n        const initialNumOfRenderedPages = 3;\r\n        const _renderedPages = _pageData.pages.slice(0, initialNumOfRenderedPages).concat(_pageData.pages.slice(initialNumOfRenderedPages, _pageData.pages.length).map(page => <Page type=\"temp\" key={page.props.pageNumber} pageNumber={page.props.pageNumber}></Page>));\r\n\r\n\r\n        const _pageMap = new Array(initialNumOfRenderedPages).reduce((res, page, i) => {\r\n          res[i] = true;\r\n          return res;\r\n        }, {});\r\n\r\n        for (let i = 0; i < initialNumOfRenderedPages; i++) {\r\n          _pageMap[i] = true;\r\n        }\r\n\r\n        console.log('pageMap', _pageMap);\r\n\r\n        const _router = new Router({ mode: routingStrategy });\r\n        // console.log(router.getFragment());\r\n\r\n        // const page = this.setupRoute();\r\n        let _page = 0;\r\n        if (isNumeric(_router.getFragment())) {\r\n          _page = Number(_router.getFragment());\r\n        } else {\r\n          _router.navigate('/0');\r\n        }\r\n        // const _bookmark = Number(localStorage.getItem('bookmark'));\r\n\r\n        let update = updateRenderedPages(_renderedPages, _pageMap, _pageData);\r\n        setRenderedPages(() => update.updatedRenderedPages);\r\n        setPageMap(() => update.updatedPageMap);\r\n\r\n        // setRenderedPages(_renderedPages);\r\n        // setPageMap(_pageMap);\r\n        setPageData(_pageData);\r\n        setRouter(_router);\r\n        setPage(_page);\r\n        // setBookmark(_bookmark);\r\n\r\n        // updateRenderedPages();\r\n      }, err => {\r\n        alert('Nem sikerült betölteni az oldalt!');\r\n        console.error(err);\r\n      });\r\n    }, err => {\r\n      alert('Nem sikerült betölteni az oldalt.');\r\n      console.error(err);\r\n    });\r\n    return () => {\r\n    }\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [language]);\r\n\r\n  useEffect(() => {\r\n    // if (tempCounter < 2) {\r\n    //   setTempCounter(tempCounter => tempCounter + 1);\r\n    //   return;\r\n    // }\r\n    const flipToPage = () => {\r\n      // console.log('state', { language, renderedPages, pageData, routingStrategy, bookmark, page, router, flipBook });\r\n      if (renderedPages.length >= page) {\r\n        // flipBook.current.pageFlip().flip(Number(page));\r\n        flipBook.current.flip(Number(page));\r\n\r\n        if (router !== undefined) {\r\n          router.navigate('/' + page);\r\n        }\r\n      } else {\r\n        setPage(0);\r\n      }\r\n    };\r\n\r\n    if (flipBook.current !== undefined && pageMap !== null && renderedPages.length >= page) {\r\n      let update = updateRenderedPages(renderedPages, pageMap, pageData);\r\n      setRenderedPages(() => update.updatedRenderedPages);\r\n      setPageMap(() => update.updatedPageMap);\r\n      // TODO: A weird race condition bug in very fast environments most of the time makes the initial flip referenced by the URL to be skipped and instead turns to page 1.\r\n      // Since the useState setters cannot be subscribed here and I don't know React or more specifically Hooks that much, I will just put a bit of a timeout here to let the state changes happen before flipping.\r\n      // Should fix after getting more experience about state updates.\r\n      setTimeout(() => {\r\n        flipToPage();\r\n      }, 100);\r\n    }\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [page]);\r\n\r\n  // useEffect(() => {\r\n  //   if (bookmark !== undefined) localStorage.setItem('bookmark', bookmark);\r\n  // }, [bookmark]);\r\n\r\n  useEffect(() => {\r\n    console.log('renderedPages', renderedPages);\r\n  }, [renderedPages]);\r\n\r\n  useEffect(() => {\r\n    console.log('pageData', pageData);\r\n  }, [pageData]);\r\n\r\n  // lazy loading of pages\r\n  const updateRenderedPages = (_renderedPages, _pageMap, _pageData) => {\r\n    const updatedRenderedPages = [..._renderedPages];\r\n    const updatedPageMap = { ..._pageMap };\r\n    for (let i = page - 5; i < page + 5; i++) {\r\n      if (i < 0 || i > _renderedPages.length - 1) continue;\r\n      if (_pageMap[i] !== undefined) continue;\r\n\r\n      updatedRenderedPages[i] = _pageData.pages[i];\r\n      updatedPageMap[i] = true;\r\n    }\r\n\r\n    return { updatedRenderedPages, updatedPageMap };\r\n  }\r\n\r\n  useEffect(() => {\r\n    console.log('Change');\r\n  });\r\n\r\n  // Event handlers\r\n\r\n  // const nextButtonClick = () => {\r\n  //   setPage((totalPage > page) ? page + 1 : page);\r\n  // }\r\n\r\n  // const prevButtonClick = () => {\r\n  //   setPage((0 < page) ? page - 1 : page);\r\n  // }\r\n\r\n\r\n  // const onPage = (e) => {\r\n  //   setPage(e.data);\r\n  // };\r\n\r\n  // const addPageToBookmark = () => {\r\n  //   // setBookmark(page);\r\n  //   localStorage.setItem('bookmark', page);\r\n  // };\r\n\r\n  const openBookmark = () => {\r\n    setPage(Number(localStorage.getItem('bookmark')));\r\n  };\r\n\r\n  // const updateBook = () => {\r\n  //   // setRenderedPages([]);\r\n  //   // setRenderedPages(pageData.pages.slice(0, 4));\r\n  //   // setRenderedPages(renderedPages.slice(0, 4).concat(pageData.pages.slice(5, 7)));\r\n  // }\r\n\r\n  const preparePages = (pageArray) => {\r\n    return pageArray.reduce((res, page, index) => {\r\n      if (page.type === 'chapter') res.chapters.push({\r\n        pagetitle: page.pagetitle,\r\n        pagenumber: res.pageCount\r\n      });\r\n      if (page.type === 'contents') {\r\n        // We want to have the links on the right side\r\n        if (res.pageCount % 2 === 1) {\r\n          res.pages.push(<Page type=\"temp\" key={res.pageCount} pageNumber={res.pageCount}></Page>);\r\n          res.pageCount += 1;\r\n        }\r\n        res.pageOfContents = res.pageCount + 1;\r\n      }\r\n      if (index + 1 === pageArray.length) {\r\n        if (res.pageCount % 2 === 0) {\r\n          res.pages.push(<Page type=\"temp\" key={res.pageCount} pageNumber={res.pageCount}></Page>);\r\n          res.pageCount += 1;\r\n        }\r\n      }\r\n\r\n      if (page.type === 'html') {\r\n        // On a 480x720 display the text content would probably have these width-height parameters\r\n        const htmlpages = cutHTMLIntoPieces(page.content[language].html, 420, 500);\r\n        let minipages = htmlpages.map((p, i) => {\r\n          return <Page\r\n            key={res.pageCount + i}\r\n            pageNumber={res.pageCount + i}\r\n            type={page.type}\r\n            pageTitle={page.pagetitle[language]}\r\n            content={(i === 0) ? { image: page.content[language].image, html: p } : { image: null, html: p }}\r\n          ></Page>\r\n        });\r\n        minipages.forEach(p => res.pages.push(p));\r\n        res.pageCount += htmlpages.length;\r\n\r\n      } else {\r\n        let inputProps = {\r\n          key: res.pageCount,\r\n          pageNumber: res.pageCount,\r\n          type: page.type,\r\n          pageTitle: (page.pagetitle) ? page.pagetitle[language] : undefined\r\n        };\r\n        if (res.pageCount === 0) {\r\n          inputProps.bookmark = true;\r\n          inputProps.onBookmark = openBookmark;\r\n          inputProps.pos = 'top';\r\n        }\r\n        if (res.pageCount === pageArray.length - 1) {\r\n          inputProps.pos = 'bottom';\r\n        }\r\n        if (page.imagename) {\r\n          inputProps.image = process.env.PUBLIC_URL + '/' + page.imagename;\r\n          inputProps.imageCaption = page.imagecaption[language]\r\n        }\r\n\r\n        res.pages.push(\r\n          <Page\r\n            {...inputProps}\r\n          ></Page>\r\n        );\r\n        res.pageCount += 1;\r\n      }\r\n\r\n      return res;\r\n\r\n    }, {\r\n      chapters: [],\r\n      pageCount: 0,\r\n      pageOfContents: 0,\r\n      pages: []\r\n    });\r\n  }\r\n\r\n  const cutHTMLIntoPieces = (content, width, height) => {\r\n    let hiddendiv = document.createElement('div');\r\n    hiddendiv.id = 'hiddendiv';\r\n    hiddendiv.style.width = width + 'px';\r\n    hiddendiv.style.visibility = 'hidden';\r\n    hiddendiv.style.fontSize = '120%';\r\n    hiddendiv.innerHTML = content;\r\n    let arr = [];\r\n\r\n    document.body.appendChild(hiddendiv);\r\n\r\n    hiddendiv.childNodes.forEach(node => {\r\n      if (node.nodeType === 3) {\r\n        arr.push(node.textContent);\r\n      } else {\r\n        arr.push(node.outerHTML);\r\n      }\r\n    });\r\n    hiddendiv.innerHTML = '';\r\n\r\n    let pages = [];\r\n    let pageIndex = 0;\r\n\r\n    pages[0] = document.createElement('article');\r\n\r\n    for (let i = 0; i < arr.length; i++) {\r\n      hiddendiv.innerHTML += arr[i];\r\n      if (hiddendiv.clientHeight > height) {\r\n        pageIndex += 1;\r\n        pages[pageIndex] = document.createElement('article');\r\n        hiddendiv.innerHTML = '';\r\n      }\r\n      pages[pageIndex].innerHTML += arr[i];\r\n    }\r\n\r\n    document.body.removeChild(hiddendiv);\r\n    return pages;\r\n  }\r\n\r\n  const changeLanguage = () => {\r\n    setLanguage(language => (language === 1) ? 0 : 1);\r\n  }\r\n\r\n  const openModal = () => {\r\n    alert('Helló! :D');\r\n  }\r\n\r\n\r\n  // const createPage = (page, pagenumber, language) => {\r\n  //   return <Page\r\n  //     key={pagenumber}\r\n  //     pageNumber={pagenumber}\r\n  //     image={process.env.PUBLIC_URL + '/' + page.imagename}\r\n  //     imageCaption={page.imagecaption[language]}\r\n  //     // {(page.type === 'category') ? page.pagetitle[language] : null}\r\n  //     pageTitle={(page.type === 'category') ? page.pagetitle[language] : undefined}\r\n  //   ></Page>;\r\n  // };\r\n\r\n  const navigateToPage = (e) => {\r\n    e.preventDefault();\r\n    // setPage(Number(e.target.pathname.substring(1).split('/')[1]),);\r\n    setPage(Number(e.target.hash.substring(1).split('/')[1]));\r\n  }\r\n\r\n  // https://stackoverflow.com/a/175787\r\n  const isNumeric = (str) => {\r\n    if (typeof str != 'string') return false // we only process strings!\r\n    return !isNaN(str) && // use type coercion to parse the _entirety_ of the string (`parseFloat` alone does not do this)...\r\n      !isNaN(parseFloat(str)) // ...and ensure strings of whitespace fail\r\n  }\r\n\r\n  return (\r\n    <div className=\"d-flex flex-column\">\r\n      {/* https://github.com/lipis/flag-icon-css */}\r\n      <div className=\"mt-1 align-self-end\">\r\n        <button className=\"m-1 button\" onClick={changeLanguage} title={\r\n          (language === 0) ? 'Switch to english language' : 'Magyar nyelvre váltás'\r\n        }>\r\n          {(language === 0) ?\r\n            <span><span class=\"flag-icon\" style={{ backgroundImage: 'url(' + process.env.PUBLIC_URL + '/gb.svg)' }}></span>\r\n              {/* Switch to english language */}\r\n            </span> :\r\n            <span><span class=\"flag-icon\" style={{ backgroundImage: 'url(' + process.env.PUBLIC_URL + '/hu.svg)' }}></span>\r\n              {/* Magyar nyelvre váltás */}\r\n            </span>\r\n          }\r\n        </button>\r\n        <button className=\"m-1 button\" onClick={openModal}>Kapcsolat</button>\r\n      </div>\r\n      <div className='book-container container-md'>\r\n        {/* <button type={'button'} className={'mt-1 btn btn-success'} onClick={addPageToBookmark} title={'Oldal könyvjelzőzése'}>\r\n        <svg xmlns={'http://www.w3.org/2000/svg'} width={'16'} height={'16'} fill={'currentColor'} className={'bi bi-bookmark-plus'} viewBox={'0 0 16 16'}>\r\n          <path fillRule={'evenodd'} d={'M8 4a.5.5 0 0 1 .5.5V6H10a.5.5 0 0 1 0 1H8.5v1.5a.5.5 0 0 1-1 0V7H6a.5.5 0 0 1 0-1h1.5V4.5A.5.5 0 0 1 8 4z'} />\r\n          <path d={'M2 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v13.5a.5.5 0 0 1-.777.416L8 13.101l-5.223 2.815A.5.5 0 0 1 2 15.5V2zm2-1a1 1 0 0 0-1 1v12.566l4.723-2.482a.5.5 0 0 1 .554 0L13 14.566V2a1 1 0 0 0-1-1H4z'} />\r\n        </svg>\r\n      </button>\r\n      <button type={'button'} className={'mt-1 btn btn-danger'} onClick={openBookmark} title={'Oldal kinyitása a könyvjelzőhöz'}>\r\n        <svg xmlns={'http://www.w3.org/2000/svg'} width={'16'} height={'16'} fill={'currentColor'} className={'bi bi-bookmark-plus'} viewBox={'0 0 16 16'}>\r\n          <path fillRule={'evenodd'} d={'M8 4a.5.5 0 0 1 .5.5V6H10a.5.5 0 0 1 0 1H8.5v1.5a.5.5 0 0 1-1 0V7H6a.5.5 0 0 1 0-1h1.5V4.5A.5.5 0 0 1 8 4z'} />\r\n          <path d={'M2 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v13.5a.5.5 0 0 1-.777.416L8 13.101l-5.223 2.815A.5.5 0 0 1 2 15.5V2zm2-1a1 1 0 0 0-1 1v12.566l4.723-2.482a.5.5 0 0 1 .554 0L13 14.566V2a1 1 0 0 0-1-1H4z'} />\r\n        </svg>\r\n  </button> */}\r\n        {(renderedPages.length > 0) ?\r\n          <HTMLFlipBook\r\n            width={550}\r\n            height={733}\r\n            size='stretch'\r\n            minWidth={315}\r\n            minHeight={400}\r\n            maxWidth={1000}\r\n            maxHeight={1533}\r\n            maxShadowOpacity={0.5}\r\n            flippingTime={700}\r\n            showCover={true}\r\n            mobileScrollSupport={true}\r\n            clickEventForward={['img', 'button', 'a']}\r\n            drawShadow={true}\r\n            swipeDistance={1}\r\n            useMouseEvents={true}\r\n            showPageCorners={false}\r\n\r\n            onFlip={(e) => setPage(() => {\r\n              // console.log(e.data);\r\n              return e.data;\r\n            })}\r\n\r\n            className='image-book'\r\n\r\n            ref={flipBook}\r\n          >\r\n            {renderedPages}\r\n          </HTMLFlipBook> : null}\r\n\r\n        {/* <div className='pageturner-container'>\r\n        <div>\r\n\r\n          <button type='button' onClick={this.prevButtonClick}>Előző oldal</button>\r\n\r\n            [<span>{this.state.page}</span> of <span> {this.state.totalPage} </span>]\r\n\r\n            <button type='button' onClick={this.nextButtonClick}>Következő oldal</button>\r\n        </div>\r\n      </div> */}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\nexport default ImageBook;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.scss';\r\nimport ImageBook from './ImageBook/ImageBook';\r\nimport reportWebVitals from './reportWebVitals';\r\n// import DemoBlock from './DemoBlock';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    {/* <DemoBlock /> */}\r\n    <ImageBook />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}