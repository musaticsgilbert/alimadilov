{"version":3,"sources":["PageFlip/Page/Page.ts","PageFlip/Flip/Flip.ts","PageFlip/Page/ImagePage.ts","PageFlip/Helper.ts","PageFlip/Flip/FlipCalculation.ts","PageFlip/Settings.ts","PageFlip/Render/Render.ts","PageFlip/Collection/PageCollection.ts","PageFlip/Collection/ImagePageCollection.ts","PageFlip/Page/HTMLPage.ts","PageFlip/Collection/HTMLPageCollection.ts","PageFlip/Render/CanvasRender.ts","PageFlip/UI/UI.ts","PageFlip/UI/HTMLUI.ts","PageFlip/UI/CanvasUI.ts","PageFlip/Event/EventObject.ts","PageFlip/Render/HTMLRender.ts","PageFlip/PageFlip.ts","PageFlip/react-pageflip.js","ImageBook/Page/Page.jsx","Router.js","ImageBook/ImageBook.jsx","reportWebVitals.js","index.js"],"names":["PageOrientation","PageDensity","FlipDirection","FlipCorner","FlippingState","Page","render","density","state","orientation","createdDensity","nowDrawingDensity","this","angle","area","position","x","y","hardAngle","hardDrawingAngle","pagePos","ImagePage","href","image","isLoad","loadingAngle","Image","src","tempDensity","ctx","getContext","convertToGlobal","pageWidth","getRect","pageHeight","height","save","translate","beginPath","p","lineTo","rotate","clip","drawImage","drawLoader","restore","orient","rect","RIGHT","left","top","shiftPos","strokeStyle","fillStyle","lineWidth","stroke","fill","middlePoint","arc","Math","PI","closePath","onload","Helper","point1","point2","Infinity","sqrt","pow","segment","GetDistanceBetweenTwoPoint","line1","line2","A1","A2","B1","B2","acos","pos","width","transformedPoint","startPoint","cos","sin","radius","limitedPoint","a","b","n","m","rectBorder","one","two","PointInRect","GetIntersectBeetwenTwoLine","C1","C2","det1","det2","isFinite","abs","Error","pointOne","pointTwo","sizeX","sizeY","lengthLine","max","result","getCord","c1","c2","size","length","index","i","push","FlipCalculation","direction","corner","topIntersectPoint","sideIntersectPoint","bottomIntersectPoint","parseInt","localPos","calcAngleAndPosition","calculateIntersectPoint","e","clipBottom","topLeft","BOTTOM","bottomLeft","TOP","FORWARD","topRight","BACK","GetAngleBetweenTwoLine","getSegmentToShadowLine","updateAngleAndGeometry","checkPositionAtCenterLine","calculateAngle","getPageRect","da","getRectFromBasePoint","points","getRotatedPoint","bottomRight","boundRect","GetIntersectBetweenTwoSegment","checkedPos","centerOne","centerTwo","tmp","LimitPointToCircle","rad","checkPointOne","checkPointTwo","bottomPoint","first","getShadowStartPoint","SizeType","Flip","app","flippingPage","bottomPage","calc","READ","globalPos","setState","USER_FOLD","start","do","convertToPage","finishAnimation","getBoundsRect","FLIPPING","topMargins","yStart","getCorner","yDest","animateFlippingTo","reset","bookPos","convertToBook","getDirectionByPoint","flipCorner","checkDirection","getPageCollection","getFlippingPage","getBottomPage","getOrientation","Orientation","LANDSCAPE","nextPage","nextBy","getDensity","setDrawingDensity","HARD","prevPage","prevBy","setDirection","toString","progress","getFlippingProgress","setArea","getBottomClipArea","setPosition","getBottomPagePosition","setAngle","setHardAngle","getFlippingClipArea","getActiveCorner","getAngle","getDirection","setPageRect","setBottomPage","setFlippingPage","setShadowData","getShadowAngle","page","current","getCurrentSpreadIndex","next","getSpreadIndexByPage","setCurrentSpreadIndex","flipNext","flipPrev","flip","getPosition","checkState","FOLD_CORNER","operatingDistance","stopMove","dest","isTurned","needReset","GetCordsFromTwoPoint","frames","duration","getAnimationDuration","startAnimation","turnToPrevPage","turnToNextPage","clearShadow","newState","updateState","touchPos","PORTRAIT","defaultTime","getSettings","flippingTime","getCurrentPageIndex","getPageCount","states","Settings","_default","startPage","FIXED","minWidth","maxWidth","minHeight","maxHeight","drawShadow","usePortrait","startZIndex","autoSize","maxShadowOpacity","showCover","mobileScrollSupport","swipeDistance","clickEventForward","useMouseEvents","showPageCorners","userSetting","Object","assign","STRETCH","Render","setting","leftPage","rightPage","shadow","animation","pageRect","boundsRect","timer","safari","regex","RegExp","exec","window","navigator","userAgent","frameIndex","round","startedAt","durationFrame","onAnimateEnd","drawFrame","update","requestAnimationFrame","loop","calculateBoundsRect","updateOrientation","blockWidth","getBlockWidth","getBlockHeight","ratio","opacity","getUI","getDistElement","offsetWidth","offsetHeight","setOrientation","LEFT","PageCollection","isShowCover","pages","currentPageIndex","currentSpreadIndex","landscapeSpread","portraitSpread","setDensity","pageNum","spread","getSpread","pageIndex","idx","indexOf","newTemporaryCopy","showSpread","spreadIndex","newIndex","setLeftPage","setRightPage","updatePageIndex","ImagePageCollection","imagesHref","SOFT","load","createSpread","HTMLPage","element","copiedElement","temporaryCopy","classList","add","cloneNode","parentElement","appendChild","getTemporaryCopy","remove","style","display","drawHard","drawSoft","backfaceVisibility","setProperty","transformOrigin","transform","clipPath","polygon","g","GetRotatedPoint","slice","isSafari","contains","cssText","HTMLPageCollection","items","pagesElement","pageElement","dataset","CanvasRender","inCanvas","canvas","clear","simpleDraw","draw","drawBookShadow","drawOuterShadow","drawInnerShadow","shadowSize","shadowPos","outerGradient","createLinearGradient","addColorStop","fillRect","convertRectToGlobal","moveTo","isw","innerGradient","UI","inBlock","wrapper","distElement","touchPoint","swipeTimeout","onResize","onMouseDown","checkTarget","target","getMousePos","clientX","clientY","startUserTouch","preventDefault","onTouchStart","changedTouches","t","point","time","Date","now","setTimeout","onMouseUp","userStop","onMouseMove","userMove","onTouchMove","getState","cancelable","onTouchEnd","isSwipe","dx","distY","getRender","insertAdjacentHTML","querySelector","k","addEventListener","removeHandlers","paddingBottom","removeEventListener","passive","getBoundingClientRect","Array","isArray","includes","tagName","toLowerCase","HTMLUI","item","setHandlers","innerHTML","CanvasUI","querySelectorAll","resizeCanvas","cs","getComputedStyle","getPropertyValue","EventObject","events","Map","eventName","callback","has","get","set","event","delete","data","object","HTMLRender","outerShadow","innerShadow","hardShadow","hardInnerShadow","createShadows","innerShadowSize","zIndex","background","shadowTranslate","shadowDirection","getDrawingDensity","getElement","setHardDrawingAngle","getHardAngle","drawLeftPage","drawRightPage","drawBottomPage","drawHardOuterShadow","drawHardInnerShadow","getPages","hideTemporaryCopy","PageFlip","mousePosition","isUserTouch","isUserMove","block","flipController","ui","destroy","show","getCanvas","trigger","mode","updateItems","updatePages","showPrev","showNext","flipToPage","newPage","newOrientation","setOrientationStyle","getPage","isTouch","fold","showCorner","HTMLFlipBook","pageFlip","el","props","loadFromHTML","childRef","onFlip","on","onChangeOrientation","onChangeState","onInit","onUpdate","prevProps","children","off","updateFromHtml","childWithRef","React","Children","map","child","cloneElement","ref","dom","createElement","className","Component","forwardRef","type","data-density","bookmark","process","filter","alt","title","onClick","onBookmark","pageTitle","no_animation","undefined","content","margin","float","dangerouslySetInnerHTML","__html","html","imageCaption","console","log","requestFullscreen","then","onLoad","isNaN","pageNumber","Router","options","routes","root","path","cb","flush","clearSlashes","replace","getFragment","fragment","decodeURI","location","pathname","search","match","navigate","history","pushState","listen","clearInterval","interval","setInterval","some","route","shift","apply","ImageBook","nextButtonClick","totalPage","prevButtonClick","onPage","router","flipBook","getPageFlip","Number","addPageToBookmark","localStorage","setItem","openBookmark","navigateToPage","hash","substring","split","updateBook","renderedPages","pageData","language","chapters","pageOfContents","routingStrategy","fetch","headers","res","json","pageArray","reduce","pagetitle","pagenumber","inputProps","key","imagename","imagecaption","chapter","String","isNumeric","getItem","forceUpdate","err","alert","error","str","parseFloat","xmlns","viewBox","fillRule","d","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.0aae78e1.chunk.js","sourcesContent":["import { Render } from '../Render/Render';\r\nimport { Point } from '../BasicTypes';\r\n\r\n/**\r\n * State of the page on the basis of which rendering\r\n */\r\nexport interface PageState {\r\n  /** Page rotation angle */\r\n  angle: number;\r\n\r\n  /** Page scope */\r\n  area: Point[];\r\n\r\n  /** Page position */\r\n  position: Point;\r\n\r\n  /** Rotate angle for hard pages */\r\n  hardAngle: number;\r\n\r\n  /** Rotate angle for hard pages at renedering time */\r\n  hardDrawingAngle: number;\r\n}\r\n\r\nexport enum PageOrientation {\r\n  /** Left side page */\r\n  LEFT,\r\n\r\n  /** Right side page */\r\n  RIGHT,\r\n}\r\n\r\nexport enum PageDensity {\r\n  SOFT = 'soft',\r\n  HARD = 'hard',\r\n}\r\n\r\n/**\r\n * Class representing a book page\r\n */\r\nexport abstract class Page {\r\n  /** State of the page on the basis of which rendering */\r\n  protected state: PageState;\r\n  /** Render object */\r\n  protected render: Render;\r\n\r\n  /** Page Orientation */\r\n  protected orientation: PageOrientation;\r\n\r\n  /** Density at creation */\r\n  protected createdDensity: PageDensity;\r\n  /** Density at the time of rendering (Depends on neighboring pages) */\r\n  protected nowDrawingDensity: PageDensity;\r\n\r\n  protected constructor(render: Render, density: PageDensity) {\r\n    this.state = {\r\n      angle: 0,\r\n      area: [],\r\n      position: { x: 0, y: 0 },\r\n      hardAngle: 0,\r\n      hardDrawingAngle: 0,\r\n    };\r\n\r\n    this.createdDensity = density;\r\n    this.nowDrawingDensity = this.createdDensity;\r\n\r\n    this.render = render;\r\n  }\r\n\r\n  /**\r\n   * Render static page\r\n   * \r\n   * @param {PageOrientation} orient - Static page orientation\r\n   */\r\n  public abstract simpleDraw(orient: PageOrientation): void;\r\n\r\n  /**\r\n   * Render dynamic page, using state\r\n   * \r\n   * @param {PageDensity} tempDensity - Density at the time of rendering \r\n   */\r\n  public abstract draw(tempDensity?: PageDensity): void;\r\n\r\n  /**\r\n   * Page loading\r\n   */\r\n  public abstract load(): void;\r\n\r\n  /**\r\n   * Set a constant page density\r\n   * \r\n   * @param {PageDensity} density \r\n   */\r\n  public setDensity(density: PageDensity): void {\r\n    this.createdDensity = density;\r\n    this.nowDrawingDensity = density;\r\n  }\r\n\r\n  /**\r\n   * Set temp page density to next render\r\n   * \r\n   * @param {PageDensity}  density \r\n   */\r\n  public setDrawingDensity(density: PageDensity): void {\r\n    this.nowDrawingDensity = density;\r\n  }\r\n\r\n  /**\r\n   * Set page position\r\n   * \r\n   * @param {Point} pagePos \r\n   */\r\n  public setPosition(pagePos: Point): void {\r\n    this.state.position = pagePos;\r\n  }\r\n\r\n  /**\r\n   * Set page angle\r\n   * \r\n   * @param {number} angle \r\n   */\r\n  public setAngle(angle: number): void {\r\n    this.state.angle = angle;\r\n  }\r\n\r\n  /**\r\n   * Set page crop area\r\n   * \r\n   * @param {Point[]} area \r\n   */\r\n  public setArea(area: Point[]): void {\r\n    this.state.area = area;\r\n  }\r\n\r\n  /**\r\n   * Rotate angle for hard pages to next render\r\n   * \r\n   * @param {number} angle \r\n   */\r\n  public setHardDrawingAngle(angle: number): void {\r\n    this.state.hardDrawingAngle = angle;\r\n  }\r\n\r\n  /**\r\n   * Rotate angle for hard pages\r\n   * \r\n   * @param {number} angle \r\n   */\r\n  public setHardAngle(angle: number): void {\r\n    this.state.hardAngle = angle;\r\n    this.state.hardDrawingAngle = angle;\r\n  }\r\n\r\n  /**\r\n   * Set page orientation\r\n   * \r\n   * @param {PageOrientation} orientation \r\n   */\r\n  public setOrientation(orientation: PageOrientation): void {\r\n    this.orientation = orientation;\r\n  }\r\n\r\n  /**\r\n   * Get temp page density\r\n   */\r\n  public getDrawingDensity(): PageDensity {\r\n    return this.nowDrawingDensity;\r\n  }\r\n\r\n  /**\r\n   * Get a constant page density\r\n   */\r\n  public getDensity(): PageDensity {\r\n    return this.createdDensity;\r\n  }\r\n\r\n  /**\r\n   * Get rotate angle for hard pages\r\n   */\r\n  public getHardAngle(): number {\r\n    return this.state.hardAngle;\r\n  }\r\n\r\n  public abstract newTemporaryCopy(): Page;\r\n  public abstract getTemporaryCopy(): Page;\r\n  public abstract hideTemporaryCopy(): void;\r\n}\r\n","import { Orientation, Render } from '../Render/Render';\r\nimport { PageFlip } from '../PageFlip';\r\nimport { Helper } from '../Helper';\r\nimport { PageRect, Point } from '../BasicTypes';\r\nimport { FlipCalculation } from './FlipCalculation';\r\nimport { Page, PageDensity } from '../Page/Page';\r\n\r\n/**\r\n * Flipping direction\r\n */\r\nexport enum FlipDirection {\r\n  FORWARD,\r\n  BACK,\r\n}\r\n\r\n/**\r\n * Active corner when flipping\r\n */\r\nexport enum FlipCorner {\r\n  TOP = 'top',\r\n  BOTTOM = 'bottom',\r\n}\r\n\r\n/**\r\n * State of the book\r\n */\r\nexport enum FlippingState {\r\n  /** The user folding the page */\r\n  USER_FOLD = 'user_fold',\r\n\r\n  /** Mouse over active corners */\r\n  FOLD_CORNER = 'fold_corner',\r\n\r\n  /** During flipping animation */\r\n  FLIPPING = 'flipping',\r\n\r\n  /** Base state */\r\n  READ = 'read',\r\n}\r\n\r\n/**\r\n * Class representing the flipping process\r\n */\r\nexport class Flip {\r\n  private readonly render: Render;\r\n  private readonly app: PageFlip;\r\n\r\n  private flippingPage: Page = null;\r\n  private bottomPage: Page = null;\r\n\r\n  private calc: FlipCalculation = null;\r\n\r\n  private state: FlippingState = FlippingState.READ;\r\n\r\n  constructor(render: Render, app: PageFlip) {\r\n    this.render = render;\r\n    this.app = app;\r\n  }\r\n\r\n  /**\r\n   * Called when the page folding (User drags page corner)\r\n   * \r\n   * @param globalPos - Touch Point Coordinates (relative window)\r\n   */\r\n  public fold(globalPos: Point): void {\r\n    this.setState(FlippingState.USER_FOLD);\r\n\r\n    // If the process has not started yet\r\n    if (this.calc === null) this.start(globalPos);\r\n\r\n    this.do(this.render.convertToPage(globalPos));\r\n  }\r\n\r\n  /**\r\n   * Page turning with animation\r\n   * \r\n   * @param globalPos - Touch Point Coordinates (relative window)\r\n   */\r\n  public flip(globalPos: Point): void {\r\n    // the flipiing process is already running\r\n    if (this.calc !== null) this.render.finishAnimation();\r\n\r\n    if (!this.start(globalPos)) return;\r\n\r\n    const rect = this.getBoundsRect();\r\n\r\n    this.setState(FlippingState.FLIPPING);\r\n\r\n    // Margin from top to start flipping\r\n    const topMargins = rect.height / 10;\r\n\r\n    // Defining animation start points\r\n    const yStart =\r\n      this.calc.getCorner() === FlipCorner.BOTTOM ? rect.height - topMargins : topMargins;\r\n\r\n    const yDest = this.calc.getCorner() === FlipCorner.BOTTOM ? rect.height : 0;\r\n\r\n    // Сalculations for these points\r\n    this.calc.calc({ x: rect.pageWidth - topMargins, y: yStart });\r\n\r\n    // Run flipping animation\r\n    this.animateFlippingTo(\r\n      { x: rect.pageWidth - topMargins, y: yStart },\r\n      { x: -rect.pageWidth, y: yDest },\r\n      true\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Start the flipping process. Find direction and corner of flipping. Creating an object for calculation.\r\n   * \r\n   * @param {Point} globalPos - Touch Point Coordinates (relative window)\r\n   * \r\n   * @returns {boolean} True if flipping is possible, false otherwise\r\n   */\r\n  public start(globalPos: Point): boolean {\r\n    this.reset();\r\n\r\n    const bookPos = this.render.convertToBook(globalPos);\r\n    const rect = this.getBoundsRect();\r\n\r\n    // Find the direction of flipping\r\n    const direction = this.getDirectionByPoint(bookPos);\r\n\r\n    // Find the active corner\r\n    const flipCorner = bookPos.y >= rect.height / 2 ? FlipCorner.BOTTOM : FlipCorner.TOP;\r\n\r\n    if (!this.checkDirection(direction)) return false;\r\n\r\n    try {\r\n      this.flippingPage = this.app.getPageCollection().getFlippingPage(direction);\r\n      this.bottomPage = this.app.getPageCollection().getBottomPage(direction);\r\n\r\n      // In landscape mode, needed to set the density  of the next page to the same as that of the flipped\r\n      if (this.render.getOrientation() === Orientation.LANDSCAPE) {\r\n        if (direction === FlipDirection.BACK) {\r\n          const nextPage = this.app.getPageCollection().nextBy(this.flippingPage);\r\n\r\n          if (nextPage !== null) {\r\n            if (this.flippingPage.getDensity() !== nextPage.getDensity()) {\r\n              this.flippingPage.setDrawingDensity(PageDensity.HARD);\r\n              nextPage.setDrawingDensity(PageDensity.HARD);\r\n            }\r\n          }\r\n        } else {\r\n          const prevPage = this.app.getPageCollection().prevBy(this.flippingPage);\r\n\r\n          if (prevPage !== null) {\r\n            if (this.flippingPage.getDensity() !== prevPage.getDensity()) {\r\n              this.flippingPage.setDrawingDensity(PageDensity.HARD);\r\n              prevPage.setDrawingDensity(PageDensity.HARD);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      this.render.setDirection(direction);\r\n      this.calc = new FlipCalculation(\r\n        direction,\r\n        flipCorner,\r\n        rect.pageWidth.toString(10), // fix bug with type casting\r\n        rect.height.toString(10) // fix bug with type casting\r\n      );\r\n\r\n      return true;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Perform calculations for the current page position. Pass data to render object\r\n   * \r\n   * @param {Point} pagePos - Touch Point Coordinates (relative active page)\r\n   */\r\n  private do(pagePos: Point): void {\r\n    if (this.calc === null) return; // Flipping process not started\r\n\r\n    if (this.calc.calc(pagePos)) { // Perform calculations for a specific position\r\n      const progress = this.calc.getFlippingProgress();\r\n\r\n      this.bottomPage.setArea(this.calc.getBottomClipArea());\r\n      this.bottomPage.setPosition(this.calc.getBottomPagePosition());\r\n      this.bottomPage.setAngle(0);\r\n      this.bottomPage.setHardAngle(0);\r\n\r\n      this.flippingPage.setArea(this.calc.getFlippingClipArea());\r\n      this.flippingPage.setPosition(this.calc.getActiveCorner());\r\n      this.flippingPage.setAngle(this.calc.getAngle());\r\n\r\n      if (this.calc.getDirection() === FlipDirection.FORWARD) {\r\n        this.flippingPage.setHardAngle((90 * (200 - progress * 2)) / 100);\r\n      } else {\r\n        this.flippingPage.setHardAngle((-90 * (200 - progress * 2)) / 100);\r\n      }\r\n\r\n      this.render.setPageRect(this.calc.getRect());\r\n\r\n      this.render.setBottomPage(this.bottomPage);\r\n      this.render.setFlippingPage(this.flippingPage);\r\n\r\n      this.render.setShadowData(\r\n        this.calc.getShadowStartPoint(),\r\n        this.calc.getShadowAngle(),\r\n        progress,\r\n        this.calc.getDirection()\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Turn to the specified page number (with animation)\r\n   *\r\n   * @param {number} page - New page number\r\n   * @param {FlipCorner} corner - Active page corner when turning\r\n   */\r\n  public flipToPage(page: number, corner: FlipCorner): void {\r\n    const current = this.app.getPageCollection().getCurrentSpreadIndex();\r\n    const next = this.app.getPageCollection().getSpreadIndexByPage(page);\r\n\r\n    try {\r\n      if (next > current) {\r\n        this.app.getPageCollection().setCurrentSpreadIndex(next - 1);\r\n        this.flipNext(corner);\r\n      }\r\n      if (next < current) {\r\n        this.app.getPageCollection().setCurrentSpreadIndex(next + 1);\r\n        this.flipPrev(corner);\r\n      }\r\n    } catch (e) {\r\n      //\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Turn to the next page (with animation)\r\n   *\r\n   * @param {FlipCorner} corner - Active page corner when turning\r\n   */\r\n  public flipNext(corner: FlipCorner): void {\r\n    this.flip({\r\n      x: this.render.getRect().left + this.render.getRect().pageWidth * 2,\r\n      y: corner === FlipCorner.TOP ? 1 : this.render.getRect().height - 2,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Turn to the prev page (with animation)\r\n   *\r\n   * @param {FlipCorner} corner - Active page corner when turning\r\n   */\r\n  public flipPrev(corner: FlipCorner): void {\r\n    this.flip({\r\n      x: 10,\r\n      y: corner === FlipCorner.TOP ? 1 : this.render.getRect().height - 2,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Called when the user has stopped flipping\r\n   */\r\n  public stopMove(): void {\r\n    if (this.calc === null) return;\r\n\r\n    const pos = this.calc.getPosition();\r\n    const rect = this.getBoundsRect();\r\n\r\n    const y = this.calc.getCorner() === FlipCorner.BOTTOM ? rect.height : 0;\r\n\r\n    if (pos.x <= 0) this.animateFlippingTo(pos, { x: -rect.pageWidth, y }, true);\r\n    else this.animateFlippingTo(pos, { x: rect.pageWidth, y }, false);\r\n  }\r\n\r\n  /**\r\n   * Fold the corners of the book when the mouse pointer is over them.\r\n   * Called when the mouse pointer is over the book without clicking\r\n   * \r\n   * @param globalPos \r\n   */\r\n  public showCorner(globalPos: Point): void {\r\n    if (!this.checkState(FlippingState.READ, FlippingState.FOLD_CORNER)) return;\r\n\r\n    const rect = this.getBoundsRect();\r\n    const pageWidth = rect.pageWidth;\r\n\r\n    // folding angle length\r\n    const operatingDistance = Math.sqrt(Math.pow(pageWidth, 2) + Math.pow(rect.height, 2)) / 5;\r\n\r\n    const bookPos = this.render.convertToBook(globalPos);\r\n\r\n    if (\r\n      bookPos.x > 0 &&\r\n      bookPos.y > 0 &&\r\n      bookPos.x < rect.width &&\r\n      bookPos.y < rect.height &&\r\n      (bookPos.x < operatingDistance || bookPos.x > rect.width - operatingDistance) &&\r\n      (bookPos.y < operatingDistance || bookPos.y > rect.height - operatingDistance)\r\n    ) {\r\n      if (this.calc === null) {\r\n        if (!this.start(globalPos)) return;\r\n\r\n        this.setState(FlippingState.FOLD_CORNER);\r\n\r\n        this.calc.calc({ x: pageWidth - 1, y: 1 });\r\n\r\n        const fixedCornerSize = 50;\r\n        const yStart = this.calc.getCorner() === FlipCorner.BOTTOM ? rect.height - 1 : 1;\r\n\r\n        const yDest =\r\n          this.calc.getCorner() === FlipCorner.BOTTOM\r\n            ? rect.height - fixedCornerSize\r\n            : fixedCornerSize;\r\n\r\n        this.animateFlippingTo(\r\n          { x: pageWidth - 1, y: yStart },\r\n          { x: pageWidth - fixedCornerSize, y: yDest },\r\n          false,\r\n          false\r\n        );\r\n      } else {\r\n        this.do(this.render.convertToPage(globalPos));\r\n      }\r\n    } else {\r\n      this.setState(FlippingState.READ);\r\n      this.render.finishAnimation();\r\n\r\n      this.stopMove();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Starting the flipping animation process\r\n   * \r\n   * @param {Point} start - animation start point\r\n   * @param {Point} dest - animation end point\r\n   * @param {boolean} isTurned - will the page turn over, or just bring it back\r\n   * @param {boolean} needReset - reset the flipping process at the end of the animation\r\n   */\r\n  private animateFlippingTo(\r\n    start: Point,\r\n    dest: Point,\r\n    isTurned: boolean,\r\n    needReset = true\r\n  ): void {\r\n    const points = Helper.GetCordsFromTwoPoint(start, dest);\r\n\r\n    // Create frames\r\n    const frames = [];\r\n    for (const p of points) frames.push(() => this.do(p));\r\n\r\n    const duration = this.getAnimationDuration(points.length);\r\n\r\n    this.render.startAnimation(frames, duration, () => {\r\n      // callback function\r\n      if (!this.calc) return;\r\n\r\n      if (isTurned) {\r\n        if (this.calc.getDirection() === FlipDirection.BACK) this.app.turnToPrevPage();\r\n        else this.app.turnToNextPage();\r\n      }\r\n\r\n      if (needReset) {\r\n        this.render.setBottomPage(null);\r\n        this.render.setFlippingPage(null);\r\n        this.render.clearShadow();\r\n\r\n        this.setState(FlippingState.READ);\r\n        this.reset();\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get the current calculations object\r\n   */\r\n  public getCalculation(): FlipCalculation {\r\n    return this.calc;\r\n  }\r\n\r\n  /**\r\n   * Get current flipping state\r\n   */\r\n  public getState(): FlippingState {\r\n    return this.state;\r\n  }\r\n\r\n  private setState(newState: FlippingState): void {\r\n    if (this.state !== newState) {\r\n      this.app.updateState(newState);\r\n      this.state = newState;\r\n    }\r\n  }\r\n\r\n  private getDirectionByPoint(touchPos: Point): FlipDirection {\r\n    const rect = this.getBoundsRect();\r\n\r\n    if (this.render.getOrientation() === Orientation.PORTRAIT) {\r\n      if (touchPos.x - rect.pageWidth <= rect.width / 5) {\r\n        return FlipDirection.BACK;\r\n      }\r\n    } else if (touchPos.x < rect.width / 2) {\r\n      return FlipDirection.BACK;\r\n    }\r\n\r\n    return FlipDirection.FORWARD;\r\n  }\r\n\r\n  private getAnimationDuration(size: number): number {\r\n    const defaultTime = this.app.getSettings().flippingTime;\r\n\r\n    if (size >= 1000) return defaultTime;\r\n\r\n    return (size / 1000) * defaultTime;\r\n  }\r\n\r\n  private checkDirection(direction: FlipDirection): boolean {\r\n    if (direction === FlipDirection.FORWARD)\r\n      return this.app.getCurrentPageIndex() < this.app.getPageCount() - 1;\r\n\r\n    return this.app.getCurrentPageIndex() >= 1;\r\n  }\r\n\r\n  private reset(): void {\r\n    this.calc = null;\r\n    this.flippingPage = null;\r\n    this.bottomPage = null;\r\n  }\r\n\r\n  private getBoundsRect(): PageRect {\r\n    return this.render.getRect();\r\n  }\r\n\r\n  private checkState(...states: FlippingState[]): boolean {\r\n    for (const state of states) {\r\n      if (this.state === state) return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n}\r\n","import { CanvasRender } from '../Render/CanvasRender';\r\nimport { Page, PageDensity, PageOrientation } from './Page';\r\nimport { Render } from '../Render/Render';\r\nimport { Point } from '../BasicTypes';\r\n\r\n/**\r\n * Class representing a book page as an image on Canvas\r\n */\r\nexport class ImagePage extends Page {\r\n    private readonly image: HTMLImageElement = null;\r\n    private isLoad = false;\r\n\r\n    private loadingAngle = 0;\r\n\r\n    constructor(render: Render, href: string, density: PageDensity) {\r\n        super(render, density);\r\n\r\n        this.image = new Image();\r\n        this.image.src = href;\r\n    }\r\n\r\n    public draw(tempDensity?: PageDensity): void {\r\n        const ctx = (this.render as CanvasRender).getContext();\r\n\r\n        const pagePos = this.render.convertToGlobal(this.state.position);\r\n        const pageWidth = this.render.getRect().pageWidth;\r\n        const pageHeight = this.render.getRect().height;\r\n\r\n        ctx.save();\r\n        ctx.translate(pagePos.x, pagePos.y);\r\n        ctx.beginPath();\r\n\r\n        for (let p of this.state.area) {\r\n            if (p !== null) {\r\n                p = this.render.convertToGlobal(p);\r\n                ctx.lineTo(p.x - pagePos.x, p.y - pagePos.y);\r\n            }\r\n        }\r\n\r\n        ctx.rotate(this.state.angle);\r\n\r\n        ctx.clip();\r\n\r\n        if (!this.isLoad) {\r\n            this.drawLoader(ctx, { x: 0, y: 0 }, pageWidth, pageHeight);\r\n        } else {\r\n            ctx.drawImage(this.image, 0, 0, pageWidth, pageHeight);\r\n        }\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    public simpleDraw(orient: PageOrientation): void {\r\n        const rect = this.render.getRect();\r\n        const ctx = (this.render as CanvasRender).getContext();\r\n\r\n        const pageWidth = rect.pageWidth;\r\n        const pageHeight = rect.height;\r\n\r\n        const x = orient === PageOrientation.RIGHT ? rect.left + rect.pageWidth : rect.left;\r\n\r\n        const y = rect.top;\r\n\r\n        if (!this.isLoad) {\r\n            this.drawLoader(ctx, { x, y }, pageWidth, pageHeight);\r\n        } else {\r\n            ctx.drawImage(this.image, x, y, pageWidth, pageHeight);\r\n        }\r\n    }\r\n\r\n    private drawLoader(\r\n        ctx: CanvasRenderingContext2D,\r\n        shiftPos: Point,\r\n        pageWidth: number,\r\n        pageHeight: number\r\n    ): void {\r\n        ctx.beginPath();\r\n        ctx.strokeStyle = 'rgb(200, 200, 200)';\r\n        ctx.fillStyle = 'rgb(255, 255, 255)';\r\n        ctx.lineWidth = 1;\r\n        ctx.rect(shiftPos.x + 1, shiftPos.y + 1, pageWidth - 1, pageHeight - 1);\r\n        ctx.stroke();\r\n        ctx.fill();\r\n\r\n        const middlePoint: Point = {\r\n            x: shiftPos.x + pageWidth / 2,\r\n            y: shiftPos.y + pageHeight / 2,\r\n        };\r\n\r\n        ctx.beginPath();\r\n        ctx.lineWidth = 10;\r\n        ctx.arc(\r\n            middlePoint.x,\r\n            middlePoint.y,\r\n            20,\r\n            this.loadingAngle,\r\n            (3 * Math.PI) / 2 + this.loadingAngle\r\n        );\r\n        ctx.stroke();\r\n        ctx.closePath();\r\n\r\n        this.loadingAngle += 0.07;\r\n        if (this.loadingAngle >= 2 * Math.PI) {\r\n            this.loadingAngle = 0;\r\n        }\r\n    }\r\n\r\n    public load(): void {\r\n        if (!this.isLoad)\r\n            this.image.onload = (): void => {\r\n                this.isLoad = true;\r\n            };\r\n    }\r\n\r\n    public newTemporaryCopy(): Page {\r\n        return this;\r\n    }\r\n\r\n    public getTemporaryCopy(): Page {\r\n        return this;\r\n    }\r\n\r\n    public hideTemporaryCopy(): void {\r\n        return;\r\n    }\r\n}\r\n","import { Point, Rect, Segment } from './BasicTypes';\r\n\r\n/**\r\n * A class containing helping mathematical methods\r\n */\r\nexport class Helper {\r\n    /**\r\n     * Get the distance between two points\r\n     *\r\n     * @param {Point} point1\r\n     * @param {Point} point2\r\n     */\r\n    public static GetDistanceBetweenTwoPoint(point1: Point, point2: Point): number {\r\n        if (point1 === null || point2 === null) {\r\n            return Infinity;\r\n        }\r\n\r\n        return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));\r\n    }\r\n\r\n    /**\r\n     * Get the length of the line segment\r\n     *\r\n     * @param {Segment} segment\r\n     */\r\n    public static GetSegmentLength(segment: Segment): number {\r\n        return Helper.GetDistanceBetweenTwoPoint(segment[0], segment[1]);\r\n    }\r\n\r\n    /**\r\n     * Get the angle between two lines\r\n     *\r\n     * @param {Segment} line1\r\n     * @param {Segment} line2\r\n     */\r\n    public static GetAngleBetweenTwoLine(line1: Segment, line2: Segment): number {\r\n        const A1 = line1[0].y - line1[1].y;\r\n        const A2 = line2[0].y - line2[1].y;\r\n\r\n        const B1 = line1[1].x - line1[0].x;\r\n        const B2 = line2[1].x - line2[0].x;\r\n\r\n        return Math.acos((A1 * A2 + B1 * B2) / (Math.sqrt(A1 * A1 + B1 * B1) * Math.sqrt(A2 * A2 + B2 * B2)));\r\n    }\r\n\r\n    /**\r\n     * Check for a point in a rectangle\r\n     *\r\n     * @param {Rect} rect\r\n     * @param {Point} pos\r\n     *\r\n     * @returns {Point} If the point enters the rectangle its coordinates will be returned, otherwise - null\r\n     */\r\n    public static PointInRect(rect: Rect, pos: Point): Point {\r\n        if (pos === null) {\r\n            return null;\r\n        }\r\n\r\n        if (\r\n            pos.x >= rect.left &&\r\n            pos.x <= rect.width + rect.left &&\r\n            pos.y >= rect.top &&\r\n            pos.y <= rect.top + rect.height\r\n        ) {\r\n            return pos;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Transform point coordinates to a given angle\r\n     *\r\n     * @param {Point} transformedPoint - Point to rotate\r\n     * @param {Point} startPoint - Transformation reference point\r\n     * @param {number} angle - Rotation angle (in radians)\r\n     *\r\n     * @returns {Point} Point coordinates after rotation\r\n     */\r\n    public static GetRotatedPoint(transformedPoint: Point, startPoint: Point, angle: number): Point {\r\n        return {\r\n            x: transformedPoint.x * Math.cos(angle) + transformedPoint.y * Math.sin(angle) + startPoint.x,\r\n            y: transformedPoint.y * Math.cos(angle) - transformedPoint.x * Math.sin(angle) + startPoint.y,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Limit a point \"linePoint\" to a given circle centered at point \"startPoint\" and a given radius\r\n     *\r\n     * @param {Point} startPoint - Circle center\r\n     * @param {number} radius - Circle radius\r\n     * @param {Point} limitedPoint - Сhecked point\r\n     *\r\n     * @returns {Point} If \"linePoint\" enters the circle, then its coordinates are returned.\r\n     * Else will be returned the intersection point between the line ([startPoint, linePoint]) and the circle\r\n     */\r\n    public static LimitPointToCircle(startPoint: Point, radius: number, limitedPoint: Point): Point {\r\n        // If \"linePoint\" enters the circle, do nothing\r\n        if (Helper.GetDistanceBetweenTwoPoint(startPoint, limitedPoint) <= radius) {\r\n            return limitedPoint;\r\n        }\r\n\r\n        const a = startPoint.x;\r\n        const b = startPoint.y;\r\n        const n = limitedPoint.x;\r\n        const m = limitedPoint.y;\r\n\r\n        // Find the intersection between the line at two points: (startPoint and limitedPoint) and the circle.\r\n        let x = Math.sqrt((Math.pow(radius, 2) * Math.pow(a - n, 2)) / (Math.pow(a - n, 2) + Math.pow(b - m, 2))) + a;\r\n        if (limitedPoint.x < 0) {\r\n            x *= -1;\r\n        }\r\n\r\n        let y = ((x - a) * (b - m)) / (a - n) + b;\r\n        if (a - n + b === 0) {\r\n            y = radius;\r\n        }\r\n\r\n        return { x, y };\r\n    }\r\n\r\n    /**\r\n     * Find the intersection of two lines bounded by a rectangle \"rectBorder\"\r\n     *\r\n     * @param {Rect} rectBorder\r\n     * @param {Segment} one\r\n     * @param {Segment} two\r\n     *\r\n     * @returns {Point} The intersection point, or \"null\" if it does not exist, or it lies outside the rectangle \"rectBorder\"\r\n     */\r\n    public static GetIntersectBetweenTwoSegment(rectBorder: Rect, one: Segment, two: Segment): Point {\r\n        return Helper.PointInRect(rectBorder, Helper.GetIntersectBeetwenTwoLine(one, two));\r\n    }\r\n\r\n    /**\r\n     * Find the intersection point of two lines\r\n     *\r\n     * @param one\r\n     * @param two\r\n     *\r\n     * @returns {Point} The intersection point, or \"null\" if it does not exist\r\n     * @throws Error if the segments are on the same line\r\n     */\r\n    public static GetIntersectBeetwenTwoLine(one: Segment, two: Segment): Point {\r\n        const A1 = one[0].y - one[1].y;\r\n        const A2 = two[0].y - two[1].y;\r\n\r\n        const B1 = one[1].x - one[0].x;\r\n        const B2 = two[1].x - two[0].x;\r\n\r\n        const C1 = one[0].x * one[1].y - one[1].x * one[0].y;\r\n        const C2 = two[0].x * two[1].y - two[1].x * two[0].y;\r\n\r\n        const det1 = A1 * C2 - A2 * C1;\r\n        const det2 = B1 * C2 - B2 * C1;\r\n\r\n        const x = -((C1 * B2 - C2 * B1) / (A1 * B2 - A2 * B1));\r\n        const y = -((A1 * C2 - A2 * C1) / (A1 * B2 - A2 * B1));\r\n\r\n        if (isFinite(x) && isFinite(y)) {\r\n            return { x, y };\r\n        } else {\r\n            if (Math.abs(det1 - det2) < 0.1) throw new Error('Segment included');\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get a list of coordinates (step: 1px) between two points\r\n     *\r\n     * @param pointOne\r\n     * @param pointTwo\r\n     *\r\n     * @returns {Point[]}\r\n     */\r\n    public static GetCordsFromTwoPoint(pointOne: Point, pointTwo: Point): Point[] {\r\n        const sizeX = Math.abs(pointOne.x - pointTwo.x);\r\n        const sizeY = Math.abs(pointOne.y - pointTwo.y);\r\n\r\n        const lengthLine = Math.max(sizeX, sizeY);\r\n\r\n        const result: Point[] = [pointOne];\r\n\r\n        function getCord(c1: number, c2: number, size: number, length: number, index: number): number {\r\n            if (c2 > c1) {\r\n                return c1 + index * (size / length);\r\n            } else if (c2 < c1) {\r\n                return c1 - index * (size / length);\r\n            }\r\n\r\n            return c1;\r\n        }\r\n\r\n        for (let i = 1; i <= lengthLine; i += 1) {\r\n            result.push({\r\n                x: getCord(pointOne.x, pointTwo.x, sizeX, lengthLine, i),\r\n                y: getCord(pointOne.y, pointTwo.y, sizeY, lengthLine, i),\r\n            });\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n","import { Helper } from '../Helper';\r\nimport { Point, Rect, RectPoints, Segment } from '../BasicTypes';\r\nimport { FlipCorner, FlipDirection } from './Flip';\r\n\r\n/**\r\n * Class representing mathematical methods for calculating page position (rotation angle, clip area ...)\r\n */\r\nexport class FlipCalculation {\r\n    /** Calculated rotation angle to flipping page */\r\n    private angle: number;\r\n    /** Calculated position to flipping page */\r\n    private position: Point;\r\n\r\n    private rect: RectPoints;\r\n\r\n    /** The point of intersection of the page with the borders of the book */\r\n    private topIntersectPoint: Point = null; // With top border\r\n    private sideIntersectPoint: Point = null; // With side border\r\n    private bottomIntersectPoint: Point = null; // With bottom border\r\n\r\n    private readonly pageWidth: number;\r\n    private readonly pageHeight: number;\r\n\r\n    /**\r\n     * @constructor\r\n     *\r\n     * @param {FlipDirection} direction - Flipping direction\r\n     * @param {FlipCorner} corner - Flipping corner\r\n     * @param pageWidth - Current page width\r\n     * @param pageHeight - Current page height\r\n     */\r\n    constructor(\r\n        private direction: FlipDirection,\r\n        private corner: FlipCorner,\r\n\r\n        pageWidth: string,\r\n        pageHeight: string\r\n    ) {\r\n        this.pageWidth = parseInt(pageWidth, 10);\r\n        this.pageHeight = parseInt(pageHeight, 10);\r\n    }\r\n\r\n    /**\r\n     * The main calculation method\r\n     * \r\n     * @param {Point} localPos - Touch Point Coordinates (relative active page!)\r\n     * \r\n     * @returns {boolean} True - if the calculations were successful, false if errors occurred\r\n     */\r\n    public calc(localPos: Point): boolean {\r\n        try {\r\n            // Find: page rotation angle and active corner position\r\n            this.position = this.calcAngleAndPosition(localPos);\r\n            // Find the intersection points of the scrolling page and the book\r\n            this.calculateIntersectPoint(this.position);\r\n\r\n            return true;\r\n        } catch (e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the crop area for the flipping page\r\n     * \r\n     * @returns {Point[]} Polygon page\r\n     */\r\n    public getFlippingClipArea(): Point[] {\r\n        const result = [];\r\n        let clipBottom = false;\r\n\r\n        result.push(this.rect.topLeft);\r\n        result.push(this.topIntersectPoint);\r\n\r\n        if (this.sideIntersectPoint === null) {\r\n            clipBottom = true;\r\n        } else {\r\n            result.push(this.sideIntersectPoint);\r\n\r\n            if (this.bottomIntersectPoint === null) clipBottom = false;\r\n        }\r\n\r\n        result.push(this.bottomIntersectPoint);\r\n\r\n        if (clipBottom || this.corner === FlipCorner.BOTTOM) {\r\n            result.push(this.rect.bottomLeft);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get the crop area for the page that is below the page to be flipped\r\n     * \r\n     * @returns {Point[]} Polygon page\r\n     */\r\n    public getBottomClipArea(): Point[] {\r\n        const result = [];\r\n\r\n        result.push(this.topIntersectPoint);\r\n\r\n        if (this.corner === FlipCorner.TOP) {\r\n            result.push({ x: this.pageWidth, y: 0 });\r\n        } else {\r\n            if (this.topIntersectPoint !== null) {\r\n                result.push({ x: this.pageWidth, y: 0 });\r\n            }\r\n            result.push({ x: this.pageWidth, y: this.pageHeight });\r\n        }\r\n\r\n        if (this.sideIntersectPoint !== null) {\r\n            if (\r\n                Helper.GetDistanceBetweenTwoPoint(\r\n                    this.sideIntersectPoint,\r\n                    this.topIntersectPoint\r\n                ) >= 10\r\n            )\r\n                result.push(this.sideIntersectPoint);\r\n        } else {\r\n            if (this.corner === FlipCorner.TOP) {\r\n                result.push({ x: this.pageWidth, y: this.pageHeight });\r\n            }\r\n        }\r\n\r\n        result.push(this.bottomIntersectPoint);\r\n        result.push(this.topIntersectPoint);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get page rotation angle\r\n     */\r\n    public getAngle(): number {\r\n        if (this.direction === FlipDirection.FORWARD) {\r\n            return -this.angle;\r\n        }\r\n\r\n        return this.angle;\r\n    }\r\n\r\n    /**\r\n     * Get page area while flipping\r\n     */\r\n    public getRect(): RectPoints {\r\n        return this.rect;\r\n    }\r\n\r\n    /**\r\n     * Get the position of the active angle when turning\r\n     */\r\n    public getPosition(): Point {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Get the active corner of the page (which pull)\r\n     */\r\n    public getActiveCorner(): Point {\r\n        if (this.direction === FlipDirection.FORWARD) {\r\n            return this.rect.topLeft;\r\n        }\r\n\r\n        return this.rect.topRight;\r\n    }\r\n\r\n    /**\r\n     * Get flipping direction\r\n     */\r\n    public getDirection(): FlipDirection {\r\n        return this.direction;\r\n    }\r\n\r\n    /**\r\n     * Get flipping progress (0-100)\r\n     */\r\n    public getFlippingProgress(): number {\r\n        return Math.abs(((this.position.x - this.pageWidth) / (2 * this.pageWidth)) * 100);\r\n    }\r\n    \r\n    /**\r\n     * Get flipping corner position (top, bottom)\r\n     */\r\n    public getCorner(): FlipCorner {\r\n        return this.corner;\r\n    }\r\n\r\n    /**\r\n     * Get start position for the page that is below the page to be flipped\r\n     */\r\n    public getBottomPagePosition(): Point {\r\n        if (this.direction === FlipDirection.BACK) {\r\n            return { x: this.pageWidth, y: 0 };\r\n        }\r\n\r\n        return { x: 0, y: 0 };\r\n    }\r\n\r\n    /**\r\n     * Get the starting position of the shadow\r\n     */\r\n    public getShadowStartPoint(): Point {\r\n        if (this.corner === FlipCorner.TOP) {\r\n            return this.topIntersectPoint;\r\n        } else {\r\n            if (this.sideIntersectPoint !== null) return this.sideIntersectPoint;\r\n\r\n            return this.topIntersectPoint;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the rotate angle of the shadow\r\n     */\r\n    public getShadowAngle(): number {\r\n        const angle = Helper.GetAngleBetweenTwoLine(this.getSegmentToShadowLine(), [\r\n            { x: 0, y: 0 },\r\n            { x: this.pageWidth, y: 0 },\r\n        ]);\r\n\r\n        if (this.direction === FlipDirection.FORWARD) {\r\n            return angle;\r\n        }\r\n\r\n        return Math.PI - angle;\r\n    }\r\n\r\n    private calcAngleAndPosition(pos: Point): Point {\r\n        let result = pos;\r\n\r\n        this.updateAngleAndGeometry(result);\r\n\r\n        if (this.corner === FlipCorner.TOP) {\r\n            result = this.checkPositionAtCenterLine(\r\n                result,\r\n                { x: 0, y: 0 },\r\n                { x: 0, y: this.pageHeight }\r\n            );\r\n        } else {\r\n            result = this.checkPositionAtCenterLine(\r\n                result,\r\n                { x: 0, y: this.pageHeight },\r\n                { x: 0, y: 0 }\r\n            );\r\n        }\r\n\r\n        if (Math.abs(result.x - this.pageWidth) < 1 && Math.abs(result.y) < 1) {\r\n            throw new Error('Point is too small');\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private updateAngleAndGeometry(pos: Point): void {\r\n        this.angle = this.calculateAngle(pos);\r\n        this.rect = this.getPageRect(pos);\r\n    }\r\n\r\n    private calculateAngle(pos: Point): number {\r\n        const left = this.pageWidth - pos.x + 1;\r\n        const top = this.corner === FlipCorner.BOTTOM ? this.pageHeight - pos.y : pos.y;\r\n\r\n        let angle = 2 * Math.acos(left / Math.sqrt(top * top + left * left));\r\n\r\n        if (top < 0) angle = -angle;\r\n\r\n        const da = Math.PI - angle;\r\n        if (!isFinite(angle) || (da >= 0 && da < 0.003))\r\n            throw new Error('The G point is too small');\r\n\r\n        if (this.corner === FlipCorner.BOTTOM) angle = -angle;\r\n\r\n        return angle;\r\n    }\r\n\r\n\r\n    private getPageRect(localPos: Point): RectPoints {\r\n        if (this.corner === FlipCorner.TOP) {\r\n            return this.getRectFromBasePoint(\r\n                [\r\n                    { x: 0, y: 0 },\r\n                    { x: this.pageWidth, y: 0 },\r\n                    { x: 0, y: this.pageHeight },\r\n                    { x: this.pageWidth, y: this.pageHeight },\r\n                ],\r\n                localPos\r\n            );\r\n        }\r\n\r\n        return this.getRectFromBasePoint(\r\n            [\r\n                { x: 0, y: -this.pageHeight },\r\n                { x: this.pageWidth, y: -this.pageHeight },\r\n                { x: 0, y: 0 },\r\n                { x: this.pageWidth, y: 0 },\r\n            ],\r\n            localPos\r\n        );\r\n    }\r\n\r\n    private getRectFromBasePoint(points: Point[], localPos: Point): RectPoints {\r\n        return {\r\n            topLeft: this.getRotatedPoint(points[0], localPos),\r\n            topRight: this.getRotatedPoint(points[1], localPos),\r\n            bottomLeft: this.getRotatedPoint(points[2], localPos),\r\n            bottomRight: this.getRotatedPoint(points[3], localPos),\r\n        };\r\n    }\r\n\r\n    private getRotatedPoint(transformedPoint: Point, startPoint: Point): Point {\r\n        return {\r\n            x:\r\n                transformedPoint.x * Math.cos(this.angle) +\r\n                transformedPoint.y * Math.sin(this.angle) +\r\n                startPoint.x,\r\n            y:\r\n                transformedPoint.y * Math.cos(this.angle) -\r\n                transformedPoint.x * Math.sin(this.angle) +\r\n                startPoint.y,\r\n        };\r\n    }\r\n\r\n    private calculateIntersectPoint(pos: Point): void {\r\n        const boundRect: Rect = {\r\n            left: -1,\r\n            top: -1,\r\n            width: this.pageWidth + 2,\r\n            height: this.pageHeight + 2,\r\n        };\r\n\r\n        if (this.corner === FlipCorner.TOP) {\r\n            this.topIntersectPoint = Helper.GetIntersectBetweenTwoSegment(\r\n                boundRect,\r\n                [pos, this.rect.topRight],\r\n                [\r\n                    { x: 0, y: 0 },\r\n                    { x: this.pageWidth, y: 0 },\r\n                ]\r\n            );\r\n\r\n            this.sideIntersectPoint = Helper.GetIntersectBetweenTwoSegment(\r\n                boundRect,\r\n                [pos, this.rect.bottomLeft],\r\n                [\r\n                    { x: this.pageWidth, y: 0 },\r\n                    { x: this.pageWidth, y: this.pageHeight },\r\n                ]\r\n            );\r\n\r\n            this.bottomIntersectPoint = Helper.GetIntersectBetweenTwoSegment(\r\n                boundRect,\r\n                [this.rect.bottomLeft, this.rect.bottomRight],\r\n                [\r\n                    { x: 0, y: this.pageHeight },\r\n                    { x: this.pageWidth, y: this.pageHeight },\r\n                ]\r\n            );\r\n        } else {\r\n            this.topIntersectPoint = Helper.GetIntersectBetweenTwoSegment(\r\n                boundRect,\r\n                [this.rect.topLeft, this.rect.topRight],\r\n                [\r\n                    { x: 0, y: 0 },\r\n                    { x: this.pageWidth, y: 0 },\r\n                ]\r\n            );\r\n\r\n            this.sideIntersectPoint = Helper.GetIntersectBetweenTwoSegment(\r\n                boundRect,\r\n                [pos, this.rect.topLeft],\r\n                [\r\n                    { x: this.pageWidth, y: 0 },\r\n                    { x: this.pageWidth, y: this.pageHeight },\r\n                ]\r\n            );\r\n\r\n            this.bottomIntersectPoint = Helper.GetIntersectBetweenTwoSegment(\r\n                boundRect,\r\n                [this.rect.bottomLeft, this.rect.bottomRight],\r\n                [\r\n                    { x: 0, y: this.pageHeight },\r\n                    { x: this.pageWidth, y: this.pageHeight },\r\n                ]\r\n            );\r\n        }\r\n    }\r\n\r\n    private checkPositionAtCenterLine(\r\n        checkedPos: Point,\r\n        centerOne: Point,\r\n        centerTwo: Point\r\n    ): Point {\r\n        let result = checkedPos;\r\n\r\n        const tmp = Helper.LimitPointToCircle(centerOne, this.pageWidth, result);\r\n        if (result !== tmp) {\r\n            result = tmp;\r\n            this.updateAngleAndGeometry(result);\r\n        }\r\n\r\n        const rad = Math.sqrt(Math.pow(this.pageWidth, 2) + Math.pow(this.pageHeight, 2));\r\n\r\n        let checkPointOne = this.rect.bottomRight;\r\n        let checkPointTwo = this.rect.topLeft;\r\n\r\n        if (this.corner === FlipCorner.BOTTOM) {\r\n            checkPointOne = this.rect.topRight;\r\n            checkPointTwo = this.rect.bottomLeft;\r\n        }\r\n\r\n        if (checkPointOne.x <= 0) {\r\n            const bottomPoint = Helper.LimitPointToCircle(centerTwo, rad, checkPointTwo);\r\n\r\n            if (bottomPoint !== result) {\r\n                result = bottomPoint;\r\n                this.updateAngleAndGeometry(result);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private getSegmentToShadowLine(): Segment {\r\n        const first = this.getShadowStartPoint();\r\n\r\n        const second =\r\n            first !== this.sideIntersectPoint && this.sideIntersectPoint !== null\r\n                ? this.sideIntersectPoint\r\n                : this.bottomIntersectPoint;\r\n\r\n        return [first, second];\r\n    }\r\n}\r\n","/**\r\n * Book size calculation type\r\n */\r\nexport enum SizeType {\r\n  /** Dimensions are fixed */\r\n  FIXED = 'fixed',\r\n  /** Dimensions are calculated based on the parent element */\r\n  STRETCH = 'stretch',\r\n}\r\n\r\n/**\r\n * Configuration object\r\n */\r\nexport interface FlipSetting {\r\n  /** Page number from which to start viewing */\r\n  startPage: number;\r\n  /** Whether the book will be stretched under the parent element or not */\r\n  size: SizeType;\r\n\r\n  width: number;\r\n  height: number;\r\n\r\n  minWidth: number;\r\n  maxWidth: number;\r\n  minHeight: number;\r\n  maxHeight: number;\r\n\r\n  /** Draw shadows or not when page flipping */\r\n  drawShadow: boolean;\r\n  /** Flipping animation time */\r\n  flippingTime: number;\r\n\r\n  /** Enable switching to portrait mode */\r\n  usePortrait: boolean;\r\n  /** Initial value to z-index */\r\n  startZIndex: number;\r\n  /** If this value is true, the parent element will be equal to the size of the book */\r\n  autoSize: boolean;\r\n  /** Shadow intensity (1: max intensity, 0: hidden shadows) */\r\n  maxShadowOpacity: number;\r\n\r\n  /** If this value is true, the first and the last pages will be marked as hard and will be shown in single page mode */\r\n  showCover: boolean;\r\n  /** Disable content scrolling when touching a book on mobile devices */\r\n  mobileScrollSupport: boolean;\r\n\r\n  /** Set the forward event of clicking on child elements (e.g. buttons, links) */\r\n  clickEventForward: boolean | string[];\r\n\r\n  /** Using mouse and touch events to page flipping */\r\n  useMouseEvents: boolean;\r\n\r\n  swipeDistance: number;\r\n\r\n  /** if this value is true, fold the corners of the book when the mouse pointer is over them. */\r\n  showPageCorners: boolean;\r\n}\r\n\r\nexport class Settings {\r\n  private _default: FlipSetting = {\r\n    startPage: 0,\r\n    size: SizeType.FIXED,\r\n    width: 0,\r\n    height: 0,\r\n    minWidth: 0,\r\n    maxWidth: 0,\r\n    minHeight: 0,\r\n    maxHeight: 0,\r\n    drawShadow: true,\r\n    flippingTime: 1000,\r\n    usePortrait: true,\r\n    startZIndex: 0,\r\n    autoSize: true,\r\n    maxShadowOpacity: 1,\r\n    showCover: false,\r\n    mobileScrollSupport: true,\r\n    swipeDistance: 30,\r\n    clickEventForward: false,\r\n    useMouseEvents: true,\r\n    showPageCorners: true,\r\n  };\r\n\r\n  /**\r\n   * Processing parameters received from the user. Substitution default values\r\n   *\r\n   * @param userSetting\r\n   * @returns {FlipSetting} Сonfiguration object\r\n   */\r\n  public getSettings(userSetting: Record<string, number | string | boolean>): FlipSetting {\r\n    const result = this._default;\r\n    Object.assign(result, userSetting);\r\n\r\n    if (result.size !== SizeType.STRETCH && result.size !== SizeType.FIXED)\r\n      throw new Error('Invalid size type. Available only \"fixed\" and \"stretch\" value');\r\n\r\n    if (result.width <= 0 || result.height <= 0)\r\n      throw new Error('Invalid width or height');\r\n\r\n    if (result.flippingTime <= 0)\r\n      throw new Error('Invalid flipping time');\r\n\r\n    if (result.size === SizeType.STRETCH) {\r\n      if (result.minWidth <= 0) result.minWidth = 100;\r\n\r\n      if (result.maxWidth < result.minWidth) result.maxWidth = 2000;\r\n\r\n      if (result.minHeight <= 0) result.minHeight = 100;\r\n\r\n      if (result.maxHeight < result.minHeight) result.maxHeight = 2000;\r\n    } else {\r\n      result.minWidth = result.width;\r\n      result.maxWidth = result.width;\r\n      result.minHeight = result.height;\r\n      result.maxHeight = result.height;\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n","import { PageFlip } from '../PageFlip';\r\nimport { Point, PageRect, RectPoints } from '../BasicTypes';\r\nimport { FlipDirection } from '../Flip/Flip';\r\nimport { Page, PageOrientation } from '../Page/Page';\r\nimport { FlipSetting, SizeType } from '../Settings';\r\n\r\ntype FrameAction = () => void;\r\ntype AnimationSuccessAction = () => void;\r\n\r\n/**\r\n * Type describing calculated values for drop shadows\r\n */\r\ntype Shadow = {\r\n  /** Shadow Position Start Point */\r\n  pos: Point;\r\n  /** The angle of the shadows relative to the book */\r\n  angle: number;\r\n  /** Base width shadow */\r\n  width: number;\r\n  /** Base shadow opacity */\r\n  opacity: number;\r\n  /** Flipping Direction, the direction of the shadow gradients */\r\n  direction: FlipDirection;\r\n  /** Flipping progress in percent (0 - 100) */\r\n  progress: number;\r\n};\r\n\r\n/**\r\n * Type describing the animation process\r\n * Only one animation process can be started at a same time\r\n */\r\ntype AnimationProcess = {\r\n  /** List of frames in playback order. Each frame is a function. */\r\n  frames: FrameAction[];\r\n  /** Total animation duration */\r\n  duration: number;\r\n  /** Animation duration of one frame */\r\n  durationFrame: number;\r\n  /** Сallback at the end of the animation */\r\n  onAnimateEnd: AnimationSuccessAction;\r\n  /** Animation start time (Global Timer) */\r\n  startedAt: number;\r\n};\r\n\r\n/**\r\n * Book orientation\r\n */\r\nexport enum Orientation {\r\n  PORTRAIT = 'portrait',\r\n  LANDSCAPE = 'landscape',\r\n}\r\n\r\n/**\r\n * Class responsible for rendering the book\r\n */\r\nexport abstract class Render {\r\n  protected readonly setting: FlipSetting;\r\n  protected readonly app: PageFlip;\r\n\r\n  /** Left static book page */\r\n  protected leftPage: Page = null;\r\n  /** Right static book page */\r\n  protected rightPage: Page = null;\r\n\r\n  /** Page currently flipping */\r\n  protected flippingPage: Page = null;\r\n  /** Next page at the time of flipping */\r\n  protected bottomPage: Page = null;\r\n\r\n  /** Current flipping direction */\r\n  protected direction: FlipDirection = null;\r\n  /** Current book orientation */\r\n  protected orientation: Orientation = null;\r\n  /** Сurrent state of the shadows */\r\n  protected shadow: Shadow = null;\r\n  /** Сurrent animation process */\r\n  protected animation: AnimationProcess = null;\r\n  /** Page borders while flipping */\r\n  protected pageRect: RectPoints = null;\r\n  /** Current book area */\r\n  private boundsRect: PageRect = null;\r\n\r\n  /** Timer started from start of rendering */\r\n  protected timer = 0;\r\n\r\n  /**\r\n   * Safari browser definitions for resolving a bug with a css property clip-area\r\n   *\r\n   * https://bugs.webkit.org/show_bug.cgi?id=126207\r\n   */\r\n  private safari = false;\r\n\r\n  protected constructor(app: PageFlip, setting: FlipSetting) {\r\n    this.setting = setting;\r\n    this.app = app;\r\n\r\n    // detect safari\r\n    const regex = new RegExp('Version\\\\/[\\\\d\\\\.]+.*Safari/');\r\n    this.safari = regex.exec(window.navigator.userAgent) !== null;\r\n  }\r\n\r\n  /**\r\n   * Rendering action on each requestAnimationFrame call. The entire rendering process is performed only in this method\r\n   */\r\n  protected abstract drawFrame(): void;\r\n\r\n  /**\r\n   * Executed when requestAnimationFrame is called. Performs the current animation process and call drawFrame()\r\n   *\r\n   * @param timer\r\n   */\r\n  private render(timer: number): void {\r\n    if (this.animation !== null) {\r\n      // Find current frame of animation\r\n      const frameIndex = Math.round(\r\n        (timer - this.animation.startedAt) / this.animation.durationFrame\r\n      );\r\n\r\n      if (frameIndex < this.animation.frames.length) {\r\n        this.animation.frames[frameIndex]();\r\n      } else {\r\n        this.animation.onAnimateEnd();\r\n        this.animation = null;\r\n      }\r\n    }\r\n\r\n    this.timer = timer;\r\n    this.drawFrame();\r\n  }\r\n\r\n  /**\r\n   * Running requestAnimationFrame, and rendering process\r\n   */\r\n  public start(): void {\r\n    this.update();\r\n\r\n    const loop = (timer: number): void => {\r\n      this.render(timer);\r\n      requestAnimationFrame(loop);\r\n    };\r\n\r\n    requestAnimationFrame(loop);\r\n  }\r\n\r\n  /**\r\n   * Start a new animation process\r\n   *\r\n   * @param {FrameAction[]} frames - Frame list\r\n   * @param {number} duration - total animation duration\r\n   * @param {AnimationSuccessAction} onAnimateEnd - Animation callback function\r\n   */\r\n  public startAnimation(\r\n    frames: FrameAction[],\r\n    duration: number,\r\n    onAnimateEnd: AnimationSuccessAction\r\n  ): void {\r\n    this.finishAnimation(); // finish the previous animation process\r\n\r\n    this.animation = {\r\n      frames,\r\n      duration,\r\n      durationFrame: duration / frames.length,\r\n      onAnimateEnd,\r\n      startedAt: this.timer,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * End the current animation process and call the callback\r\n   */\r\n  public finishAnimation(): void {\r\n    if (this.animation !== null) {\r\n      this.animation.frames[this.animation.frames.length - 1]();\r\n\r\n      if (this.animation.onAnimateEnd !== null) {\r\n        this.animation.onAnimateEnd();\r\n      }\r\n    }\r\n\r\n    this.animation = null;\r\n  }\r\n\r\n  /**\r\n   * Recalculate the size of the displayed area, and update the page orientation\r\n   */\r\n  public update(): void {\r\n    this.boundsRect = null;\r\n    const orientation = this.calculateBoundsRect();\r\n\r\n    if (this.orientation !== orientation) {\r\n      this.orientation = orientation;\r\n      this.app.updateOrientation(orientation);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate the size and position of the book depending on the parent element and configuration parameters\r\n   */\r\n  private calculateBoundsRect(): Orientation {\r\n    let orientation = Orientation.LANDSCAPE;\r\n\r\n    const blockWidth = this.getBlockWidth();\r\n    const middlePoint: Point = {\r\n      x: blockWidth / 2,\r\n      y: this.getBlockHeight() / 2,\r\n    };\r\n\r\n    const ratio = this.setting.width / this.setting.height;\r\n\r\n    let pageWidth = this.setting.width;\r\n    let pageHeight = this.setting.height;\r\n\r\n    let left = middlePoint.x - pageWidth;\r\n\r\n    if (this.setting.size === SizeType.STRETCH) {\r\n      if (blockWidth < this.setting.minWidth * 2 && this.app.getSettings().usePortrait)\r\n        orientation = Orientation.PORTRAIT;\r\n\r\n      pageWidth =\r\n        orientation === Orientation.PORTRAIT\r\n          ? this.getBlockWidth()\r\n          : this.getBlockWidth() / 2;\r\n\r\n      if (pageWidth > this.setting.maxWidth) pageWidth = this.setting.maxWidth;\r\n\r\n      pageHeight = pageWidth / ratio;\r\n      if (pageHeight > this.getBlockHeight()) {\r\n        pageHeight = this.getBlockHeight();\r\n        pageWidth = pageHeight * ratio;\r\n      }\r\n\r\n      left =\r\n        orientation === Orientation.PORTRAIT\r\n          ? middlePoint.x - pageWidth / 2 - pageWidth\r\n          : middlePoint.x - pageWidth;\r\n    } else {\r\n      if (blockWidth < pageWidth * 2) {\r\n        if (this.app.getSettings().usePortrait) {\r\n          orientation = Orientation.PORTRAIT;\r\n          left = middlePoint.x - pageWidth / 2 - pageWidth;\r\n        }\r\n      }\r\n    }\r\n\r\n    this.boundsRect = {\r\n      left,\r\n      top: middlePoint.y - pageHeight / 2,\r\n      width: pageWidth * 2,\r\n      height: pageHeight,\r\n      pageWidth: pageWidth,\r\n    };\r\n\r\n    return orientation;\r\n  }\r\n\r\n  /**\r\n   * Set the current parameters of the drop shadow\r\n   *\r\n   * @param {Point} pos - Shadow Position Start Point\r\n   * @param {number} angle - The angle of the shadows relative to the book\r\n   * @param {number} progress - Flipping progress in percent (0 - 100)\r\n   * @param {FlipDirection} direction - Flipping Direction, the direction of the shadow gradients\r\n   */\r\n  public setShadowData(\r\n    pos: Point,\r\n    angle: number,\r\n    progress: number,\r\n    direction: FlipDirection\r\n  ): void {\r\n    if (!this.app.getSettings().drawShadow) return;\r\n\r\n    const maxShadowOpacity = 100 * this.getSettings().maxShadowOpacity;\r\n\r\n    this.shadow = {\r\n      pos,\r\n      angle,\r\n      width: (((this.getRect().pageWidth * 3) / 4) * progress) / 100,\r\n      opacity: ((100 - progress) * maxShadowOpacity) / 100 / 100,\r\n      direction,\r\n      progress: progress * 2,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clear shadow\r\n   */\r\n  public clearShadow(): void {\r\n    this.shadow = null;\r\n  }\r\n\r\n  /**\r\n   * Get parent block offset width\r\n   */\r\n  public getBlockWidth(): number {\r\n    return this.app.getUI().getDistElement().offsetWidth;\r\n  }\r\n\r\n  /**\r\n   * Get parent block offset height\r\n   */\r\n  public getBlockHeight(): number {\r\n    return this.app.getUI().getDistElement().offsetHeight;\r\n  }\r\n\r\n  /**\r\n   * Get current flipping direction\r\n   */\r\n  public getDirection(): FlipDirection {\r\n    return this.direction;\r\n  }\r\n\r\n  /**\r\n   * Сurrent size and position of the book\r\n   */\r\n  public getRect(): PageRect {\r\n    if (this.boundsRect === null) this.calculateBoundsRect();\r\n\r\n    return this.boundsRect;\r\n  }\r\n\r\n  /**\r\n   * Get configuration object\r\n   */\r\n  public getSettings(): FlipSetting {\r\n    return this.app.getSettings();\r\n  }\r\n\r\n  /**\r\n   * Get current book orientation\r\n   */\r\n  public getOrientation(): Orientation {\r\n    return this.orientation;\r\n  }\r\n\r\n  /**\r\n   * Set page area while flipping\r\n   *\r\n   * @param direction\r\n   */\r\n  public setPageRect(pageRect: RectPoints): void {\r\n    this.pageRect = pageRect;\r\n  }\r\n\r\n  /**\r\n   * Set flipping direction\r\n   *\r\n   * @param direction\r\n   */\r\n  public setDirection(direction: FlipDirection): void {\r\n    this.direction = direction;\r\n  }\r\n\r\n  /**\r\n   * Set right static book page\r\n   *\r\n   * @param page\r\n   */\r\n  public setRightPage(page: Page): void {\r\n    if (page !== null) page.setOrientation(PageOrientation.RIGHT);\r\n\r\n    this.rightPage = page;\r\n  }\r\n\r\n  /**\r\n   * Set left static book page\r\n   * @param page\r\n   */\r\n  public setLeftPage(page: Page): void {\r\n    if (page !== null) page.setOrientation(PageOrientation.LEFT);\r\n\r\n    this.leftPage = page;\r\n  }\r\n\r\n  /**\r\n   * Set next page at the time of flipping\r\n   * @param page\r\n   */\r\n  public setBottomPage(page: Page): void {\r\n    if (page !== null)\r\n      page.setOrientation(\r\n        this.direction === FlipDirection.BACK ? PageOrientation.LEFT : PageOrientation.RIGHT\r\n      );\r\n\r\n    this.bottomPage = page;\r\n  }\r\n\r\n  /**\r\n   * Set currently flipping page\r\n   *\r\n   * @param page\r\n   */\r\n  public setFlippingPage(page: Page): void {\r\n    if (page !== null)\r\n      page.setOrientation(\r\n        this.direction === FlipDirection.FORWARD &&\r\n          this.orientation !== Orientation.PORTRAIT\r\n          ? PageOrientation.LEFT\r\n          : PageOrientation.RIGHT\r\n      );\r\n\r\n    this.flippingPage = page;\r\n  }\r\n\r\n  /**\r\n   * Coordinate conversion function. Window coordinates -> to book coordinates\r\n   *\r\n   * @param {Point} pos - Global coordinates relative to the window\r\n   * @returns {Point} Coordinates relative to the book\r\n   */\r\n  public convertToBook(pos: Point): Point {\r\n    const rect = this.getRect();\r\n\r\n    return {\r\n      x: pos.x - rect.left,\r\n      y: pos.y - rect.top,\r\n    };\r\n  }\r\n\r\n  public isSafari(): boolean {\r\n    return this.safari;\r\n  }\r\n\r\n  /**\r\n   * Coordinate conversion function. Window coordinates -> to current coordinates of the working page\r\n   *\r\n   * @param {Point} pos - Global coordinates relative to the window\r\n   * @param {FlipDirection} direction  - Current flipping direction\r\n   *\r\n   * @returns {Point} Coordinates relative to the work page\r\n   */\r\n  public convertToPage(pos: Point, direction?: FlipDirection): Point {\r\n    if (!direction) direction = this.direction;\r\n\r\n    const rect = this.getRect();\r\n    const x =\r\n      direction === FlipDirection.FORWARD\r\n        ? pos.x - rect.left - rect.width / 2\r\n        : rect.width / 2 - pos.x + rect.left;\r\n\r\n    return {\r\n      x,\r\n      y: pos.y - rect.top,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Coordinate conversion function. Coordinates relative to the work page -> Window coordinates\r\n   *\r\n   * @param {Point} pos - Coordinates relative to the work page\r\n   * @param {FlipDirection} direction  - Current flipping direction\r\n   *\r\n   * @returns {Point} Global coordinates relative to the window\r\n   */\r\n  public convertToGlobal(pos: Point, direction?: FlipDirection): Point {\r\n    if (!direction) direction = this.direction;\r\n\r\n    if (pos == null) return null;\r\n\r\n    const rect = this.getRect();\r\n\r\n    const x =\r\n      direction === FlipDirection.FORWARD\r\n        ? pos.x + rect.left + rect.width / 2\r\n        : rect.width / 2 - pos.x + rect.left;\r\n\r\n    return {\r\n      x,\r\n      y: pos.y + rect.top,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Casting the coordinates of the corners of the rectangle in the coordinates relative to the window\r\n   *\r\n   * @param {RectPoints} rect - Coordinates of the corners of the rectangle relative to the work page\r\n   * @param {FlipDirection} direction  - Current flipping direction\r\n   *\r\n   * @returns {RectPoints} Coordinates of the corners of the rectangle relative to the window\r\n   */\r\n  public convertRectToGlobal(rect: RectPoints, direction?: FlipDirection): RectPoints {\r\n    if (!direction) direction = this.direction;\r\n\r\n    return {\r\n      topLeft: this.convertToGlobal(rect.topLeft, direction),\r\n      topRight: this.convertToGlobal(rect.topRight, direction),\r\n      bottomLeft: this.convertToGlobal(rect.bottomLeft, direction),\r\n      bottomRight: this.convertToGlobal(rect.bottomRight, direction),\r\n    };\r\n  }\r\n}\r\n","import { Orientation, Render } from '../Render/Render';\r\nimport { Page, PageDensity } from '../Page/Page';\r\nimport { PageFlip } from '../PageFlip';\r\nimport { FlipDirection } from '../Flip/Flip';\r\n\r\ntype NumberArray = number[];\r\n\r\n/**\r\n * Сlass representing a collection of pages\r\n */\r\nexport abstract class PageCollection {\r\n    protected readonly app: PageFlip;\r\n    protected readonly render: Render;\r\n    protected readonly isShowCover: boolean;\r\n\r\n    /** Pages List */\r\n    protected pages: Page[] = [];\r\n    /** Index of the current page in list */\r\n    protected currentPageIndex = 0;\r\n\r\n    /** Number of the current spread in book */\r\n    protected currentSpreadIndex = 0;\r\n    /**  Two-page spread in landscape mode */\r\n    protected landscapeSpread: NumberArray[] = [];\r\n    /**  One-page spread in portrait mode */\r\n    protected portraitSpread: NumberArray[] = [];\r\n\r\n    protected constructor(app: PageFlip, render: Render) {\r\n        this.render = render;\r\n        this.app = app;\r\n\r\n        this.currentPageIndex = 0;\r\n        this.isShowCover = this.app.getSettings().showCover;\r\n    }\r\n\r\n    /**\r\n     * Load pages\r\n     */\r\n    public abstract load(): void;\r\n\r\n    /**\r\n     * Clear pages list\r\n     */\r\n    public destroy(): void {\r\n        this.pages = [];\r\n    }\r\n\r\n    /**\r\n     * Split the book on the two-page spread in landscape mode and one-page spread in portrait mode\r\n     */\r\n    protected createSpread(): void {\r\n        this.landscapeSpread = [];\r\n        this.portraitSpread = [];\r\n\r\n        for (let i = 0; i < this.pages.length; i++) {\r\n            this.portraitSpread.push([i]); // In portrait mode - (one spread = one page)\r\n        }\r\n\r\n        let start = 0;\r\n        if (this.isShowCover) {\r\n            this.pages[0].setDensity(PageDensity.HARD);\r\n            this.landscapeSpread.push([start]);\r\n            start++;\r\n        }\r\n\r\n        for (let i = start; i < this.pages.length; i += 2) {\r\n            if (i < this.pages.length - 1) this.landscapeSpread.push([i, i + 1]);\r\n            else {\r\n                this.landscapeSpread.push([i]);\r\n                this.pages[i].setDensity(PageDensity.HARD);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get spread by mode (portrait or landscape)\r\n     */\r\n    protected getSpread(): NumberArray[] {\r\n        return this.render.getOrientation() === Orientation.LANDSCAPE\r\n            ? this.landscapeSpread\r\n            : this.portraitSpread;\r\n    }\r\n\r\n    /**\r\n     * Get spread index by page number\r\n     * \r\n     * @param {number} pageNum - page index\r\n     */\r\n    public getSpreadIndexByPage(pageNum: number): number {\r\n        const spread = this.getSpread();\r\n\r\n        for (let i = 0; i < spread.length; i++)\r\n            if (pageNum === spread[i][0] || pageNum === spread[i][1]) return i;\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get the total number of pages\r\n     */\r\n    public getPageCount(): number {\r\n        return this.pages.length;\r\n    }\r\n\r\n    /**\r\n     * Get the pages list\r\n     */\r\n    public getPages(): Page[] {\r\n        return this.pages;\r\n    }\r\n\r\n    /**\r\n     * Get page by index\r\n     * \r\n     * @param {number} pageIndex\r\n     */\r\n    public getPage(pageIndex: number): Page {\r\n        if (pageIndex >= 0 && pageIndex < this.pages.length) {\r\n            return this.pages[pageIndex];\r\n        }\r\n\r\n        throw new Error('Invalid page number');\r\n    }\r\n\r\n    /**\r\n     * Get the next page from the specified\r\n     * \r\n     * @param {Page} current \r\n     */\r\n    public nextBy(current: Page): Page {\r\n        const idx = this.pages.indexOf(current);\r\n\r\n        if (idx < this.pages.length - 1) return this.pages[idx + 1];\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get previous page from specified\r\n     * \r\n     * @param {Page} current \r\n     */\r\n    public prevBy(current: Page): Page {\r\n        const idx = this.pages.indexOf(current);\r\n\r\n        if (idx > 0) return this.pages[idx - 1];\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get flipping page depending on the direction\r\n     * \r\n     * @param {FlipDirection} direction \r\n     */\r\n    public getFlippingPage(direction: FlipDirection): Page {\r\n        const current = this.currentSpreadIndex;\r\n\r\n        if (this.render.getOrientation() === Orientation.PORTRAIT) {\r\n            return direction === FlipDirection.FORWARD\r\n                ? this.pages[current].newTemporaryCopy()\r\n                : this.pages[current - 1];\r\n        } else {\r\n            const spread =\r\n                direction === FlipDirection.FORWARD\r\n                    ? this.getSpread()[current + 1]\r\n                    : this.getSpread()[current - 1];\r\n\r\n            if (spread.length === 1) return this.pages[spread[0]];\r\n\r\n            return direction === FlipDirection.FORWARD\r\n                ? this.pages[spread[0]]\r\n                : this.pages[spread[1]];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get Next page at the time of flipping\r\n     * \r\n     * @param {FlipDirection}  direction \r\n     */\r\n    public getBottomPage(direction: FlipDirection): Page {\r\n        const current = this.currentSpreadIndex;\r\n\r\n        if (this.render.getOrientation() === Orientation.PORTRAIT) {\r\n            return direction === FlipDirection.FORWARD\r\n                ? this.pages[current + 1]\r\n                : this.pages[current - 1];\r\n        } else {\r\n            const spread =\r\n                direction === FlipDirection.FORWARD\r\n                    ? this.getSpread()[current + 1]\r\n                    : this.getSpread()[current - 1];\r\n\r\n            if (spread.length === 1) return this.pages[spread[0]];\r\n\r\n            return direction === FlipDirection.FORWARD\r\n                ? this.pages[spread[1]]\r\n                : this.pages[spread[0]];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Show next spread\r\n     */\r\n    public showNext(): void {\r\n        if (this.currentSpreadIndex < this.getSpread().length) {\r\n            this.currentSpreadIndex++;\r\n            this.showSpread();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Show prev spread\r\n     */\r\n    public showPrev(): void {\r\n        if (this.currentSpreadIndex > 0) {\r\n            this.currentSpreadIndex--;\r\n            this.showSpread();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the number of the current spread in book\r\n     */\r\n    public getCurrentPageIndex(): number {\r\n        return this.currentPageIndex;\r\n    }\r\n\r\n    /**\r\n     * Show specified page\r\n     * @param {number} pageNum - Page index (from 0s)\r\n     */\r\n    public show(pageNum: number = null): void {\r\n        if (pageNum === null) pageNum = this.currentPageIndex;\r\n\r\n        if (pageNum < 0 || pageNum >= this.pages.length) return;\r\n\r\n        const spreadIndex = this.getSpreadIndexByPage(pageNum);\r\n        if (spreadIndex !== null) {\r\n            this.currentSpreadIndex = spreadIndex;\r\n            this.showSpread();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Index of the current page in list\r\n     */\r\n    public getCurrentSpreadIndex(): number {\r\n        return this.currentSpreadIndex;\r\n    }\r\n\r\n    /**\r\n     * Set new spread index as current\r\n     * \r\n     * @param {number} newIndex - new spread index\r\n     */\r\n    public setCurrentSpreadIndex(newIndex: number): void {\r\n        if (newIndex >= 0 && newIndex < this.getSpread().length) {\r\n            this.currentSpreadIndex = newIndex;\r\n        } else {\r\n            throw new Error('Invalid page');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Show current spread\r\n     */\r\n    private showSpread(): void {\r\n        const spread = this.getSpread()[this.currentSpreadIndex];\r\n\r\n        if (spread.length === 2) {\r\n            this.render.setLeftPage(this.pages[spread[0]]);\r\n            this.render.setRightPage(this.pages[spread[1]]);\r\n        } else {\r\n            if (this.render.getOrientation() === Orientation.LANDSCAPE) {\r\n                if (spread[0] === this.pages.length - 1) {\r\n                    this.render.setLeftPage(this.pages[spread[0]]);\r\n                    this.render.setRightPage(null);\r\n                } else {\r\n                    this.render.setLeftPage(null);\r\n                    this.render.setRightPage(this.pages[spread[0]]);\r\n                }\r\n            } else {\r\n                this.render.setLeftPage(null);\r\n                this.render.setRightPage(this.pages[spread[0]]);\r\n            }\r\n        }\r\n\r\n        this.currentPageIndex = spread[0];\r\n        this.app.updatePageIndex(this.currentPageIndex);\r\n    }\r\n}\r\n","import { ImagePage } from '../Page/ImagePage';\r\nimport { Render } from '../Render/Render';\r\nimport { PageCollection } from './PageCollection';\r\nimport { PageFlip } from '../PageFlip';\r\nimport { PageDensity } from '../Page/Page';\r\n\r\n/**\r\n * Сlass representing a collection of pages as images on the canvas\r\n */\r\nexport class ImagePageCollection extends PageCollection {\r\n    private readonly imagesHref: string[];\r\n\r\n    constructor(app: PageFlip, render: Render, imagesHref: string[]) {\r\n        super(app, render);\r\n\r\n        this.imagesHref = imagesHref;\r\n    }\r\n\r\n    public load(): void {\r\n        for (const href of this.imagesHref) {\r\n            const page = new ImagePage(this.render, href, PageDensity.SOFT);\r\n\r\n            page.load();\r\n            this.pages.push(page);\r\n        }\r\n\r\n        this.createSpread();\r\n    }\r\n}\r\n","import { Page, PageDensity, PageOrientation } from './Page';\r\nimport { Render } from '../Render/Render';\r\nimport { Helper } from '../Helper';\r\nimport { FlipDirection } from '../Flip/Flip';\r\nimport { Point } from '../BasicTypes';\r\n\r\n/**\r\n * Class representing a book page as a HTML Element\r\n */\r\nexport class HTMLPage extends Page {\r\n  private readonly element: HTMLElement;\r\n  private copiedElement: HTMLElement = null;\r\n\r\n  private temporaryCopy: Page = null;\r\n\r\n  private isLoad = false;\r\n\r\n  constructor(render: Render, element: HTMLElement, density: PageDensity) {\r\n    super(render, density);\r\n\r\n    this.element = element;\r\n    this.element.classList.add('stf__item');\r\n    this.element.classList.add('--' + density);\r\n  }\r\n\r\n  public newTemporaryCopy(): Page {\r\n    if (this.nowDrawingDensity === PageDensity.HARD) {\r\n      return this;\r\n    }\r\n\r\n    if (this.temporaryCopy === null) {\r\n      this.copiedElement = this.element.cloneNode(true) as HTMLElement;\r\n      this.element.parentElement.appendChild(this.copiedElement);\r\n\r\n      this.temporaryCopy = new HTMLPage(\r\n        this.render,\r\n        this.copiedElement,\r\n        this.nowDrawingDensity\r\n      );\r\n    }\r\n\r\n    return this.getTemporaryCopy();\r\n  }\r\n\r\n  public getTemporaryCopy(): Page {\r\n    return this.temporaryCopy;\r\n  }\r\n\r\n  public hideTemporaryCopy(): void {\r\n    if (this.temporaryCopy !== null) {\r\n      this.copiedElement.remove();\r\n      this.copiedElement = null;\r\n      this.temporaryCopy = null;\r\n    }\r\n  }\r\n\r\n  public draw(tempDensity?: PageDensity): void {\r\n    const density = tempDensity ? tempDensity : this.nowDrawingDensity;\r\n\r\n    const pagePos = this.render.convertToGlobal(this.state.position);\r\n    const pageWidth = this.render.getRect().pageWidth;\r\n    const pageHeight = this.render.getRect().height;\r\n\r\n    this.element.classList.remove('--simple');\r\n\r\n    // const commonStyle = `\r\n    //         display: block;\r\n    //         z-index: ${this.element.style.zIndex};\r\n    //         left: 0;\r\n    //         top: 0;\r\n    //         width: ${pageWidth}px;\r\n    //         height: ${pageHeight}px;\r\n    //     `;\r\n\r\n    this.element.style.display = 'block';\r\n    this.element.style.left = '0';\r\n    this.element.style.top = '0';\r\n\r\n    this.element.style.width = pageWidth + 'px';\r\n    this.element.style.height = pageHeight + 'px';\r\n\r\n    density === PageDensity.HARD\r\n      ? this.drawHard()\r\n      : this.drawSoft(pagePos);\r\n  }\r\n\r\n  private drawHard(commonStyle = ''): void {\r\n    const pos = this.render.getRect().left + this.render.getRect().width / 2;\r\n\r\n    const angle = this.state.hardDrawingAngle;\r\n\r\n    this.element.style.backfaceVisibility = 'hidden';\r\n    this.element.style.setProperty('-webkit-backface-visibility', 'hidden');\r\n    if (this.orientation === PageOrientation.LEFT) {\r\n      this.element.style.transformOrigin = this.render.getRect().pageWidth + 'px 0';\r\n      this.element.style.transform =\r\n        'translate3d(' + 0 + 'px, ' + 0 + 'px, 0) rotateY(' + angle + 'deg)';\r\n    } else {\r\n      this.element.style.transformOrigin = '0 0';\r\n      this.element.style.transform =\r\n        'translate3d(' + pos + 'px, ' + 0 + 'px, 0) rotateY(' + angle + 'deg)';\r\n    }\r\n    this.element.style.clipPath = 'none';\r\n    this.element.style.setProperty('-webkit-clip-path', 'none');\r\n\r\n    // const newStyle =\r\n    //   commonStyle +\r\n    //   `\r\n    //             backface-visibility: hidden;\r\n    //             -webkit-backface-visibility: hidden;\r\n    //             clip-path: none;\r\n    //             -webkit-clip-path: none;\r\n    //         ` +\r\n    //   (this.orientation === PageOrientation.LEFT\r\n    //     ? `transform-origin: ${this.render.getRect().pageWidth}px 0; \r\n    //                transform: translate3d(0, 0, 0) rotateY(${angle}deg);`\r\n    //     : `transform-origin: 0 0; \r\n    //                transform: translate3d(${pos}px, 0, 0) rotateY(${angle}deg);`);\r\n\r\n    // this.element.style.cssText = newStyle;\r\n\r\n\r\n  }\r\n\r\n  private drawSoft(position: Point, commonStyle = ''): void {\r\n    let polygon = 'polygon( ';\r\n    for (const p of this.state.area) {\r\n      if (p !== null) {\r\n        let g =\r\n          this.render.getDirection() === FlipDirection.BACK\r\n            ? {\r\n              x: -p.x + this.state.position.x,\r\n              y: p.y - this.state.position.y,\r\n            }\r\n            : {\r\n              x: p.x - this.state.position.x,\r\n              y: p.y - this.state.position.y,\r\n            };\r\n\r\n        g = Helper.GetRotatedPoint(g, { x: 0, y: 0 }, this.state.angle);\r\n        polygon += g.x + 'px ' + g.y + 'px, ';\r\n      }\r\n    }\r\n    polygon = polygon.slice(0, -2);\r\n    polygon += ')';\r\n\r\n    // const newStyle =\r\n    //   commonStyle +\r\n    //   `transform-origin: 0 0; clip-path: ${polygon}; -webkit-clip-path: ${polygon};` +\r\n    //   (this.render.isSafari() && this.state.angle === 0\r\n    //     ? `transform: translate(${position.x}px, ${position.y}px);`\r\n    //     : `transform: translate3d(${position.x}px, ${position.y}px, 0) rotate(${this.state.angle}rad);`);\r\n\r\n    // this.element.style.cssText = newStyle;\r\n\r\n    this.element.style.transformOrigin = '0 0';\r\n    if (this.render.isSafari() && this.state.angle === 0) {\r\n      this.element.style.transform = 'translate(' + position.x + 'px, ' + position.y + 'px)';\r\n    } else {\r\n      this.element.style.transform =\r\n        'translate3d(' +\r\n        position.x +\r\n        'px, ' +\r\n        position.y +\r\n        'px, 0) rotate(' +\r\n        this.state.angle +\r\n        'rad)';\r\n    }\r\n\r\n    this.element.style.clipPath = polygon;\r\n    this.element.style.setProperty('-webkit-clip-path', polygon);\r\n  }\r\n\r\n  public simpleDraw(orient: PageOrientation): void {\r\n    if (this.element.classList.contains('--simple')) return;\r\n\r\n    const rect = this.render.getRect();\r\n\r\n    const pageWidth = rect.pageWidth;\r\n    const pageHeight = rect.height;\r\n\r\n    const x = orient === PageOrientation.RIGHT ? rect.left + rect.pageWidth : rect.left;\r\n\r\n    const y = rect.top;\r\n\r\n    this.element.classList.add('--simple');\r\n    this.element.style.cssText = `\r\n            position: absolute; \r\n            display: block; \r\n            height: ${pageHeight}px; \r\n            left: ${x}px; \r\n            top: ${y}px; \r\n            width: ${pageWidth}px; \r\n            z-index: ${this.render.getSettings().startZIndex + 1};`;\r\n\r\n    // this.element.style.position = 'absolute';\r\n    // this.element.style.display = 'block';\r\n    // this.element.style.height = pageHeight + 'px';\r\n    // this.element.style.top = y + 'px';\r\n    // this.element.style.left = x + 'px';\r\n    // this.element.style.width = pageWidth + 'px';\r\n    // this.element.style.zIndex = String(this.render.getSettings().startZIndex + 1);\r\n  }\r\n\r\n  public getElement(): HTMLElement {\r\n    return this.element;\r\n  }\r\n\r\n  public load(): void {\r\n    this.isLoad = true;\r\n  }\r\n\r\n  public setOrientation(orientation: PageOrientation): void {\r\n    super.setOrientation(orientation);\r\n    this.element.classList.remove('--left', '--right');\r\n\r\n    this.element.classList.add(orientation === PageOrientation.RIGHT ? '--right' : '--left');\r\n  }\r\n\r\n  public setDrawingDensity(density: PageDensity): void {\r\n    this.element.classList.remove('--soft', '--hard');\r\n    this.element.classList.add('--' + density);\r\n\r\n    super.setDrawingDensity(density);\r\n  }\r\n}\r\n","import { HTMLPage } from '../Page/HTMLPage';\r\nimport { Render } from '../Render/Render';\r\nimport { PageCollection } from './PageCollection';\r\nimport { PageFlip } from '../PageFlip';\r\nimport { PageDensity } from '../Page/Page';\r\n\r\n/**\r\n * Сlass representing a collection of pages as HTML Element\r\n */\r\nexport class HTMLPageCollection extends PageCollection {\r\n    private readonly element: HTMLElement;\r\n    private readonly pagesElement: NodeListOf<HTMLElement> | HTMLElement[];\r\n\r\n    constructor(\r\n        app: PageFlip,\r\n        render: Render,\r\n        element: HTMLElement,\r\n        items: NodeListOf<HTMLElement> | HTMLElement[]\r\n    ) {\r\n        super(app, render);\r\n\r\n        this.element = element;\r\n        this.pagesElement = items;\r\n    }\r\n\r\n    public load(): void {\r\n        for (const pageElement of this.pagesElement) {\r\n            const page = new HTMLPage(\r\n                this.render,\r\n                pageElement,\r\n                pageElement.dataset['density'] === 'hard' ? PageDensity.HARD : PageDensity.SOFT\r\n            );\r\n\r\n            page.load();\r\n            this.pages.push(page);\r\n        }\r\n\r\n        this.createSpread();\r\n    }\r\n}\r\n","import { Orientation, Render } from './Render';\r\nimport { PageFlip } from '../PageFlip';\r\nimport { FlipDirection } from '../Flip/Flip';\r\nimport { PageOrientation } from '../Page/Page';\r\nimport { FlipSetting } from '../Settings';\r\n\r\n/**\r\n * Class responsible for rendering the Canvas book\r\n */\r\nexport class CanvasRender extends Render {\r\n    private readonly canvas: HTMLCanvasElement;\r\n    private readonly ctx: CanvasRenderingContext2D;\r\n\r\n    constructor(app: PageFlip, setting: FlipSetting, inCanvas: HTMLCanvasElement) {\r\n        super(app, setting);\r\n\r\n        this.canvas = inCanvas;\r\n        this.ctx = inCanvas.getContext('2d');\r\n    }\r\n\r\n    public getContext(): CanvasRenderingContext2D {\r\n        return this.ctx;\r\n    }\r\n\r\n    protected drawFrame(): void {\r\n        this.clear();\r\n\r\n        if (this.orientation !== Orientation.PORTRAIT)\r\n            if (this.leftPage != null) this.leftPage.simpleDraw(PageOrientation.LEFT);\r\n\r\n        if (this.rightPage != null) this.rightPage.simpleDraw(PageOrientation.RIGHT);\r\n\r\n        if (this.bottomPage != null) this.bottomPage.draw();\r\n\r\n        this.drawBookShadow();\r\n\r\n        if (this.flippingPage != null) this.flippingPage.draw();\r\n\r\n        if (this.shadow != null) {\r\n            this.drawOuterShadow();\r\n            this.drawInnerShadow();\r\n        }\r\n\r\n        const rect = this.getRect();\r\n\r\n        if (this.orientation === Orientation.PORTRAIT) {\r\n            this.ctx.beginPath();\r\n            this.ctx.rect(rect.left + rect.pageWidth, rect.top, rect.width, rect.height);\r\n            this.ctx.clip();\r\n        }\r\n    }\r\n\r\n    private drawBookShadow(): void {\r\n        const rect = this.getRect();\r\n\r\n        this.ctx.save();\r\n        this.ctx.beginPath();\r\n\r\n        const shadowSize = rect.width / 20;\r\n        this.ctx.rect(rect.left, rect.top, rect.width, rect.height);\r\n\r\n        const shadowPos = { x: rect.left + rect.width / 2 - shadowSize / 2, y: 0 };\r\n        this.ctx.translate(shadowPos.x, shadowPos.y);\r\n\r\n        const outerGradient = this.ctx.createLinearGradient(0, 0, shadowSize, 0);\r\n\r\n        outerGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');\r\n        outerGradient.addColorStop(0.4, 'rgba(0, 0, 0, 0.2)');\r\n        outerGradient.addColorStop(0.49, 'rgba(0, 0, 0, 0.1)');\r\n        outerGradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.5)');\r\n        outerGradient.addColorStop(0.51, 'rgba(0, 0, 0, 0.4)');\r\n        outerGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\r\n\r\n        this.ctx.clip();\r\n\r\n        this.ctx.fillStyle = outerGradient;\r\n        this.ctx.fillRect(0, 0, shadowSize, rect.height * 2);\r\n\r\n        this.ctx.restore();\r\n    }\r\n\r\n    private drawOuterShadow(): void {\r\n        const rect = this.getRect();\r\n\r\n        this.ctx.save();\r\n        this.ctx.beginPath();\r\n\r\n        this.ctx.rect(rect.left, rect.top, rect.width, rect.height);\r\n\r\n        const shadowPos = this.convertToGlobal({ x: this.shadow.pos.x, y: this.shadow.pos.y });\r\n        this.ctx.translate(shadowPos.x, shadowPos.y);\r\n\r\n        this.ctx.rotate(Math.PI + this.shadow.angle + Math.PI / 2);\r\n\r\n        const outerGradient = this.ctx.createLinearGradient(0, 0, this.shadow.width, 0);\r\n\r\n        if (this.shadow.direction === FlipDirection.FORWARD) {\r\n            this.ctx.translate(0, -100);\r\n            outerGradient.addColorStop(0, 'rgba(0, 0, 0, ' + this.shadow.opacity + ')');\r\n            outerGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\r\n        } else {\r\n            this.ctx.translate(-this.shadow.width, -100);\r\n            outerGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');\r\n            outerGradient.addColorStop(1, 'rgba(0, 0, 0, ' + this.shadow.opacity + ')');\r\n        }\r\n\r\n        this.ctx.clip();\r\n\r\n        this.ctx.fillStyle = outerGradient;\r\n        this.ctx.fillRect(0, 0, this.shadow.width, rect.height * 2);\r\n\r\n        this.ctx.restore();\r\n    }\r\n\r\n    private drawInnerShadow(): void {\r\n        const rect = this.getRect();\r\n\r\n        this.ctx.save();\r\n        this.ctx.beginPath();\r\n\r\n        const shadowPos = this.convertToGlobal({ x: this.shadow.pos.x, y: this.shadow.pos.y });\r\n\r\n        const pageRect = this.convertRectToGlobal(this.pageRect);\r\n        this.ctx.moveTo(pageRect.topLeft.x, pageRect.topLeft.y);\r\n        this.ctx.lineTo(pageRect.topRight.x, pageRect.topRight.y);\r\n        this.ctx.lineTo(pageRect.bottomRight.x, pageRect.bottomRight.y);\r\n        this.ctx.lineTo(pageRect.bottomLeft.x, pageRect.bottomLeft.y);\r\n        this.ctx.translate(shadowPos.x, shadowPos.y);\r\n\r\n        this.ctx.rotate(Math.PI + this.shadow.angle + Math.PI / 2);\r\n\r\n        const isw = (this.shadow.width * 3) / 4;\r\n        const innerGradient = this.ctx.createLinearGradient(0, 0, isw, 0);\r\n\r\n        if (this.shadow.direction === FlipDirection.FORWARD) {\r\n            this.ctx.translate(-isw, -100);\r\n\r\n            innerGradient.addColorStop(1, 'rgba(0, 0, 0, ' + this.shadow.opacity + ')');\r\n            innerGradient.addColorStop(0.9, 'rgba(0, 0, 0, 0.05)');\r\n            innerGradient.addColorStop(0.7, 'rgba(0, 0, 0, ' + this.shadow.opacity + ')');\r\n            innerGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');\r\n        } else {\r\n            this.ctx.translate(0, -100);\r\n\r\n            innerGradient.addColorStop(0, 'rgba(0, 0, 0, ' + this.shadow.opacity + ')');\r\n            innerGradient.addColorStop(0.1, 'rgba(0, 0, 0, 0.05)');\r\n            innerGradient.addColorStop(0.3, 'rgba(0, 0, 0, ' + this.shadow.opacity + ')');\r\n            innerGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\r\n        }\r\n\r\n        this.ctx.clip();\r\n\r\n        this.ctx.fillStyle = innerGradient;\r\n        this.ctx.fillRect(0, 0, isw, rect.height * 2);\r\n\r\n        this.ctx.restore();\r\n    }\r\n\r\n    private clear(): void {\r\n        this.ctx.fillStyle = 'white';\r\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n}\r\n","import { PageFlip } from '../PageFlip';\r\nimport { Point } from '../BasicTypes';\r\nimport { FlipSetting, SizeType } from '../Settings';\r\nimport { FlipCorner, FlippingState } from '../Flip/Flip';\r\nimport { Orientation } from '../Render/Render';\r\n\r\ntype SwipeData = {\r\n  point: Point;\r\n  time: number;\r\n};\r\n\r\n/**\r\n * UI Class, represents work with DOM\r\n */\r\nexport abstract class UI {\r\n  protected readonly app: PageFlip;\r\n  protected readonly wrapper: HTMLElement;\r\n  protected distElement: HTMLElement;\r\n\r\n  private touchPoint: SwipeData = null;\r\n  private readonly swipeTimeout = 250;\r\n  private readonly swipeDistance: number;\r\n\r\n  private onResize = (): void => {\r\n    this.update();\r\n  };\r\n\r\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {HTMLElement} inBlock - Root HTML Element\r\n   * @param {PageFlip} app - PageFlip instanse\r\n   * @param {FlipSetting} setting - Configuration object\r\n   */\r\n  protected constructor(inBlock: HTMLElement, app: PageFlip, setting: FlipSetting) {\r\n    inBlock.classList.add('stf__parent');\r\n    // Add first wrapper\r\n    inBlock.insertAdjacentHTML('afterbegin', '<div class=\"stf__wrapper\"></div>');\r\n\r\n    this.wrapper = inBlock.querySelector('.stf__wrapper');\r\n\r\n    this.app = app;\r\n\r\n    const k = this.app.getSettings().usePortrait ? 1 : 2;\r\n\r\n    // Setting block sizes based on configuration\r\n    inBlock.style.minWidth = setting.minWidth * k + 'px';\r\n    inBlock.style.minHeight = setting.minHeight + 'px';\r\n\r\n    if (setting.size === SizeType.FIXED) {\r\n      inBlock.style.minWidth = setting.width * k + 'px';\r\n      inBlock.style.minHeight = setting.height + 'px';\r\n    }\r\n\r\n    if (setting.autoSize) {\r\n      inBlock.style.width = '100%';\r\n      inBlock.style.maxWidth = setting.maxWidth * 2 + 'px';\r\n    }\r\n\r\n    inBlock.style.display = 'block';\r\n\r\n    window.addEventListener('resize', this.onResize, false);\r\n    this.swipeDistance = setting.swipeDistance;\r\n  }\r\n\r\n  /**\r\n   * Destructor. Remove all HTML elements and all event handlers\r\n   */\r\n  public destroy(): void {\r\n    if (this.app.getSettings().useMouseEvents) this.removeHandlers();\r\n\r\n    this.distElement.remove();\r\n    this.wrapper.remove();\r\n  }\r\n\r\n  /**\r\n   * Updating child components when resizing\r\n   */\r\n  public abstract update(): void;\r\n\r\n  /**\r\n   * Get parent element for book\r\n   *\r\n   * @returns {HTMLElement}\r\n   */\r\n  public getDistElement(): HTMLElement {\r\n    return this.distElement;\r\n  }\r\n\r\n  /**\r\n   * Get wrapper element\r\n   *\r\n   * @returns {HTMLElement}\r\n   */\r\n  public getWrapper(): HTMLElement {\r\n    return this.wrapper;\r\n  }\r\n\r\n  /**\r\n   * Updates styles and sizes based on book orientation\r\n   *\r\n   * @param {Orientation} orientation - New book orientation\r\n   */\r\n  public setOrientationStyle(orientation: Orientation): void {\r\n    this.wrapper.classList.remove('--portrait', '--landscape');\r\n\r\n    if (orientation === Orientation.PORTRAIT) {\r\n      if (this.app.getSettings().autoSize)\r\n        this.wrapper.style.paddingBottom =\r\n          (this.app.getSettings().height / this.app.getSettings().width) * 100 + '%';\r\n\r\n      this.wrapper.classList.add('--portrait');\r\n    } else {\r\n      if (this.app.getSettings().autoSize)\r\n        this.wrapper.style.paddingBottom =\r\n          (this.app.getSettings().height / (this.app.getSettings().width * 2)) * 100 +\r\n          '%';\r\n\r\n      this.wrapper.classList.add('--landscape');\r\n    }\r\n\r\n    this.update();\r\n  }\r\n\r\n  protected removeHandlers(): void {\r\n    window.removeEventListener('resize', this.onResize);\r\n\r\n    this.distElement.removeEventListener('mousedown', this.onMouseDown);\r\n    this.distElement.removeEventListener('touchstart', this.onTouchStart);\r\n    window.removeEventListener('mousemove', this.onMouseMove);\r\n    window.removeEventListener('touchmove', this.onTouchMove);\r\n    window.removeEventListener('mouseup', this.onMouseUp);\r\n    window.removeEventListener('touchend', this.onTouchEnd);\r\n  }\r\n\r\n  protected setHandlers(): void {\r\n    if (!this.app.getSettings().useMouseEvents) return;\r\n\r\n    this.distElement.addEventListener('mousedown', this.onMouseDown);\r\n    this.distElement.addEventListener('touchstart', this.onTouchStart);\r\n    window.addEventListener('mousemove', this.onMouseMove);\r\n    window.addEventListener('touchmove', this.onTouchMove, {\r\n      passive: !this.app.getSettings().mobileScrollSupport,\r\n    });\r\n    window.addEventListener('mouseup', this.onMouseUp);\r\n    window.addEventListener('touchend', this.onTouchEnd);\r\n  }\r\n\r\n  /**\r\n   * Convert global coordinates to relative book coordinates\r\n   *\r\n   * @param x\r\n   * @param y\r\n   */\r\n  private getMousePos(x: number, y: number): Point {\r\n    const rect = this.distElement.getBoundingClientRect();\r\n\r\n    return {\r\n      x: x - rect.left,\r\n      y: y - rect.top,\r\n    };\r\n  }\r\n\r\n  private checkTarget(target: EventTarget): boolean {\r\n    if (this.app.getSettings().clickEventForward === true) return false;\r\n    if (Array.isArray(this.app.getSettings().clickEventForward)) {\r\n      if ((this.app.getSettings().clickEventForward as string[]).includes((target as HTMLElement).tagName.toLowerCase())) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private onMouseDown = (e: MouseEvent): void => {\r\n    if (this.checkTarget(e.target)) {\r\n      const pos = this.getMousePos(e.clientX, e.clientY);\r\n\r\n      this.app.startUserTouch(pos);\r\n\r\n      e.preventDefault();\r\n    }\r\n  };\r\n\r\n  private onTouchStart = (e: TouchEvent): void => {\r\n    if (this.checkTarget(e.target)) {\r\n      if (e.changedTouches.length > 0) {\r\n        const t = e.changedTouches[0];\r\n        const pos = this.getMousePos(t.clientX, t.clientY);\r\n\r\n        this.touchPoint = {\r\n          point: pos,\r\n          time: Date.now(),\r\n        };\r\n\r\n        // part of swipe detection\r\n        setTimeout(() => {\r\n          if (this.touchPoint !== null) {\r\n            this.app.startUserTouch(pos);\r\n          }\r\n        }, this.swipeTimeout);\r\n\r\n        if (!this.app.getSettings().mobileScrollSupport) e.preventDefault();\r\n      }\r\n    }\r\n  };\r\n\r\n  private onMouseUp = (e: MouseEvent): void => {\r\n    const pos = this.getMousePos(e.clientX, e.clientY);\r\n\r\n    this.app.userStop(pos);\r\n  };\r\n\r\n  private onMouseMove = (e: MouseEvent): void => {\r\n    const pos = this.getMousePos(e.clientX, e.clientY);\r\n\r\n    this.app.userMove(pos, false);\r\n  };\r\n\r\n  private onTouchMove = (e: TouchEvent): void => {\r\n    if (e.changedTouches.length > 0) {\r\n      const t = e.changedTouches[0];\r\n      const pos = this.getMousePos(t.clientX, t.clientY);\r\n\r\n      if (this.app.getSettings().mobileScrollSupport) {\r\n        if (this.touchPoint !== null) {\r\n          if (\r\n            Math.abs(this.touchPoint.point.x - pos.x) > 10 ||\r\n            this.app.getState() !== FlippingState.READ\r\n          ) {\r\n            if (e.cancelable) this.app.userMove(pos, true);\r\n          }\r\n        }\r\n\r\n        if (this.app.getState() !== FlippingState.READ) {\r\n          e.preventDefault();\r\n        }\r\n      } else {\r\n        this.app.userMove(pos, true);\r\n      }\r\n    }\r\n  };\r\n\r\n  private onTouchEnd = (e: TouchEvent): void => {\r\n    if (e.changedTouches.length > 0) {\r\n      const t = e.changedTouches[0];\r\n      const pos = this.getMousePos(t.clientX, t.clientY);\r\n      let isSwipe = false;\r\n\r\n      // swipe detection\r\n      if (this.touchPoint !== null) {\r\n        const dx = pos.x - this.touchPoint.point.x;\r\n        const distY = Math.abs(pos.y - this.touchPoint.point.y);\r\n\r\n        if (\r\n          Math.abs(dx) > this.swipeDistance &&\r\n          distY < this.swipeDistance * 2 &&\r\n          Date.now() - this.touchPoint.time < this.swipeTimeout\r\n        ) {\r\n          if (dx > 0) {\r\n            this.app.flipPrev(\r\n              this.touchPoint.point.y < this.app.getRender().getRect().height / 2\r\n                ? FlipCorner.TOP\r\n                : FlipCorner.BOTTOM\r\n            );\r\n          } else {\r\n            this.app.flipNext(\r\n              this.touchPoint.point.y < this.app.getRender().getRect().height / 2\r\n                ? FlipCorner.TOP\r\n                : FlipCorner.BOTTOM\r\n            );\r\n          }\r\n          isSwipe = true;\r\n        }\r\n\r\n        this.touchPoint = null;\r\n      }\r\n\r\n      this.app.userStop(pos, isSwipe);\r\n    }\r\n  };\r\n}\r\n","import {UI} from \"./UI\";\r\nimport {PageFlip} from \"../PageFlip\";\r\nimport {FlipSetting} from \"../Settings\";\r\n\r\n/**\r\n * UI for HTML mode\r\n */\r\nexport class HTMLUI extends UI {\r\n    constructor(inBlock: HTMLElement, app: PageFlip, setting: FlipSetting, items: NodeListOf<HTMLElement> | HTMLElement[]) {\r\n        super(inBlock, app, setting);\r\n\r\n        // Second wrapper to HTML page\r\n        this.wrapper.insertAdjacentHTML('afterbegin', '<div class=\"stf__block\"></div>');\r\n\r\n        this.distElement = inBlock.querySelector('.stf__block');\r\n\r\n        for (const item of items) {\r\n            this.distElement.appendChild(item);\r\n        }\r\n\r\n        this.setHandlers();\r\n    }\r\n\r\n    /**\r\n     * Update page list from HTMLElements\r\n     * \r\n     * @param {(NodeListOf<HTMLElement>|HTMLElement[])} items - List of pages as HTML Element\r\n     */\r\n    public updateItems(items: NodeListOf<HTMLElement> | HTMLElement[]): void {\r\n        this.removeHandlers();\r\n\r\n        this.distElement.innerHTML = \"\";\r\n\r\n        for (const item of items) {\r\n            this.distElement.appendChild(item);\r\n        }\r\n\r\n        this.setHandlers();\r\n    }\r\n\r\n    public update(): void {\r\n        this.app.getRender().update();\r\n    }\r\n}","import {UI} from \"./UI\";\r\nimport {PageFlip} from \"../PageFlip\";\r\nimport {FlipSetting} from \"../Settings\";\r\n\r\n/**\r\n * UI for canvas mode\r\n */\r\nexport class CanvasUI extends UI {\r\n    private readonly canvas: HTMLCanvasElement;\r\n\r\n    constructor(inBlock: HTMLElement, app: PageFlip, setting: FlipSetting) {\r\n        super(inBlock, app, setting);\r\n\r\n        this.wrapper.innerHTML = '<canvas class=\"stf__canvas\"></canvas>';\r\n\r\n        this.canvas = inBlock.querySelectorAll('canvas')[0];\r\n\r\n        this.distElement = this.canvas;\r\n\r\n        this.resizeCanvas();\r\n        this.setHandlers();\r\n    }\r\n\r\n    private resizeCanvas(): void {\r\n        const cs = getComputedStyle(this.canvas);\r\n        const width = parseInt(cs.getPropertyValue('width'), 10);\r\n        const height = parseInt(cs.getPropertyValue('height'), 10);\r\n\r\n        this.canvas.width = width;\r\n        this.canvas.height = height;\r\n    }\r\n\r\n    /**\r\n     * Get canvas element\r\n     */\r\n    public getCanvas(): HTMLCanvasElement {\r\n        return this.canvas;\r\n    }\r\n\r\n    public update(): void {\r\n        this.resizeCanvas();\r\n        this.app.getRender().update();\r\n    }\r\n}","import { PageFlip } from '../PageFlip';\r\n\r\n/**\r\n * Data type passed to the event handler\r\n */\r\nexport type DataType = number | string | boolean | object;\r\n\r\n/**\r\n * Type of object in event handlers\r\n */\r\nexport interface WidgetEvent {\r\n    data: DataType;\r\n    object: PageFlip;\r\n}\r\n\r\ntype EventCallback = (e: WidgetEvent) => void;\r\n\r\n/**\r\n * A class implementing a basic event model\r\n */\r\nexport abstract class EventObject {\r\n    private events = new Map<string, EventCallback[]>();\r\n\r\n    /**\r\n     * Add new event handler\r\n     *\r\n     * @param {string} eventName\r\n     * @param {EventCallback} callback\r\n     */\r\n    public on(eventName: string, callback: EventCallback): EventObject {\r\n        if (!this.events.has(eventName)) {\r\n            this.events.set(eventName, [callback]);\r\n        } else {\r\n            this.events.get(eventName).push(callback);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removing all handlers from an event\r\n     *\r\n     * @param {string} event - Event name\r\n     */\r\n    public off(event: string): void {\r\n        this.events.delete(event);\r\n    }\r\n\r\n    protected trigger(eventName: string, app: PageFlip, data: DataType = null): void {\r\n        if (!this.events.has(eventName)) return;\r\n\r\n        for (const callback of this.events.get(eventName)) {\r\n            callback({ data, object: app });\r\n        }\r\n    }\r\n}\r\n","import { Orientation, Render } from './Render';\r\nimport { PageFlip } from '../PageFlip';\r\nimport { FlipDirection } from '../Flip/Flip';\r\nimport { PageDensity, PageOrientation } from '../Page/Page';\r\nimport { HTMLPage } from '../Page/HTMLPage';\r\nimport { Helper } from '../Helper';\r\nimport { FlipSetting } from '../Settings';\r\n\r\n/**\r\n * Class responsible for rendering the HTML book\r\n */\r\nexport class HTMLRender extends Render {\r\n  /** Parent HTML Element */\r\n  private readonly element: HTMLElement;\r\n\r\n  /** Pages List as HTMLElements */\r\n  private readonly items: NodeListOf<HTMLElement> | HTMLElement[];\r\n\r\n  private outerShadow: HTMLElement = null;\r\n  private innerShadow: HTMLElement = null;\r\n  private hardShadow: HTMLElement = null;\r\n  private hardInnerShadow: HTMLElement = null;\r\n\r\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {PageFlip} app - PageFlip object\r\n   * @param {FlipSetting} setting - Configuration object\r\n   * @param {HTMLElement} element - Parent HTML Element\r\n   */\r\n  constructor(\r\n    app: PageFlip,\r\n    setting: FlipSetting,\r\n    element: HTMLElement,\r\n    items: NodeListOf<HTMLElement> | HTMLElement[]\r\n  ) {\r\n    super(app, setting);\r\n\r\n    this.element = element;\r\n    this.items = items;\r\n\r\n    this.createShadows();\r\n  }\r\n\r\n  private createShadows(): void {\r\n    this.element.insertAdjacentHTML(\r\n      'beforeend',\r\n      `<div class=\"stf__outerShadow\"></div>\r\n             <div class=\"stf__innerShadow\"></div>\r\n             <div class=\"stf__hardShadow\"></div>\r\n             <div class=\"stf__hardInnerShadow\"></div>`\r\n    );\r\n\r\n    this.outerShadow = this.element.querySelector('.stf__outerShadow');\r\n    this.innerShadow = this.element.querySelector('.stf__innerShadow');\r\n    this.hardShadow = this.element.querySelector('.stf__hardShadow');\r\n    this.hardInnerShadow = this.element.querySelector('.stf__hardInnerShadow');\r\n  }\r\n\r\n  public updatePages(): void {\r\n    this.createShadows();\r\n  }\r\n\r\n  public clearShadow(): void {\r\n    super.clearShadow();\r\n\r\n    this.outerShadow.style.cssText = 'display: none';\r\n    this.innerShadow.style.cssText = 'display: none';\r\n    this.hardShadow.style.cssText = 'display: none';\r\n    this.hardInnerShadow.style.cssText = 'display: none';\r\n  }\r\n\r\n  /**\r\n   * Draw inner shadow to the hard page\r\n   */\r\n  private drawHardInnerShadow(): void {\r\n    const rect = this.getRect();\r\n\r\n    const progress =\r\n      this.shadow.progress > 100 ? 200 - this.shadow.progress : this.shadow.progress;\r\n\r\n    let innerShadowSize = ((100 - progress) * (2.5 * rect.pageWidth)) / 100 + 20;\r\n    if (innerShadowSize > rect.pageWidth) innerShadowSize = rect.pageWidth;\r\n\r\n    // let newStyle = `\r\n    //         display: block;\r\n    //         z-index: ${(this.getSettings().startZIndex + 5).toString(10)};\r\n    //         width: ${innerShadowSize}px;\r\n    //         height: ${rect.height}px;\r\n    //         background: linear-gradient(to right,\r\n    //             rgba(0, 0, 0, ${(this.shadow.opacity * progress) / 100}) 5%,\r\n    //             rgba(0, 0, 0, 0) 100%);\r\n    //         left: ${rect.left + rect.width / 2}px;\r\n    //         transform-origin: 0 0;\r\n    //     `;\r\n\r\n    // newStyle +=\r\n    //   (this.getDirection() === FlipDirection.FORWARD && this.shadow.progress > 100) ||\r\n    //     (this.getDirection() === FlipDirection.BACK && this.shadow.progress <= 100)\r\n    //     ? `transform: translate3d(0, 0, 0);`\r\n    //     : `transform: translate3d(0, 0, 0) rotateY(180deg);`;\r\n\r\n    // this.hardInnerShadow.style.cssText = newStyle;\r\n\r\n    this.hardInnerShadow.style.display = 'block';\r\n    this.hardInnerShadow.style.zIndex = (this.getSettings().startZIndex + 5).toString(10);\r\n    this.hardInnerShadow.style.width = innerShadowSize + 'px';\r\n    this.hardInnerShadow.style.height = rect.height + 'px';\r\n    this.hardInnerShadow.style.background = `linear-gradient(to right,\r\n            rgba(0, 0, 0, ${(this.shadow.opacity * progress) / 100}) 5%,\r\n            rgba(0, 0, 0, 0) 100%)`;\r\n\r\n    this.hardInnerShadow.style.left = rect.left + rect.width / 2 + 'px';\r\n    this.hardInnerShadow.style.transformOrigin = '0 0';\r\n\r\n    this.hardInnerShadow.style.transform =\r\n      (this.getDirection() === FlipDirection.FORWARD && this.shadow.progress > 100) ||\r\n        (this.getDirection() === FlipDirection.BACK && this.shadow.progress <= 100)\r\n        ? 'translate3d(0, 0, 0)'\r\n        : 'translate3d(0, 0, 0) rotateY(180deg)';\r\n  }\r\n\r\n  /**\r\n   * Draw outer shadow to the hard page\r\n   */\r\n  private drawHardOuterShadow(): void {\r\n    const rect = this.getRect();\r\n\r\n    const progress =\r\n      this.shadow.progress > 100 ? 200 - this.shadow.progress : this.shadow.progress;\r\n\r\n    let shadowSize = ((100 - progress) * (2.5 * rect.pageWidth)) / 100 + 20;\r\n    if (shadowSize > rect.pageWidth) shadowSize = rect.pageWidth;\r\n\r\n    // let newStyle = `\r\n    //         display: block;\r\n    //         z-index: ${(this.getSettings().startZIndex + 4).toString(10)};\r\n    //         width: ${shadowSize}px;\r\n    //         height: ${rect.height}px;\r\n    //         background: linear-gradient(to left, rgba(0, 0, 0, ${this.shadow.opacity\r\n    //   }) 5%, rgba(0, 0, 0, 0) 100%);\r\n    //         left: ${rect.left + rect.width / 2}px;\r\n    //         transform-origin: 0 0;\r\n    //     `;\r\n\r\n    // newStyle +=\r\n    //   (this.getDirection() === FlipDirection.FORWARD && this.shadow.progress > 100) ||\r\n    //     (this.getDirection() === FlipDirection.BACK && this.shadow.progress <= 100)\r\n    //     ? `transform: translate3d(0, 0, 0) rotateY(180deg);`\r\n    //     : `transform: translate3d(0, 0, 0);`;\r\n\r\n    // this.hardShadow.style.cssText = newStyle;\r\n\r\n    this.hardShadow.style.display = 'block';\r\n    this.hardShadow.style.zIndex = (this.getSettings().startZIndex + 4).toString(10);\r\n    this.hardShadow.style.width = shadowSize + 'px';\r\n    this.hardShadow.style.height = rect.height + 'px';\r\n    this.hardShadow.style.background = `linear-gradient(to left,\r\n            rgba(0, 0, 0, ${this.shadow.opacity}) 5%, rgba(0, 0, 0, 0) 100%)`;\r\n\r\n    this.hardShadow.style.left = rect.left + rect.width / 2 + 'px';\r\n    this.hardShadow.style.transformOrigin = '0 0';\r\n\r\n    this.hardShadow.style.transform =\r\n      (this.getDirection() === FlipDirection.FORWARD && this.shadow.progress > 100) ||\r\n        (this.getDirection() === FlipDirection.BACK && this.shadow.progress <= 100)\r\n        ? 'translate3d(0, 0, 0) rotateY(180deg)'\r\n        : 'translate3d(0, 0, 0)';\r\n  }\r\n\r\n  /**\r\n   * Draw inner shadow to the soft page\r\n   */\r\n  private drawInnerShadow(): void {\r\n    const rect = this.getRect();\r\n\r\n    const innerShadowSize = (this.shadow.width * 3) / 4;\r\n    const shadowTranslate = this.getDirection() === FlipDirection.FORWARD ? innerShadowSize : 0;\r\n\r\n    const shadowDirection =\r\n      this.getDirection() === FlipDirection.FORWARD ? 'to left' : 'to right';\r\n\r\n    const shadowPos = this.convertToGlobal(this.shadow.pos);\r\n\r\n    const angle = this.shadow.angle + (3 * Math.PI) / 2;\r\n\r\n    const clip = [\r\n      this.pageRect.topLeft,\r\n      this.pageRect.topRight,\r\n      this.pageRect.bottomRight,\r\n      this.pageRect.bottomLeft,\r\n    ];\r\n\r\n    let polygon = 'polygon( ';\r\n    for (const p of clip) {\r\n      let g =\r\n        this.getDirection() === FlipDirection.BACK\r\n          ? {\r\n            x: -p.x + this.shadow.pos.x,\r\n            y: p.y - this.shadow.pos.y,\r\n          }\r\n          : {\r\n            x: p.x - this.shadow.pos.x,\r\n            y: p.y - this.shadow.pos.y,\r\n          };\r\n\r\n      g = Helper.GetRotatedPoint(g, { x: shadowTranslate, y: 100 }, angle);\r\n\r\n      polygon += g.x + 'px ' + g.y + 'px, ';\r\n    }\r\n    polygon = polygon.slice(0, -2);\r\n    polygon += ')';\r\n\r\n    // const newStyle = `\r\n    //         display: block;\r\n    //         z-index: ${(this.getSettings().startZIndex + 10).toString(10)};\r\n    //         width: ${innerShadowSize}px;\r\n    //         height: ${rect.height * 2}px;\r\n    //         background: linear-gradient(${shadowDirection},\r\n    //             rgba(0, 0, 0, ${this.shadow.opacity}) 5%,\r\n    //             rgba(0, 0, 0, 0.05) 15%,\r\n    //             rgba(0, 0, 0, ${this.shadow.opacity}) 35%,\r\n    //             rgba(0, 0, 0, 0) 100%);\r\n    //         transform-origin: ${shadowTranslate}px 100px;\r\n    //         transform: translate3d(${shadowPos.x - shadowTranslate}px, ${shadowPos.y - 100\r\n    //   }px, 0) rotate(${angle}rad);\r\n    //         clip-path: ${polygon};\r\n    //         -webkit-clip-path: ${polygon};\r\n    //     `;\r\n\r\n    // this.innerShadow.style.cssText = newStyle;\r\n\r\n    this.innerShadow.style.display = 'block';\r\n    this.innerShadow.style.zIndex = (this.getSettings().startZIndex + 10).toString(10);\r\n    this.innerShadow.style.width = innerShadowSize + 'px';\r\n    this.innerShadow.style.height = rect.height * 2 + 'px';\r\n    this.innerShadow.style.background = `linear-gradient(${shadowDirection},\r\n            rgba(0, 0, 0, ${this.shadow.opacity}) 5%,\r\n            rgba(0, 0, 0, 0.05) 15%,\r\n            rgba(0, 0, 0, ${this.shadow.opacity}) 35%,\r\n            rgba(0, 0, 0, 0) 100%)`;\r\n\r\n    this.innerShadow.style.transformOrigin = shadowTranslate + 'px 100px';\r\n    this.innerShadow.style.transform = `translate3d(${shadowPos.x - shadowTranslate}px, ${shadowPos.y - 100\r\n      }px, 0) rotate(${angle}rad)`;\r\n    this.innerShadow.style.clipPath = polygon;\r\n    this.innerShadow.style.setProperty('-webkit-clip-path', polygon);\r\n  }\r\n\r\n  /**\r\n   * Draw outer shadow to the soft page\r\n   */\r\n  private drawOuterShadow(): void {\r\n    const rect = this.getRect();\r\n\r\n    const shadowPos = this.convertToGlobal({ x: this.shadow.pos.x, y: this.shadow.pos.y });\r\n\r\n    const angle = this.shadow.angle + (3 * Math.PI) / 2;\r\n    const shadowTranslate = this.getDirection() === FlipDirection.BACK ? this.shadow.width : 0;\r\n\r\n    const shadowDirection =\r\n      this.getDirection() === FlipDirection.FORWARD ? 'to right' : 'to left';\r\n\r\n    const clip = [\r\n      { x: 0, y: 0 },\r\n      { x: rect.pageWidth, y: 0 },\r\n      { x: rect.pageWidth, y: rect.height },\r\n      { x: 0, y: rect.height },\r\n    ];\r\n\r\n    let polygon = 'polygon( ';\r\n    for (const p of clip) {\r\n      if (p !== null) {\r\n        let g =\r\n          this.getDirection() === FlipDirection.BACK\r\n            ? {\r\n              x: -p.x + this.shadow.pos.x,\r\n              y: p.y - this.shadow.pos.y,\r\n            }\r\n            : {\r\n              x: p.x - this.shadow.pos.x,\r\n              y: p.y - this.shadow.pos.y,\r\n            };\r\n\r\n        g = Helper.GetRotatedPoint(g, { x: shadowTranslate, y: 100 }, angle);\r\n\r\n        polygon += g.x + 'px ' + g.y + 'px, ';\r\n      }\r\n    }\r\n\r\n    polygon = polygon.slice(0, -2);\r\n    polygon += ')';\r\n\r\n    // const newStyle = `\r\n    //         display: block;\r\n    //         z-index: ${(this.getSettings().startZIndex + 10).toString(10)};\r\n    //         width: ${this.shadow.width}px;\r\n    //         height: ${rect.height * 2}px;\r\n    //         background: linear-gradient(${shadowDirection}, rgba(0, 0, 0, ${this.shadow.opacity\r\n    //   }), rgba(0, 0, 0, 0));\r\n    //         transform-origin: ${shadowTranslate}px 100px;\r\n    //         transform: translate3d(${shadowPos.x - shadowTranslate}px, ${shadowPos.y - 100\r\n    //   }px, 0) rotate(${angle}rad);\r\n    //         clip-path: ${polygon};\r\n    //         -webkit-clip-path: ${polygon};\r\n    //     `;\r\n\r\n    // this.outerShadow.style.cssText = newStyle;\r\n\r\n    this.outerShadow.style.display = 'block';\r\n    this.outerShadow.style.zIndex = (this.getSettings().startZIndex + 10).toString(10);\r\n    this.outerShadow.style.width = this.shadow.width + 'px';\r\n    this.outerShadow.style.height = rect.height * 2 + 'px';\r\n    this.outerShadow.style.background = `linear-gradient(${shadowDirection}, rgba(0, 0, 0, ${this.shadow.opacity}), rgba(0, 0, 0, 0))`;\r\n    this.outerShadow.style.transformOrigin = shadowTranslate + 'px 100px';\r\n    this.outerShadow.style.transform = `translate3d(${shadowPos.x - shadowTranslate}px, ${shadowPos.y - 100\r\n      }px, 0) rotate(${angle}rad)`;\r\n    this.outerShadow.style.clipPath = polygon;\r\n    this.outerShadow.style.setProperty('-webkit-clip-path', polygon);\r\n  }\r\n\r\n  /**\r\n   * Draw left static page\r\n   */\r\n  private drawLeftPage(): void {\r\n    if (this.orientation === Orientation.PORTRAIT || this.leftPage === null) return;\r\n\r\n    if (\r\n      this.direction === FlipDirection.BACK &&\r\n      this.flippingPage !== null &&\r\n      this.flippingPage.getDrawingDensity() === PageDensity.HARD\r\n    ) {\r\n      (this.leftPage as HTMLPage).getElement().style.zIndex = (\r\n        this.getSettings().startZIndex + 5\r\n      ).toString(10);\r\n\r\n      this.leftPage.setHardDrawingAngle(180 + this.flippingPage.getHardAngle());\r\n      this.leftPage.draw(this.flippingPage.getDrawingDensity());\r\n    } else {\r\n      this.leftPage.simpleDraw(PageOrientation.LEFT);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Draw right static page\r\n   */\r\n  private drawRightPage(): void {\r\n    if (this.rightPage === null) return;\r\n\r\n    if (\r\n      this.direction === FlipDirection.FORWARD &&\r\n      this.flippingPage !== null &&\r\n      this.flippingPage.getDrawingDensity() === PageDensity.HARD\r\n    ) {\r\n      (this.rightPage as HTMLPage).getElement().style.zIndex = (\r\n        this.getSettings().startZIndex + 5\r\n      ).toString(10);\r\n\r\n      this.rightPage.setHardDrawingAngle(180 + this.flippingPage.getHardAngle());\r\n      this.rightPage.draw(this.flippingPage.getDrawingDensity());\r\n    } else {\r\n      this.rightPage.simpleDraw(PageOrientation.RIGHT);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Draw the next page at the time of flipping\r\n   */\r\n  private drawBottomPage(): void {\r\n    if (this.bottomPage === null) return;\r\n\r\n    const tempDensity =\r\n      this.flippingPage != null ? this.flippingPage.getDrawingDensity() : null;\r\n\r\n    if (!(this.orientation === Orientation.PORTRAIT && this.direction === FlipDirection.BACK)) {\r\n      (this.bottomPage as HTMLPage).getElement().style.zIndex = (\r\n        this.getSettings().startZIndex + 3\r\n      ).toString(10);\r\n\r\n      this.bottomPage.draw(tempDensity);\r\n    }\r\n  }\r\n\r\n  protected drawFrame(): void {\r\n    this.clear();\r\n\r\n    this.drawLeftPage();\r\n\r\n    this.drawRightPage();\r\n\r\n    this.drawBottomPage();\r\n\r\n    if (this.flippingPage != null) {\r\n      (this.flippingPage as HTMLPage).getElement().style.zIndex = (\r\n        this.getSettings().startZIndex + 5\r\n      ).toString(10);\r\n\r\n      this.flippingPage.draw();\r\n    }\r\n\r\n    if (this.shadow != null && this.flippingPage !== null) {\r\n      if (this.flippingPage.getDrawingDensity() === PageDensity.SOFT) {\r\n        this.drawOuterShadow();\r\n        this.drawInnerShadow();\r\n      } else {\r\n        this.drawHardOuterShadow();\r\n        this.drawHardInnerShadow();\r\n      }\r\n    }\r\n  }\r\n\r\n  private clear(): void {\r\n    for (const page of this.app.getPageCollection().getPages()) {\r\n      if (\r\n        page !== this.leftPage &&\r\n        page !== this.rightPage &&\r\n        page !== this.flippingPage &&\r\n        page !== this.bottomPage\r\n      ) {\r\n        (page as HTMLPage).getElement().style.display = 'none';\r\n      }\r\n\r\n      if (page.getTemporaryCopy() !== this.flippingPage) {\r\n        page.hideTemporaryCopy();\r\n      }\r\n    }\r\n  }\r\n\r\n  public update(): void {\r\n    super.update();\r\n\r\n    if (this.rightPage !== null) {\r\n      this.rightPage.setOrientation(PageOrientation.RIGHT);\r\n    }\r\n\r\n    if (this.leftPage !== null) {\r\n      this.leftPage.setOrientation(PageOrientation.LEFT);\r\n    }\r\n  }\r\n}\r\n","import { PageCollection } from './Collection/PageCollection';\r\nimport { ImagePageCollection } from './Collection/ImagePageCollection';\r\nimport { HTMLPageCollection } from './Collection/HTMLPageCollection';\r\nimport { PageRect, Point } from './BasicTypes';\r\nimport { Flip, FlipCorner, FlippingState } from './Flip/Flip';\r\nimport { Orientation, Render } from './Render/Render';\r\nimport { CanvasRender } from './Render/CanvasRender';\r\nimport { HTMLUI } from './UI/HTMLUI';\r\nimport { CanvasUI } from './UI/CanvasUI';\r\nimport { Helper } from './Helper';\r\nimport { Page } from './Page/Page';\r\nimport { EventObject } from './Event/EventObject';\r\nimport { HTMLRender } from './Render/HTMLRender';\r\nimport { FlipSetting, Settings } from './Settings';\r\nimport { UI } from './UI/UI';\r\n\r\nimport './Style/stPageFlip.css';\r\n\r\n/**\r\n * Class representing a main PageFlip object\r\n *\r\n * @extends EventObject\r\n */\r\nexport class PageFlip extends EventObject {\r\n  private mousePosition: Point;\r\n  private isUserTouch = false;\r\n  private isUserMove = false;\r\n\r\n  private readonly setting: FlipSetting = null;\r\n  private readonly block: HTMLElement; // Root HTML Element\r\n\r\n  private pages: PageCollection = null;\r\n  private flipController: Flip;\r\n  private render: Render;\r\n\r\n  private ui: UI;\r\n\r\n  /**\r\n   * Create a new PageFlip instance\r\n   *\r\n   * @constructor\r\n   * @param {HTMLElement} inBlock - Root HTML Element\r\n   * @param {Object} setting - Configuration object\r\n   */\r\n  constructor(inBlock: HTMLElement, setting: Record<string, number | string | boolean>) {\r\n    super();\r\n\r\n    this.setting = new Settings().getSettings(setting);\r\n    this.block = inBlock;\r\n  }\r\n\r\n  /**\r\n   * Destructor. Remove a root HTML element and all event handlers\r\n   */\r\n  public destroy(): void {\r\n    this.ui.destroy();\r\n    this.block.remove();\r\n  }\r\n\r\n  /**\r\n   * Update the render area. Re-show current page.\r\n   */\r\n  public update(): void {\r\n    this.render.update();\r\n    this.pages.show();\r\n  }\r\n\r\n  /**\r\n   * Load pages from images on the Canvas mode\r\n   *\r\n   * @param {string[]} imagesHref - List of paths to images\r\n   */\r\n  public loadFromImages(imagesHref: string[]): void {\r\n    this.ui = new CanvasUI(this.block, this, this.setting);\r\n\r\n    const canvas = (this.ui as CanvasUI).getCanvas();\r\n    this.render = new CanvasRender(this, this.setting, canvas);\r\n\r\n    this.flipController = new Flip(this.render, this);\r\n\r\n    this.pages = new ImagePageCollection(this, this.render, imagesHref);\r\n    this.pages.load();\r\n\r\n    this.render.start();\r\n\r\n    this.pages.show(this.setting.startPage);\r\n\r\n    // safari fix\r\n    setTimeout(() => {\r\n      this.ui.update();\r\n      this.trigger('init', this, {\r\n        page: this.setting.startPage,\r\n        mode: this.render.getOrientation(),\r\n      });\r\n    }, 1);\r\n  }\r\n\r\n  /**\r\n   * Load pages from HTML elements on the HTML mode\r\n   *\r\n   * @param {(NodeListOf<HTMLElement>|HTMLElement[])} items - List of pages as HTML Element\r\n   */\r\n  public loadFromHTML(items: NodeListOf<HTMLElement> | HTMLElement[]): void {\r\n    this.ui = new HTMLUI(this.block, this, this.setting, items);\r\n\r\n    this.render = new HTMLRender(this, this.setting, this.ui.getDistElement(), items);\r\n\r\n    this.flipController = new Flip(this.render, this);\r\n\r\n    this.pages = new HTMLPageCollection(this, this.render, this.ui.getDistElement(), items);\r\n    this.pages.load();\r\n\r\n    this.render.start();\r\n\r\n    this.pages.show(this.setting.startPage);\r\n\r\n    // safari fix\r\n    setTimeout(() => {\r\n      this.ui.update();\r\n      this.trigger('init', this, {\r\n        page: this.setting.startPage,\r\n        mode: this.render.getOrientation(),\r\n      });\r\n    }, 1);\r\n  }\r\n\r\n  /**\r\n   * Update current pages from images\r\n   *\r\n   * @param {string[]} imagesHref - List of paths to images\r\n   */\r\n  public updateFromImages(imagesHref: string[]): void {\r\n    const current = this.pages.getCurrentPageIndex();\r\n\r\n    this.pages.destroy();\r\n    this.pages = new ImagePageCollection(this, this.render, imagesHref);\r\n    this.pages.load();\r\n\r\n    this.pages.show(current);\r\n    this.trigger('update', this, {\r\n      page: current,\r\n      mode: this.render.getOrientation(),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update current pages from HTML\r\n   *\r\n   * @param {(NodeListOf<HTMLElement>|HTMLElement[])} items - List of pages as HTML Element\r\n   */\r\n  public updateFromHtml(items: NodeListOf<HTMLElement> | HTMLElement[]): void {\r\n    const current = this.pages.getCurrentPageIndex();\r\n\r\n    this.pages.destroy();\r\n    this.pages = new HTMLPageCollection(this, this.render, this.ui.getDistElement(), items);\r\n    this.pages.load();\r\n    (this.ui as HTMLUI).updateItems(items);\r\n    (this.render as HTMLRender).updatePages();\r\n\r\n    this.pages.show(current);\r\n    this.trigger('update', this, {\r\n      page: current,\r\n      mode: this.render.getOrientation(),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Turn to the previous page (without animation)\r\n   */\r\n  public turnToPrevPage(): void {\r\n    this.pages.showPrev();\r\n  }\r\n\r\n  /**\r\n   * Turn to the next page (without animation)\r\n   */\r\n  public turnToNextPage(): void {\r\n    this.pages.showNext();\r\n  }\r\n\r\n  /**\r\n   * Turn to the specified page number (without animation)\r\n   *\r\n   * @param {number} page - New page number\r\n   */\r\n  public turnToPage(page: number): void {\r\n    this.pages.show(page);\r\n  }\r\n\r\n  /**\r\n   * Turn to the next page (with animation)\r\n   *\r\n   * @param {FlipCorner} corner - Active page corner when turning\r\n   */\r\n  public flipNext(corner: FlipCorner = FlipCorner.TOP): void {\r\n    this.flipController.flipNext(corner);\r\n  }\r\n\r\n  /**\r\n   * Turn to the prev page (with animation)\r\n   *\r\n   * @param {FlipCorner} corner - Active page corner when turning\r\n   */\r\n  public flipPrev(corner: FlipCorner = FlipCorner.TOP): void {\r\n    this.flipController.flipPrev(corner);\r\n  }\r\n\r\n  /**\r\n   * Turn to the specified page number (with animation)\r\n   *\r\n   * @param {number} page - New page number\r\n   * @param {FlipCorner} corner - Active page corner when turning\r\n   */\r\n  public flip(page: number, corner: FlipCorner = FlipCorner.TOP): void {\r\n    this.flipController.flipToPage(page, corner);\r\n  }\r\n\r\n  /**\r\n   * Call a state change event trigger\r\n   *\r\n   * @param {FlippingState} newState - New  state of the object\r\n   */\r\n  public updateState(newState: FlippingState): void {\r\n    this.trigger('changeState', this, newState);\r\n  }\r\n\r\n  /**\r\n   * Call a page number change event trigger\r\n   *\r\n   * @param {number} newPage - New page Number\r\n   */\r\n  public updatePageIndex(newPage: number): void {\r\n    this.trigger('flip', this, newPage);\r\n  }\r\n\r\n  /**\r\n   * Call a page orientation change event trigger. Update UI and rendering area\r\n   *\r\n   * @param {Orientation} newOrientation - New page orientation (portrait, landscape)\r\n   */\r\n  public updateOrientation(newOrientation: Orientation): void {\r\n    this.ui.setOrientationStyle(newOrientation);\r\n    this.update();\r\n    this.trigger('changeOrientation', this, newOrientation);\r\n  }\r\n\r\n  /**\r\n   * Get the total number of pages in a book\r\n   *\r\n   * @returns {number}\r\n   */\r\n  public getPageCount(): number {\r\n    return this.pages.getPageCount();\r\n  }\r\n\r\n  /**\r\n   * Get the index of the current page in the page list (starts at 0)\r\n   *\r\n   * @returns {number}\r\n   */\r\n  public getCurrentPageIndex(): number {\r\n    return this.pages.getCurrentPageIndex();\r\n  }\r\n\r\n  /**\r\n   * Get page from collection by number\r\n   *\r\n   * @param {number} pageIndex\r\n   * @returns {Page}\r\n   */\r\n  public getPage(pageIndex: number): Page {\r\n    return this.pages.getPage(pageIndex);\r\n  }\r\n\r\n  /**\r\n   * Get the current rendering object\r\n   *\r\n   * @returns {Render}\r\n   */\r\n  public getRender(): Render {\r\n    return this.render;\r\n  }\r\n\r\n  /**\r\n   * Get current object responsible for flipping\r\n   *\r\n   * @returns {Flip}\r\n   */\r\n  public getFlipController(): Flip {\r\n    return this.flipController;\r\n  }\r\n\r\n  /**\r\n   * Get current page orientation\r\n   *\r\n   * @returns {Orientation} Сurrent orientation: portrait or landscape\r\n   */\r\n  public getOrientation(): Orientation {\r\n    return this.render.getOrientation();\r\n  }\r\n\r\n  /**\r\n   * Get current book sizes and position\r\n   *\r\n   * @returns {PageRect}\r\n   */\r\n  public getBoundsRect(): PageRect {\r\n    return this.render.getRect();\r\n  }\r\n\r\n  /**\r\n   * Get configuration object\r\n   *\r\n   * @returns {FlipSetting}\r\n   */\r\n  public getSettings(): FlipSetting {\r\n    return this.setting;\r\n  }\r\n\r\n  /**\r\n   * Get UI object\r\n   *\r\n   * @returns {UI}\r\n   */\r\n  public getUI(): UI {\r\n    return this.ui;\r\n  }\r\n\r\n  /**\r\n   * Get current flipping state\r\n   *\r\n   * @returns {FlippingState}\r\n   */\r\n  public getState(): FlippingState {\r\n    return this.flipController.getState();\r\n  }\r\n\r\n  /**\r\n   * Get page collection\r\n   *\r\n   * @returns {PageCollection}\r\n   */\r\n  public getPageCollection(): PageCollection {\r\n    return this.pages;\r\n  }\r\n\r\n  /**\r\n   * Start page turning. Called when a user clicks or touches\r\n   *\r\n   * @param {Point} pos - Touch position in coordinates relative to the book\r\n   */\r\n  public startUserTouch(pos: Point): void {\r\n    this.mousePosition = pos; // Save touch position\r\n    this.isUserTouch = true;\r\n    this.isUserMove = false;\r\n  }\r\n\r\n  /**\r\n   * Called when a finger / mouse moves\r\n   *\r\n   * @param {Point} pos - Touch position in coordinates relative to the book\r\n   * @param {boolean} isTouch - True if there was a touch event, not a mouse click\r\n   */\r\n  public userMove(pos: Point, isTouch: boolean): void {\r\n    if (!this.isUserTouch && !isTouch && this.setting.showPageCorners) {\r\n      this.flipController.showCorner(pos); // fold Page Corner\r\n    } else if (this.isUserTouch) {\r\n      if (Helper.GetDistanceBetweenTwoPoint(this.mousePosition, pos) > 5) {\r\n        this.isUserMove = true;\r\n        this.flipController.fold(pos);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Сalled when the user has stopped touching\r\n   *\r\n   * @param {Point} pos - Touch end position in coordinates relative to the book\r\n   * @param {boolean} isSwipe - true if there was a mobile swipe event\r\n   */\r\n  public userStop(pos: Point, isSwipe = false): void {\r\n    if (this.isUserTouch) {\r\n      this.isUserTouch = false;\r\n\r\n      if (!isSwipe) {\r\n        if (!this.isUserMove) this.flipController.flip(pos);\r\n        else this.flipController.stopMove();\r\n      }\r\n    }\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport { PageFlip } from \"./PageFlip\";\r\n\r\nexport default class HTMLFlipBook extends React.Component {\r\n  componentDidMount() {\r\n    this.pageFlip = new PageFlip(this.el, this.props);\r\n\r\n    this.pageFlip.loadFromHTML(this.childRef);\r\n    this.setHandlers();\r\n  }\r\n\r\n  setHandlers() {\r\n    if (this.props.onFlip)\r\n      this.pageFlip.on(\"flip\", (e) => this.props.onFlip(e));\r\n\r\n    if (this.props.onChangeOrientation)\r\n      this.pageFlip.on(\"changeOrientation\", (e) =>\r\n        this.props.onChangeOrientation(e)\r\n      );\r\n\r\n    if (this.props.onChangeState)\r\n      this.pageFlip.on(\"changeState\", (e) => this.props.onChangeState(e));\r\n\r\n    if (this.props.onInit)\r\n      this.pageFlip.on(\"init\", (e) => this.props.onInit(e));\r\n\r\n    if (this.props.onUpdate)\r\n      this.pageFlip.on(\"update\", (e) => this.props.onUpdate(e));\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    this.pageFlip.destroy();\r\n    this.pageFlip = null;\r\n  }\r\n\r\n  componentDidUpdate(prevProps) {\r\n    if (prevProps.children !== this.props.children) {\r\n      this.pageFlip.off(\"flip\");\r\n      this.pageFlip.off(\"changeOrientation\");\r\n      this.pageFlip.off(\"changeState\");\r\n      this.pageFlip.off(\"init\");\r\n      this.pageFlip.off(\"update\");\r\n\r\n      this.pageFlip.updateFromHtml(this.childRef);\r\n      this.setHandlers();\r\n    }\r\n  }\r\n\r\n  getPageFlip() {\r\n    return this.pageFlip;\r\n  }\r\n\r\n  render() {\r\n    this.childRef = [];\r\n\r\n    const childWithRef = React.Children.map(this.props.children, (child) => {\r\n      return React.cloneElement(child, {\r\n        ref: (dom) => {\r\n          if (dom) this.childRef.push(dom);\r\n        },\r\n      });\r\n    });\r\n\r\n    return React.createElement(\r\n      \"div\",\r\n      {\r\n        ref: (el) => (this.el = el),\r\n        className: this.props.className,\r\n        style: this.props.style,\r\n      },\r\n      childWithRef\r\n    );\r\n  }\r\n}","import React from 'react'\r\nimport './Page.scss';\r\n\r\nconst Page = React.forwardRef((props, ref) => {\r\n  switch (props.type) {\r\n    case 'cover':\r\n      return (\r\n        <div\r\n          className={'page page-cover page-cover-' + props.pos}\r\n          ref={ref}\r\n          data-density='soft'\r\n        >\r\n          {(props.bookmark === true) ?\r\n            <img\r\n              className='bookmark'\r\n              src={process.env.PUBLIC_URL + '/bookmark.png'}\r\n              style={{ filter: 'invert(10%) sepia(96%) saturate(6344%) hue-rotate(1deg) brightness(121%) contrast(113%)' }}\r\n              alt=\"könyvjelző\"\r\n              title='Kinyitás a könyvjelzőnél'\r\n              onClick={props.onBookmark}\r\n            />\r\n            : null\r\n          }\r\n          <div className='page-content'>\r\n            <h2>{props.pageTitle}</h2>\r\n          </div>\r\n        </div>\r\n      );\r\n\r\n    case 'html':\r\n      return <div className={'page ' + (props.no_animation ? 'no-animation' : '')} ref={ref} data-density='soft'>\r\n        <div className=\"page-content\">\r\n          {(props.pageTitle !== undefined) ?\r\n            <h2 className='page-header'>{props.pageTitle}</h2> : null\r\n          }\r\n          <div className=\"page-text\">\r\n            {(props.content.image !== null && props.content.image !== '') ?\r\n              <img style={{ margin: '1%', float: 'left' }} src={process.env.PUBLIC_URL + '/' + props.content.image} width='40%' alt=\"\"></img> : null\r\n            }\r\n            <div dangerouslySetInnerHTML={{ __html: props.content.html }}></div>\r\n          </div>\r\n        </div>\r\n      </div>;\r\n\r\n    case 'contents':\r\n    case 'chapter':\r\n    case 'image':\r\n      return (\r\n        <div className={'page ' + (props.no_animation ? 'no-animation' : '')} ref={ref} data-density='soft'>\r\n          <div className='page-content'>\r\n            <div>\r\n              {(props.pageTitle !== undefined) ?\r\n                <h2 className='page-header'>{props.pageTitle}</h2> : null\r\n              }\r\n              {(props.image !== undefined) ?\r\n                <div className='page-image'>\r\n                  <figure>\r\n                    <img\r\n                      alt={props.imageCaption}\r\n                      src={props.image}\r\n                      onClick={showFullImage}\r\n                      onLoad={setDimensions}\r\n                    ></img>\r\n                    <figcaption>{props.imageCaption}</figcaption>\r\n                  </figure>\r\n                </div>\r\n                : null\r\n              }\r\n            </div>\r\n            {(props.children) ? <div className='page-text'>{props.children}</div> : null}\r\n            <div className='page-footer'>{isNaN(props.pageNumber) ? '' : props.pageNumber}</div>\r\n          </div>\r\n        </div >\r\n      );\r\n\r\n    default:\r\n      throw new Error('unrecognizable or missing page type');\r\n  }\r\n\r\n\r\n  function setDimensions(e) {\r\n    e.target.style = (e.target.width > e.target.height) ? 'width: 100%' : 'height: 100%';\r\n  }\r\n\r\n  function showFullImage(e) {\r\n    console.log('props', props);\r\n    console.log('ref', ref);\r\n    e.target.requestFullscreen().then(() => {\r\n\r\n    });\r\n  }\r\n});\r\n\r\nexport { Page };","class Router {\r\n  routes = [];\r\n\r\n  mode = null;\r\n\r\n  root = '/';\r\n\r\n  constructor(options) {\r\n    this.mode = window.history.pushState ? 'history' : 'hash';\r\n    if (options.mode) this.mode = options.mode;\r\n    if (options.root) this.root = options.root;\r\n    this.listen();\r\n  }\r\n\r\n  add = (path, cb) => {\r\n    this.routes.push({ path, cb });\r\n    return this;\r\n  };\r\n\r\n  remove = path => {\r\n    for (let i = 0; i < this.routes.length; i += 1) {\r\n      if (this.routes[i].path === path) {\r\n        this.routes.slice(i, 1);\r\n        return this;\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  flush = () => {\r\n    this.routes = [];\r\n    return this;\r\n  };\r\n\r\n  clearSlashes = path =>\r\n    path\r\n      .toString()\r\n      .replace(/\\/$/, '')\r\n      .replace(/^\\//, '');\r\n\r\n  getFragment = () => {\r\n    let fragment = '';\r\n    if (this.mode === 'history') {\r\n      fragment = this.clearSlashes(decodeURI(window.location.pathname + window.location.search));\r\n      fragment = fragment.replace(/\\?(.*)$/, '');\r\n      fragment = this.root !== '/' ? fragment.replace(this.root, '') : fragment;\r\n    } else {\r\n      const match = window.location.href.match(/#(.*)$/);\r\n      fragment = match ? match[1] : '';\r\n    }\r\n    return this.clearSlashes(fragment);\r\n  };\r\n\r\n  navigate = (path = '') => {\r\n    if (this.mode === 'history') {\r\n      window.history.pushState(null, null, this.root + this.clearSlashes(path));\r\n    } else {\r\n      window.location.href = `${window.location.href.replace(/#(.*)$/, '')}#${path}`;\r\n    }\r\n    return this;\r\n  };\r\n\r\n  listen = () => {\r\n    clearInterval(this.interval);\r\n    this.interval = setInterval(this.interval, 50);\r\n  };\r\n\r\n  interval = () => {\r\n    if (this.current === this.getFragment()) return;\r\n    this.current = this.getFragment();\r\n\r\n    this.routes.some(route => {\r\n      const match = this.current.match(route.path);\r\n      if (match) {\r\n        match.shift();\r\n        route.cb.apply({}, match);\r\n        return match;\r\n      }\r\n      return false;\r\n    });\r\n  };\r\n}\r\n\r\nexport default Router;","/* eslint-disable no-restricted-globals */\r\nimport React from 'react'\r\nimport HTMLFlipBook from '../PageFlip/react-pageflip';\r\nimport './ImageBook.scss';\r\nimport { Page } from './Page/Page';\r\nimport Router from '../Router';\r\n\r\nclass ImageBook extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    // const cvPageParts = [\r\n    //   [\r\n    //     <article style={{ padding: '2%' }}>\r\n    //       <img style={{ margin: '1%', float: 'left' }} width='40%' src={profile_pic} alt='Alim Adilov'></img>Alim Adilov Üzbegisztán fõvárosában, Taskentben született 1963 - ban és gyerekkorában elkezdett járni mûvészeti szakkörre, ahol Zója Grigorevna kiváló festõmûvésznõ tanította. 8 éves iskolai végzettség után Taskentben 4 éves Mûvészeti technikumot végzett.\r\n    //       Katonai szolgálat után felvételizett az európai hirû szentpétervári \"Repin\" Képzõmûvészeti Akadémiara és ott 6 évig tanult, közben részt vett csoportos kiállításokban Szovjetunióban és számos külföldi országban. Az Akadémia elvégzése után elutazott Londonba, ahol részt vett a \"Canvas\" mûvészeti tanfolyamban.\r\n    //       <br />\r\n    //       <br />\r\n    //     </article>,\r\n    //     <article style={{ padding: '2%' }}>\r\n    //       1993 óta hazankban él és alkot. 2004-tõl a Magyar Alkotomûvészek Országos Egyesületének tagja. Többnyire vegyes technikával, vegyes témákban dolgozik. Mûvésztelepeknek rendszeres tagja.\r\n    //       <br />\"Alim Adilov festõmûvész rohanó életünk elé olyan festményeket állít, melyekbõl sugárzik a természet varázsa és a Teremtõ jósága. Képei, mint bástyák dacolnak a háborgó világ forgatagával, idõk és korok múlásával.\"\r\n    //       <br />\r\n    //       <br />\r\n    //       Csoportos kiállitások: Szentpétervár, Moszkva, Rosztov, Taskent, Tokyo, Kuala Lumpur, Budapest, Debrecen, Békéscsaba\r\n    //       Önálló kiállítások: London, Békéscsaba, Miskolc, Debrecen, Gödöllõ, Kecskemét, Budapest, Malaysia (Puchong), Kuala Lumpur\r\n    //       Állandó kiállítás: Madeira\r\n    //     </article>\r\n    //   ],\r\n    //   [\r\n    //     <article style={{ padding: '2%' }}>\r\n    //       <img style={{ margin: '1%', float: 'left' }} width='40%' src={profile_pic} alt='Alim Adilov'></img>Alim Adilov is a painter, was born in 1963, Taskent, Uzbekistan.\r\n    //       <br />During his elementary studies he was enrolled to the best drawing course in the city.\r\n    //       <br />In 1979 he started the secondary art school, where strict but highly skilled teachers taught him, like the Korean Emil-Ki-Gajt, who did several successful book illustrations or the internationally reputed Vitrugonszkji. In his 5th year, he learned on advanced level.\r\n    //       <br />He grew up to become an artist who is ready to work with full responsibility.\r\n    //       <br />After 2 years military service, he applied to the world famous Repin Art Academy.\r\n    //       <br />\r\n    //     </article>,\r\n    //     <article style={{ padding: '2%' }}>\r\n    //       After graduating he went to England where he was a designer at a big company, so soon he could start working individually. In 1991, he got a work from an elegant gallery from the London Sloan Square, to organize an exhibition from his works. All of his paintings were purchased at once.\r\n    //       <br />After settling down in Hungary, he soon became popular both in the professional and artistic fields. Besides his professional success, he found his personal happiness and his wife. They have 2 great sons. In the next couple of years, he was the regular invited member of the art camps in Hungary and in international camps.\r\n    //       <br />\r\n    //     </article>,\r\n    //     <article style={{ padding: '2%' }}>\r\n    //       He is the member of the Hungarian Art Association.\r\n    //       <br />His paintings are often bought because this way the buyers can take home a slice from the East, from their holiday. The vivid colors of the paintings are reflecting the beach, the market, so the owners can feel these moments in their weekdays.\r\n    //       <br />Favourably, he works on those topics which he experienced on his journey. Cities, landscapes, houses but also portraits, still lifes. All over the world he had solo and organised exhibitions and he has a permanent exhibition on Madeira.\r\n    //     </article>\r\n    //   ]\r\n    // ];\r\n\r\n    // let cv = [];\r\n    // let cvPageNumbers = 0;\r\n\r\n    // const mainPageData = {\r\n    //   cv: [\"Önéletrajz\", \"Autobiography\"],\r\n    //   toc: [\"Tartalomjegyzék\", \"Contents\"]\r\n    // };\r\n\r\n    // if (isMobile) {\r\n    //   cv = cvPageParts[language].map((part, i) => <Page key={i + 1} pageNumber={i + 1} pageTitle={mainPageData.cv[language]}>{part}</Page>);\r\n    //   cvPageNumbers = cvPageParts[language].length;\r\n    // }\r\n    // else {\r\n    //   cv = <Page key={1} pageNumber={1} pageTitle={mainPageData.cv[language]}>\r\n    //     {cvPageParts[language].reduce((res, part, i) => {\r\n    //       res.push(part.props.children);\r\n    //       return res;\r\n    //     }, [])}\r\n    //   </Page>;\r\n    //   cvPageNumbers = 1;\r\n    // }\r\n\r\n    // const pageData = pageArray;\r\n\r\n    // const categories = pageData.reduce((res, page, i) => {\r\n    //   if (page.type === 'category') res.push({\r\n    //     pagenumber: i,\r\n    //     page\r\n    //   });\r\n    //   return res;\r\n    // }, []);\r\n\r\n    // // Cover + ToC = 2\r\n    // const pageOffset = cvPageNumbers + 2;\r\n\r\n    // const pages = [\r\n    //   <PageCover key={0} pos='top' bookmark image={process.env.PUBLIC_URL + '/h608.jpg'} onBookmark={this.openBookmark}>Alim Adilov képeskönyve</PageCover>,\r\n    //   cv,\r\n    //   <Page key={cvPageNumbers + 1} pageNumber={cvPageNumbers + 1} pageTitle={mainPageData.toc[language]}>\r\n    //     <ul className='toc'>\r\n    //       {categories.map(category =>\r\n    //         <li><a href={((routingStrategy === 'hash') ? '#/' : '') + String(pageOffset + category.pagenumber)} onClick={this.navigateToPage}>{category.page.pagetitle[language]}</a></li>\r\n    //       )}\r\n    //     </ul>\r\n    //   </Page>,\r\n    //   pageData.map((page, i) => {\r\n    //     // if (true) return this.createPage(page, pageOffset + i, language);\r\n    //     if (i < 5) return this.createPage(page, pageOffset + i, language);\r\n    //     else return <div></div>;\r\n    //   }),\r\n    //   <PageCover key={cvPageNumbers + 6} image={process.env.PUBLIC_URL + '/h608.jpg'} pos='bottom'></PageCover>\r\n    // ];\r\n\r\n    this.state = {\r\n      language: 0,\r\n      // pageOffset,\r\n      // mainPageData,\r\n      // renderedPages: [<Page type=\"cover\" key=\"1\"></Page>, <Page type=\"cover\" key=\"2\"></Page>, <Page type=\"cover\" key=\"3\"></Page>, <Page type=\"cover\" key=\"4\"></Page>, <Page type=\"cover\" key=\"5\"></Page>, <Page type=\"cover\" key=\"6\"></Page>,],\r\n      renderedPages: [],\r\n      pageData: {\r\n        chapters: [],\r\n        pageOfContents: 0,\r\n        pages: []\r\n      },\r\n      routingStrategy: 'hash',\r\n      bookmark: null,\r\n      page: 0,\r\n      orientation: 'landscape',\r\n      state: 'read',\r\n      // totalPage: 0,\r\n      router: null,\r\n    };\r\n  }\r\n\r\n  // Lifecycle management\r\n  componentDidMount() {\r\n\r\n    fetch(process.env.PUBLIC_URL + '/pages.json', {\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'Accept': 'application/json'\r\n      }\r\n    }).then(res => {\r\n      res.json().then(pageArray => {\r\n        // console.log(res);\r\n        // console.log(window.innerWidth);\r\n        // const isMobile = window.innerWidth < 1440;\r\n\r\n        const pageData = pageArray.reduce((res, page, i) => {\r\n          if (page.type === 'chapter') res.chapters.push({\r\n            pagetitle: page.pagetitle,\r\n            pagenumber: i\r\n          });\r\n          if (page.type === 'contents') {\r\n            res.pageOfContents = i;\r\n          }\r\n\r\n          let inputProps = {\r\n            key: i,\r\n            pageNumber: i,\r\n            type: page.type,\r\n            pageTitle: (page.pagetitle) ? page.pagetitle[this.state.language] : undefined\r\n          };\r\n          if (i === 0) {\r\n            inputProps.bookmark = true;\r\n            inputProps.onBookmark = this.openBookmark;\r\n            inputProps.pos = 'top';\r\n          }\r\n          if (i === pageArray.length - 1) {\r\n            inputProps.pos = 'bottom';\r\n          }\r\n          if (page.imagename) {\r\n            inputProps.image = process.env.PUBLIC_URL + '/' + page.imagename;\r\n            inputProps.imageCaption = page.imagecaption[this.state.language]\r\n          }\r\n          if (page.type === 'html') {\r\n            inputProps.content = page.content[this.state.language];\r\n          }\r\n\r\n          res.pages.push(\r\n            <Page\r\n              {...inputProps}\r\n            ></Page>\r\n          );\r\n          return res;\r\n        }, {\r\n          chapters: [],\r\n          pageOfContents: 0,\r\n          pages: []\r\n        });\r\n\r\n        pageData.pages[pageData.pageOfContents] = <Page type='contents' key={pageData.pageOfContents} pageNumber={pageData.pageOfContents} pageTitle={pageArray[pageData.pageOfContents].pagetitle[this.state.language]}>\r\n          <ul className='contents'>\r\n            {pageData.chapters.map((chapter, i) =>\r\n              <li key={i}><a href={((this.state.routingStrategy === 'hash') ? '#/' : '') + String(chapter.pagenumber)} onClick={this.navigateToPage}>{chapter.pagetitle[this.state.language]}</a></li>\r\n            )}\r\n          </ul>\r\n        </Page>;\r\n\r\n        const renderedPages = pageData.pages.slice(0, 6);\r\n\r\n        const router = new Router({ mode: this.state.routingStrategy });\r\n        // console.log(router.getFragment());\r\n\r\n        // const page = this.setupRoute();\r\n        let page = 0;\r\n        if (this.isNumeric(router.getFragment())) {\r\n          page = Number(router.getFragment());\r\n        } else {\r\n          router.navigate('/0');\r\n        }\r\n        const bookmark = Number(localStorage.getItem('bookmark'));\r\n\r\n        this.setState((state, props) => ({\r\n          renderedPages,\r\n          pageData,\r\n          // totalPage: this.flipBook.getPageFlip().getPageCount(),\r\n          page: page,\r\n          bookmark: bookmark,\r\n          router: router\r\n        }), () => {\r\n          this.forceUpdate();\r\n          if (this.state.page > 0) this.flipToPage();\r\n        });\r\n\r\n\r\n      }, err => {\r\n        alert('Nem sikerült betölteni az oldalt!');\r\n        console.error(err);\r\n      });\r\n    }, err => {\r\n      alert('Nem sikerült betölteni az oldalt.');\r\n      console.error(err);\r\n    });\r\n  }\r\n\r\n  // Event handlers\r\n\r\n  nextButtonClick = () => {\r\n    this.setState((state, props) => ({\r\n      page: (state.totalPage > state.page) ? state.page + 1 : state.page,\r\n    }), (e) => {\r\n      this.flipToPage();\r\n    });\r\n  };\r\n\r\n  prevButtonClick = () => {\r\n    this.setState((state, props) => ({\r\n      page: (0 < state.page) ? state.page - 1 : state.page,\r\n    }), () => {\r\n      this.flipToPage();\r\n    });\r\n  };\r\n\r\n  onPage = (e) => {\r\n    this.setState((state, props) => ({\r\n      page: e.data,\r\n    }), () => {\r\n      // eslint-disable-next-line no-restricted-globals\r\n      this.state.router.navigate('/' + this.state.page);\r\n      // history.pushState(e.data, '', e.data);\r\n    });\r\n  };\r\n\r\n  onChangeOrientation = (e) => {\r\n    this.setState((state, props) => ({\r\n      orientation: e.data,\r\n    }));\r\n  }\r\n\r\n  // onChangeState = (e) => {\r\n  //   this.setState((state, props) => ({\r\n  //     state: e.data,\r\n  //   }));\r\n  // }\r\n\r\n  createPage(page, pagenumber, language) {\r\n    return <Page\r\n      key={pagenumber}\r\n      pageNumber={pagenumber}\r\n      image={process.env.PUBLIC_URL + '/' + page.imagename}\r\n      imageCaption={page.imagecaption[language]}\r\n      // {(page.type === 'category') ? page.pagetitle[language] : null}\r\n      pageTitle={(page.type === 'category') ? page.pagetitle[language] : undefined}\r\n    ></Page>;\r\n  }\r\n\r\n  flipToPage = () => {\r\n    console.log(this.state.page);\r\n    // this.setState((state, props) => ({\r\n    //   pages: this.state.pages.splice(this.state.pages.length - 1, 0,\r\n    //     this.createPage(this.state.pageData[this.state.page - this.state.pageOffset], this.state.language),\r\n    //   )\r\n    // }), () => {\r\n    //   this.flipBook.getPageFlip().flip(Number(this.state.page));\r\n    // });\r\n    this.flipBook.getPageFlip().flip(Number(this.state.page));\r\n  }\r\n\r\n  addPageToBookmark = () => {\r\n    this.setState((state, props) => ({\r\n      bookmark: this.state.page\r\n    }), () => {\r\n      localStorage.setItem('bookmark', this.state.bookmark);\r\n    });\r\n  }\r\n\r\n  openBookmark = () => {\r\n    // console.log(this.state);\r\n    this.setState((state, props) => ({\r\n      page: this.state.bookmark\r\n    }), () => {\r\n      this.flipToPage();\r\n    });\r\n  }\r\n\r\n  // Routing\r\n\r\n  navigateToPage = (e) => {\r\n    e.preventDefault();\r\n    this.setState((state, props) => ({\r\n      // page: Number(e.target.pathname.substring(1).split('/')[1]),\r\n      page: Number(e.target.hash.substring(1).split('/')[1]),\r\n    }), () => {\r\n      this.flipToPage();\r\n    });\r\n  }\r\n\r\n  updateBook = () => {\r\n    this.setState((state, props) => ({\r\n      renderedPages: this.state.pageData.pages\r\n    }));\r\n  }\r\n\r\n  // setupRoute() {\r\n\r\n  //   console.log('TODO: window.location.pathname', window.location.pathname)\r\n  //   let page = 0;\r\n  //   if (this.pathArray().length > 3 || !this.isNumeric(this.pathArray()[2])) {\r\n  //     // history.pushState(window.location.pathname, '', '/book/0');\r\n  //     history.pushState(null, '', window.location.href + 'book/0');\r\n  //   } else {\r\n  //     page = Number(this.pathArray()[2]);\r\n  //   }\r\n  //   return page;\r\n  // }\r\n\r\n  // // Utility functions\r\n  // pathArray = () => {\r\n  //   return window.location.pathname.split('/');\r\n  // }\r\n\r\n  // https://stackoverflow.com/a/175787\r\n  isNumeric(str) {\r\n    if (typeof str != 'string') return false // we only process strings!\r\n    return !isNaN(str) && // use type coercion to parse the _entirety_ of the string (`parseFloat` alone does not do this)...\r\n      !isNaN(parseFloat(str)) // ...and ensure strings of whitespace fail\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      // <div className='no-select book-container'\r\n      <div className='book-container container-md'\r\n      // style={{ maxHeight: '100vh', maxWidth: '100vw', display: 'flex', flexDirection: 'column', alignItems: 'center', position: 'relative' }}\r\n      >\r\n        {/* <span>{this.state.isMobile}</span> */}\r\n        <button type={'button'} className={'mt-1 btn btn-success'} onClick={this.addPageToBookmark} title={'Oldal könyvjelzőzése'}>\r\n          <svg xmlns={'http://www.w3.org/2000/svg'} width={'16'} height={'16'} fill={'currentColor'} className={'bi bi-bookmark-plus'} viewBox={'0 0 16 16'}>\r\n            <path fillRule={'evenodd'} d={'M8 4a.5.5 0 0 1 .5.5V6H10a.5.5 0 0 1 0 1H8.5v1.5a.5.5 0 0 1-1 0V7H6a.5.5 0 0 1 0-1h1.5V4.5A.5.5 0 0 1 8 4z'} />\r\n            <path d={'M2 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v13.5a.5.5 0 0 1-.777.416L8 13.101l-5.223 2.815A.5.5 0 0 1 2 15.5V2zm2-1a1 1 0 0 0-1 1v12.566l4.723-2.482a.5.5 0 0 1 .554 0L13 14.566V2a1 1 0 0 0-1-1H4z'} />\r\n          </svg>\r\n        </button>\r\n        <button type={'button'} className={'mt-1 btn btn-danger'} onClick={this.openBookmark} title={'Oldal kinyitása a könyvjelzőhöz'}>\r\n          <svg xmlns={'http://www.w3.org/2000/svg'} width={'16'} height={'16'} fill={'currentColor'} className={'bi bi-bookmark-plus'} viewBox={'0 0 16 16'}>\r\n            <path fillRule={'evenodd'} d={'M8 4a.5.5 0 0 1 .5.5V6H10a.5.5 0 0 1 0 1H8.5v1.5a.5.5 0 0 1-1 0V7H6a.5.5 0 0 1 0-1h1.5V4.5A.5.5 0 0 1 8 4z'} />\r\n            <path d={'M2 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v13.5a.5.5 0 0 1-.777.416L8 13.101l-5.223 2.815A.5.5 0 0 1 2 15.5V2zm2-1a1 1 0 0 0-1 1v12.566l4.723-2.482a.5.5 0 0 1 .554 0L13 14.566V2a1 1 0 0 0-1-1H4z'} />\r\n          </svg>\r\n        </button>\r\n        <button className=\"mt-1 btn btn-primary\" onClick={this.updateBook}></button>\r\n        <span>{this.state.bookmark}</span>\r\n        {(this.state.renderedPages.length > 0) ?\r\n          <HTMLFlipBook\r\n            width={550}\r\n            height={733}\r\n            size='stretch'\r\n            minWidth={315}\r\n            minHeight={400}\r\n            maxWidth={1000}\r\n            maxHeight={1533}\r\n            maxShadowOpacity={0.5}\r\n            flippingTime={700}\r\n            showCover={true}\r\n            mobileScrollSupport={true}\r\n            clickEventForward={['img', 'button', 'a']}\r\n            drawShadow={true}\r\n            swipeDistance={0}\r\n            useMouseEvents={true}\r\n\r\n            onFlip={this.onPage}\r\n            onChangeOrientation={this.onChangeOrientation}\r\n            onChangeState={this.onChangeState}\r\n\r\n            className='image-book'\r\n\r\n            ref={(el) => (this.flipBook = el)}\r\n          >\r\n            {this.state.renderedPages}\r\n          </HTMLFlipBook> : null}\r\n\r\n        {/* <div className='pageturner-container'>\r\n          <div>\r\n\r\n            <button type='button' onClick={this.prevButtonClick}>Előző oldal</button>\r\n\r\n            [<span>{this.state.page}</span> of <span> {this.state.totalPage} </span>]\r\n\r\n            <button type='button' onClick={this.nextButtonClick}>Következő oldal</button>\r\n          </div>\r\n        </div> */}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default ImageBook;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.scss';\r\nimport ImageBook from './ImageBook/ImageBook';\r\nimport reportWebVitals from './reportWebVitals';\r\n// import DemoBlock from './DemoBlock';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    {/* <DemoBlock /> */}\r\n    <ImageBook />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}